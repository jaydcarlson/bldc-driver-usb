   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"AdcLdd1.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.rodata.ChannelToPin,"a",%progbits
  19              		.align	2
  22              	ChannelToPin:
  23 0000 4E       		.byte	78
  24 0001 4F       		.byte	79
  25 0002 0000     		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  26              		.align	2
  29              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  30 0000 00000000 		.space	8
  30      00000000 
  31              		.section	.bss.INT_ADC0__DEFAULT_RTOS_ISRPARAM,"aw",%nobits
  32              		.align	2
  35              	INT_ADC0__DEFAULT_RTOS_ISRPARAM:
  36 0000 00000000 		.space	4
  37              		.section	.text.AdcLdd1_Init,"ax",%progbits
  38              		.align	2
  39              		.global	AdcLdd1_Init
  40              		.thumb
  41              		.thumb_func
  43              	AdcLdd1_Init:
  44              	.LFB0:
  45              		.file 1 "../Generated_Code/AdcLdd1.c"
   1:../Generated_Code/AdcLdd1.c **** /* ###################################################################
   2:../Generated_Code/AdcLdd1.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/AdcLdd1.c **** **     Filename    : AdcLdd1.c
   4:../Generated_Code/AdcLdd1.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/AdcLdd1.c **** **     Processor   : MK20DX128VLH5
   6:../Generated_Code/AdcLdd1.c **** **     Component   : ADC_LDD
   7:../Generated_Code/AdcLdd1.c **** **     Version     : Component 01.182, Driver 01.08, CPU db: 3.00.000
   8:../Generated_Code/AdcLdd1.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/AdcLdd1.c **** **     Date/Time   : 2013-12-15, 00:20, # CodeGen: 20
  10:../Generated_Code/AdcLdd1.c **** **     Abstract    :
  11:../Generated_Code/AdcLdd1.c **** **         This device "ADC_LDD" implements an A/D converter,
  12:../Generated_Code/AdcLdd1.c **** **         its control methods and interrupt/event handling procedure.
  13:../Generated_Code/AdcLdd1.c **** **     Settings    :
  14:../Generated_Code/AdcLdd1.c **** **          Component name                                 : AdcLdd1
  15:../Generated_Code/AdcLdd1.c **** **          A/D converter                                  : ADC0
  16:../Generated_Code/AdcLdd1.c **** **          Discontinuous mode                             : no
  17:../Generated_Code/AdcLdd1.c **** **          Interrupt service/event                        : Enabled
  18:../Generated_Code/AdcLdd1.c **** **            A/D interrupt                                : INT_ADC0
  19:../Generated_Code/AdcLdd1.c **** **            A/D interrupt priority                       : medium priority
  20:../Generated_Code/AdcLdd1.c **** **          DMA                                            : Disabled
  21:../Generated_Code/AdcLdd1.c **** **          A/D channel list                               : 2
  22:../Generated_Code/AdcLdd1.c **** **            Channel 0                                    : 
  23:../Generated_Code/AdcLdd1.c **** **              Channel mode                               : Single Ended
  24:../Generated_Code/AdcLdd1.c **** **                Input                                    : 
  25:../Generated_Code/AdcLdd1.c **** **                  A/D channel (pin)                      : ADC0_SE14/TSI0_CH13/PTC0/SPI0_PCS4/PDB
  26:../Generated_Code/AdcLdd1.c **** **                  A/D channel (pin) signal               : 
  27:../Generated_Code/AdcLdd1.c **** **            Channel 1                                    : 
  28:../Generated_Code/AdcLdd1.c **** **              Channel mode                               : Single Ended
  29:../Generated_Code/AdcLdd1.c **** **                Input                                    : 
  30:../Generated_Code/AdcLdd1.c **** **                  A/D channel (pin)                      : ADC0_SE15/TSI0_CH14/PTC1/LLWU_P6/SPI0_
  31:../Generated_Code/AdcLdd1.c **** **                  A/D channel (pin) signal               : 
  32:../Generated_Code/AdcLdd1.c **** **          Static sample groups                           : Disabled
  33:../Generated_Code/AdcLdd1.c **** **          A/D resolution                                 : 16 bits
  34:../Generated_Code/AdcLdd1.c **** **          Low-power mode                                 : Disabled
  35:../Generated_Code/AdcLdd1.c **** **          High-speed conversion mode                     : Disabled
  36:../Generated_Code/AdcLdd1.c **** **          Asynchro clock output                          : Disabled
  37:../Generated_Code/AdcLdd1.c **** **          Sample time                                    : 4 clock periods
  38:../Generated_Code/AdcLdd1.c **** **          Number of conversions                          : 1
  39:../Generated_Code/AdcLdd1.c **** **          Conversion time                                : 6 µs
  40:../Generated_Code/AdcLdd1.c **** **          ADC clock                                      : 4 MHz (250 ns)
  41:../Generated_Code/AdcLdd1.c **** **          Single conversion time - Single-ended          : 7.604 us
  42:../Generated_Code/AdcLdd1.c **** **          Single conversion time - Differential          : 9.854 us
  43:../Generated_Code/AdcLdd1.c **** **          Additional conversion time - Single-ended      : 6.25 us
  44:../Generated_Code/AdcLdd1.c **** **          Additional conversion time - Differential      : 8.5 us
  45:../Generated_Code/AdcLdd1.c **** **          Result type                                    : unsigned 16 bits, right justified
  46:../Generated_Code/AdcLdd1.c **** **          Trigger                                        : Disabled
  47:../Generated_Code/AdcLdd1.c **** **          Voltage reference                              : 
  48:../Generated_Code/AdcLdd1.c **** **            High voltage reference                       : 
  49:../Generated_Code/AdcLdd1.c **** **              Volt. ref. pin                             : VREFH
  50:../Generated_Code/AdcLdd1.c **** **              Volt. ref pin signal                       : 
  51:../Generated_Code/AdcLdd1.c **** **            Low voltage reference                        : 
  52:../Generated_Code/AdcLdd1.c **** **              Volt. ref. pin                             : VREFL
  53:../Generated_Code/AdcLdd1.c **** **              Volt. ref pin signal                       : 
  54:../Generated_Code/AdcLdd1.c **** **          Initialization                                 : 
  55:../Generated_Code/AdcLdd1.c **** **            Enabled in init. code                        : yes
  56:../Generated_Code/AdcLdd1.c **** **            Auto initialization                          : no
  57:../Generated_Code/AdcLdd1.c **** **            Event mask                                   : 
  58:../Generated_Code/AdcLdd1.c **** **              OnMeasurementComplete                      : Enabled
  59:../Generated_Code/AdcLdd1.c **** **              OnError                                    : Disabled
  60:../Generated_Code/AdcLdd1.c **** **          CPU clock/configuration selection              : 
  61:../Generated_Code/AdcLdd1.c **** **            Clock configuration 0                        : This component enabled
  62:../Generated_Code/AdcLdd1.c **** **            Clock configuration 1                        : This component disabled
  63:../Generated_Code/AdcLdd1.c **** **            Clock configuration 2                        : This component disabled
  64:../Generated_Code/AdcLdd1.c **** **            Clock configuration 3                        : This component disabled
  65:../Generated_Code/AdcLdd1.c **** **            Clock configuration 4                        : This component disabled
  66:../Generated_Code/AdcLdd1.c **** **            Clock configuration 5                        : This component disabled
  67:../Generated_Code/AdcLdd1.c **** **            Clock configuration 6                        : This component disabled
  68:../Generated_Code/AdcLdd1.c **** **            Clock configuration 7                        : This component disabled
  69:../Generated_Code/AdcLdd1.c **** **     Contents    :
  70:../Generated_Code/AdcLdd1.c **** **         Init                         - LDD_TDeviceData* AdcLdd1_Init(LDD_TUserData *UserDataPtr)
  71:../Generated_Code/AdcLdd1.c **** **         StartSingleMeasurement       - LDD_TError AdcLdd1_StartSingleMeasurement(LDD_TDeviceData
  72:../Generated_Code/AdcLdd1.c **** **         CancelMeasurement            - LDD_TError AdcLdd1_CancelMeasurement(LDD_TDeviceData *Dev
  73:../Generated_Code/AdcLdd1.c **** **         GetMeasuredValues            - LDD_TError AdcLdd1_GetMeasuredValues(LDD_TDeviceData *Dev
  74:../Generated_Code/AdcLdd1.c **** **         CreateSampleGroup            - LDD_TError AdcLdd1_CreateSampleGroup(LDD_TDeviceData *Dev
  75:../Generated_Code/AdcLdd1.c **** **         GetMeasurementCompleteStatus - bool AdcLdd1_GetMeasurementCompleteStatus(LDD_TDeviceData
  76:../Generated_Code/AdcLdd1.c **** **         StartCalibration             - LDD_TError AdcLdd1_StartCalibration(LDD_TDeviceData *Devi
  77:../Generated_Code/AdcLdd1.c **** **         GetCalibrationResultStatus   - LDD_TError AdcLdd1_GetCalibrationResultStatus(LDD_TDevice
  78:../Generated_Code/AdcLdd1.c **** **
  79:../Generated_Code/AdcLdd1.c **** **     Copyright : 1997 - 2013 Freescale Semiconductor, Inc. All Rights Reserved.
  80:../Generated_Code/AdcLdd1.c **** **     SOURCE DISTRIBUTION PERMISSIBLE as directed in End User License Agreement.
  81:../Generated_Code/AdcLdd1.c **** **     
  82:../Generated_Code/AdcLdd1.c **** **     http      : www.freescale.com
  83:../Generated_Code/AdcLdd1.c **** **     mail      : support@freescale.com
  84:../Generated_Code/AdcLdd1.c **** ** ###################################################################*/
  85:../Generated_Code/AdcLdd1.c **** /*!
  86:../Generated_Code/AdcLdd1.c **** ** @file AdcLdd1.c
  87:../Generated_Code/AdcLdd1.c **** ** @version 01.08
  88:../Generated_Code/AdcLdd1.c **** ** @brief
  89:../Generated_Code/AdcLdd1.c **** **         This device "ADC_LDD" implements an A/D converter,
  90:../Generated_Code/AdcLdd1.c **** **         its control methods and interrupt/event handling procedure.
  91:../Generated_Code/AdcLdd1.c **** */         
  92:../Generated_Code/AdcLdd1.c **** /*!
  93:../Generated_Code/AdcLdd1.c **** **  @addtogroup AdcLdd1_module AdcLdd1 module documentation
  94:../Generated_Code/AdcLdd1.c **** **  @{
  95:../Generated_Code/AdcLdd1.c **** */         
  96:../Generated_Code/AdcLdd1.c **** 
  97:../Generated_Code/AdcLdd1.c **** /* MODULE AdcLdd1. */
  98:../Generated_Code/AdcLdd1.c **** 
  99:../Generated_Code/AdcLdd1.c **** #include "POT1.h"
 100:../Generated_Code/AdcLdd1.c **** #include "AdcLdd1.h"
 101:../Generated_Code/AdcLdd1.c **** /* {Default RTOS Adapter} No RTOS includes */
 102:../Generated_Code/AdcLdd1.c **** 
 103:../Generated_Code/AdcLdd1.c **** #ifdef __cplusplus
 104:../Generated_Code/AdcLdd1.c **** extern "C" { 
 105:../Generated_Code/AdcLdd1.c **** #endif
 106:../Generated_Code/AdcLdd1.c **** 
 107:../Generated_Code/AdcLdd1.c **** #define AdcLdd1_AVAILABLE_CHANNEL0_31_PIN_MASK (LDD_ADC_CHANNEL_0_PIN | LDD_ADC_CHANNEL_1_PIN) /*!<
 108:../Generated_Code/AdcLdd1.c **** #define AdcLdd1_AVAILABLE_CHANNEL32_63_PIN_MASK 0x00U /*!< Mask of all allocated channel pins from 
 109:../Generated_Code/AdcLdd1.c **** #define AdcLdd1_AVAILABLE_TRIGGER_PIN_MASK 0x00U /*!< Mask of all allocated trigger pins */
 110:../Generated_Code/AdcLdd1.c **** #define AdcLdd1_AVAILABLE_VOLT_REF_PIN_MASK (LDD_ADC_LOW_VOLT_REF_PIN | LDD_ADC_HIGH_VOLT_REF_PIN) 
 111:../Generated_Code/AdcLdd1.c **** 
 112:../Generated_Code/AdcLdd1.c **** static const uint8_t ChannelToPin[] = { /* Channel to pin conversion table */
 113:../Generated_Code/AdcLdd1.c ****   /* ADC0_SC1A: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 114:../Generated_Code/AdcLdd1.c ****   0x4EU,                               /* Status and control register value */
 115:../Generated_Code/AdcLdd1.c ****   /* ADC0_SC1A: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 116:../Generated_Code/AdcLdd1.c ****   0x4FU                                /* Status and control register value */
 117:../Generated_Code/AdcLdd1.c **** };
 118:../Generated_Code/AdcLdd1.c **** 
 119:../Generated_Code/AdcLdd1.c **** typedef struct {
 120:../Generated_Code/AdcLdd1.c ****   uint8_t SampleCount;                 /* Number of samples in the last selected/created sample gro
 121:../Generated_Code/AdcLdd1.c ****   uint8_t FirstSample;                 /* First sample of group store */
 122:../Generated_Code/AdcLdd1.c ****   uint8_t CompleteStatus;              /* Measurement complete status flag */
 123:../Generated_Code/AdcLdd1.c ****   LDD_TUserData *UserData;             /* RTOS device data structure */
 124:../Generated_Code/AdcLdd1.c **** } AdcLdd1_TDeviceData;                 /* Device data structure type */
 125:../Generated_Code/AdcLdd1.c **** 
 126:../Generated_Code/AdcLdd1.c **** typedef AdcLdd1_TDeviceData* AdcLdd1_TDeviceDataPtr ; /* Pointer to the device data structure. */
 127:../Generated_Code/AdcLdd1.c **** 
 128:../Generated_Code/AdcLdd1.c **** /* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
 129:../Generated_Code/AdcLdd1.c **** static AdcLdd1_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 130:../Generated_Code/AdcLdd1.c **** /* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
 131:../Generated_Code/AdcLdd1.c **** static AdcLdd1_TDeviceDataPtr INT_ADC0__DEFAULT_RTOS_ISRPARAM;
 132:../Generated_Code/AdcLdd1.c **** /*
 133:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 134:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_Init (component ADC_LDD)
 135:../Generated_Code/AdcLdd1.c **** */
 136:../Generated_Code/AdcLdd1.c **** /*!
 137:../Generated_Code/AdcLdd1.c **** **     @brief
 138:../Generated_Code/AdcLdd1.c **** **         Initializes the device. Allocates memory for the device data
 139:../Generated_Code/AdcLdd1.c **** **         structure, allocates interrupt vectors and sets interrupt
 140:../Generated_Code/AdcLdd1.c **** **         priority, sets pin routing, sets timing, etc.
 141:../Generated_Code/AdcLdd1.c **** **         If the "Enable in init. code" is set to "yes" value then the
 142:../Generated_Code/AdcLdd1.c **** **         device is also enabled(see the description of the Enable()
 143:../Generated_Code/AdcLdd1.c **** **         method). In this case the Enable() method is not necessary
 144:../Generated_Code/AdcLdd1.c **** **         and needn't to be generated. 
 145:../Generated_Code/AdcLdd1.c **** **         This method can be called only once. Before the second call
 146:../Generated_Code/AdcLdd1.c **** **         of Init() the Deinit() must be called first.
 147:../Generated_Code/AdcLdd1.c **** **     @param
 148:../Generated_Code/AdcLdd1.c **** **         UserDataPtr     - Pointer to the user or
 149:../Generated_Code/AdcLdd1.c **** **                           RTOS specific data. This pointer will be
 150:../Generated_Code/AdcLdd1.c **** **                           passed as an event or callback parameter.
 151:../Generated_Code/AdcLdd1.c **** **     @return
 152:../Generated_Code/AdcLdd1.c **** **                         - Device data structure pointer.
 153:../Generated_Code/AdcLdd1.c **** */
 154:../Generated_Code/AdcLdd1.c **** /* ===================================================================*/
 155:../Generated_Code/AdcLdd1.c **** LDD_TDeviceData* AdcLdd1_Init(LDD_TUserData *UserDataPtr)
 156:../Generated_Code/AdcLdd1.c **** {
  46              		.loc 1 156 0
  47              		.cfi_startproc
  48              		@ args = 0, pretend = 0, frame = 16
  49              		@ frame_needed = 1, uses_anonymous_args = 0
  50              		@ link register save eliminated.
  51 0000 80B4     		push	{r7}
  52              	.LCFI0:
  53              		.cfi_def_cfa_offset 4
  54              		.cfi_offset 7, -4
  55 0002 85B0     		sub	sp, sp, #20
  56              	.LCFI1:
  57              		.cfi_def_cfa_offset 24
  58 0004 00AF     		add	r7, sp, #0
  59              	.LCFI2:
  60              		.cfi_def_cfa_register 7
  61 0006 7860     		str	r0, [r7, #4]
 157:../Generated_Code/AdcLdd1.c ****   /* Allocate LDD device structure */
 158:../Generated_Code/AdcLdd1.c ****   AdcLdd1_TDeviceDataPtr DeviceDataPrv;
 159:../Generated_Code/AdcLdd1.c **** 
 160:../Generated_Code/AdcLdd1.c ****   /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 161:../Generated_Code/AdcLdd1.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  62              		.loc 1 161 0
  63 0008 40F20003 		movw	r3, #:lower16:DeviceDataPrv__DEFAULT_RTOS_ALLOC
  64 000c C0F20003 		movt	r3, #:upper16:DeviceDataPrv__DEFAULT_RTOS_ALLOC
  65 0010 FB60     		str	r3, [r7, #12]
 162:../Generated_Code/AdcLdd1.c ****   DeviceDataPrv->UserData = UserDataPtr; /* Store the RTOS device structure */
  66              		.loc 1 162 0
  67 0012 FB68     		ldr	r3, [r7, #12]
  68 0014 7A68     		ldr	r2, [r7, #4]
  69 0016 5A60     		str	r2, [r3, #4]
 163:../Generated_Code/AdcLdd1.c ****   /* Interrupt vector(s) allocation */
 164:../Generated_Code/AdcLdd1.c ****   /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the glo
 165:../Generated_Code/AdcLdd1.c ****   INT_ADC0__DEFAULT_RTOS_ISRPARAM = DeviceDataPrv;
  70              		.loc 1 165 0
  71 0018 40F20003 		movw	r3, #:lower16:INT_ADC0__DEFAULT_RTOS_ISRPARAM
  72 001c C0F20003 		movt	r3, #:upper16:INT_ADC0__DEFAULT_RTOS_ISRPARAM
  73 0020 FA68     		ldr	r2, [r7, #12]
  74 0022 1A60     		str	r2, [r3, #0]
 166:../Generated_Code/AdcLdd1.c ****   DeviceDataPrv->SampleCount = 0U;     /* Initializing SampleCount for right access of some methods
  75              		.loc 1 166 0
  76 0024 FB68     		ldr	r3, [r7, #12]
  77 0026 4FF00002 		mov	r2, #0
  78 002a 1A70     		strb	r2, [r3, #0]
 167:../Generated_Code/AdcLdd1.c ****   DeviceDataPrv->CompleteStatus = FALSE; /* Clear measurement complete status flag */
  79              		.loc 1 167 0
  80 002c FB68     		ldr	r3, [r7, #12]
  81 002e 4FF00002 		mov	r2, #0
  82 0032 9A70     		strb	r2, [r3, #2]
 168:../Generated_Code/AdcLdd1.c ****   /* SIM_SCGC6: ADC0=1 */
 169:../Generated_Code/AdcLdd1.c ****   SIM_SCGC6 |= SIM_SCGC6_ADC0_MASK;                                   
  83              		.loc 1 169 0
  84 0034 4FF4E043 		mov	r3, #28672
  85 0038 C4F20403 		movt	r3, 16388
  86 003c 4FF4E042 		mov	r2, #28672
  87 0040 C4F20402 		movt	r2, 16388
  88 0044 02F58152 		add	r2, r2, #4128
  89 0048 02F11C02 		add	r2, r2, #28
  90 004c 1268     		ldr	r2, [r2, #0]
  91 004e 42F00062 		orr	r2, r2, #134217728
  92 0052 03F58153 		add	r3, r3, #4128
  93 0056 03F11C03 		add	r3, r3, #28
  94 005a 1A60     		str	r2, [r3, #0]
 170:../Generated_Code/AdcLdd1.c ****   /* Interrupt vector(s) priority setting */
 171:../Generated_Code/AdcLdd1.c ****   /* NVICIP22: PRI22=0x80 */
 172:../Generated_Code/AdcLdd1.c ****   NVICIP22 = NVIC_IP_PRI22(0x80);                                   
  95              		.loc 1 172 0
  96 005c 4FF46143 		mov	r3, #57600
  97 0060 CEF20003 		movt	r3, 57344
  98 0064 4FF08002 		mov	r2, #128
  99 0068 83F81623 		strb	r2, [r3, #790]
 173:../Generated_Code/AdcLdd1.c ****   /* NVICISER0: SETENA|=0x00400000 */
 174:../Generated_Code/AdcLdd1.c ****   NVICISER0 |= NVIC_ISER_SETENA(0x00400000);                                   
 100              		.loc 1 174 0
 101 006c 4FF46143 		mov	r3, #57600
 102 0070 CEF20003 		movt	r3, 57344
 103 0074 4FF46142 		mov	r2, #57600
 104 0078 CEF20002 		movt	r2, 57344
 105 007c 1268     		ldr	r2, [r2, #0]
 106 007e 42F48002 		orr	r2, r2, #4194304
 107 0082 1A60     		str	r2, [r3, #0]
 175:../Generated_Code/AdcLdd1.c ****   /* PORTC_PCR0: ISF=0,MUX=0 */
 176:../Generated_Code/AdcLdd1.c ****   PORTC_PCR0 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));                   
 108              		.loc 1 176 0
 109 0084 4FF43043 		mov	r3, #45056
 110 0088 C4F20403 		movt	r3, 16388
 111 008c 4FF43042 		mov	r2, #45056
 112 0090 C4F20402 		movt	r2, 16388
 113 0094 1268     		ldr	r2, [r2, #0]
 114 0096 22F08072 		bic	r2, r2, #16777216
 115 009a 22F4E062 		bic	r2, r2, #1792
 116 009e 1A60     		str	r2, [r3, #0]
 177:../Generated_Code/AdcLdd1.c ****   /* PORTC_PCR1: ISF=0,MUX=0 */
 178:../Generated_Code/AdcLdd1.c ****   PORTC_PCR1 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));                   
 117              		.loc 1 178 0
 118 00a0 4FF43043 		mov	r3, #45056
 119 00a4 C4F20403 		movt	r3, 16388
 120 00a8 4FF43042 		mov	r2, #45056
 121 00ac C4F20402 		movt	r2, 16388
 122 00b0 5268     		ldr	r2, [r2, #4]
 123 00b2 22F08072 		bic	r2, r2, #16777216
 124 00b6 22F4E062 		bic	r2, r2, #1792
 125 00ba 5A60     		str	r2, [r3, #4]
 179:../Generated_Code/AdcLdd1.c ****   /* ADC0_CFG1: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 180:../Generated_Code/AdcLdd1.c ****   ADC0_CFG1 = ADC_CFG1_ADIV(0x01) |
 126              		.loc 1 180 0
 127 00bc 4FF43043 		mov	r3, #45056
 128 00c0 C4F20303 		movt	r3, 16387
 129 00c4 4FF02E02 		mov	r2, #46
 130 00c8 9A60     		str	r2, [r3, #8]
 181:../Generated_Code/AdcLdd1.c ****               ADC_CFG1_MODE(0x03) |
 182:../Generated_Code/AdcLdd1.c ****               ADC_CFG1_ADICLK(0x02);       
 183:../Generated_Code/AdcLdd1.c ****   /* ADC0_CFG2: ADACKEN=0,ADHSC=0,ADLSTS=0 */
 184:../Generated_Code/AdcLdd1.c ****   ADC0_CFG2 &= (uint32_t)~(uint32_t)(
 131              		.loc 1 184 0
 132 00ca 4FF43043 		mov	r3, #45056
 133 00ce C4F20303 		movt	r3, 16387
 134 00d2 4FF43042 		mov	r2, #45056
 135 00d6 C4F20302 		movt	r2, 16387
 136 00da D268     		ldr	r2, [r2, #12]
 137 00dc 22F00F02 		bic	r2, r2, #15
 138 00e0 DA60     		str	r2, [r3, #12]
 185:../Generated_Code/AdcLdd1.c ****                 ADC_CFG2_ADACKEN_MASK |
 186:../Generated_Code/AdcLdd1.c ****                 ADC_CFG2_ADHSC_MASK |
 187:../Generated_Code/AdcLdd1.c ****                 ADC_CFG2_ADLSTS(0x03)
 188:../Generated_Code/AdcLdd1.c ****                );                                   
 189:../Generated_Code/AdcLdd1.c ****   /* ADC0_SC2: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0
 190:../Generated_Code/AdcLdd1.c ****   ADC0_SC2 = ADC_SC2_REFSEL(0x00);                                   
 139              		.loc 1 190 0
 140 00e2 4FF43043 		mov	r3, #45056
 141 00e6 C4F20303 		movt	r3, 16387
 142 00ea 4FF00002 		mov	r2, #0
 143 00ee 1A62     		str	r2, [r3, #32]
 191:../Generated_Code/AdcLdd1.c ****   /* ADC0_SC3: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0
 192:../Generated_Code/AdcLdd1.c ****   ADC0_SC3 = (ADC_SC3_CALF_MASK | ADC_SC3_AVGS(0x00));                                   
 144              		.loc 1 192 0
 145 00f0 4FF43043 		mov	r3, #45056
 146 00f4 C4F20303 		movt	r3, 16387
 147 00f8 4FF04002 		mov	r2, #64
 148 00fc 5A62     		str	r2, [r3, #36]
 193:../Generated_Code/AdcLdd1.c ****   /* Registration of the device structure */
 194:../Generated_Code/AdcLdd1.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_AdcLdd1_ID,DeviceDataPrv);
 149              		.loc 1 194 0
 150 00fe 40F20003 		movw	r3, #:lower16:PE_LDD_DeviceDataList
 151 0102 C0F20003 		movt	r3, #:upper16:PE_LDD_DeviceDataList
 152 0106 FA68     		ldr	r2, [r7, #12]
 153 0108 DA62     		str	r2, [r3, #44]
 195:../Generated_Code/AdcLdd1.c ****   return ((LDD_TDeviceData *)DeviceDataPrv); /* Return pointer to the data data structure */
 154              		.loc 1 195 0
 155 010a FB68     		ldr	r3, [r7, #12]
 196:../Generated_Code/AdcLdd1.c **** }
 156              		.loc 1 196 0
 157 010c 1846     		mov	r0, r3
 158 010e 07F11407 		add	r7, r7, #20
 159 0112 BD46     		mov	sp, r7
 160 0114 80BC     		pop	{r7}
 161 0116 7047     		bx	lr
 162              		.cfi_endproc
 163              	.LFE0:
 165              		.section	.text.AdcLdd1_StartSingleMeasurement,"ax",%progbits
 166              		.align	2
 167              		.global	AdcLdd1_StartSingleMeasurement
 168              		.thumb
 169              		.thumb_func
 171              	AdcLdd1_StartSingleMeasurement:
 172              	.LFB1:
 197:../Generated_Code/AdcLdd1.c **** 
 198:../Generated_Code/AdcLdd1.c **** /*
 199:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 200:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_StartSingleMeasurement (component ADC_LDD)
 201:../Generated_Code/AdcLdd1.c **** */
 202:../Generated_Code/AdcLdd1.c **** /*!
 203:../Generated_Code/AdcLdd1.c **** **     @brief
 204:../Generated_Code/AdcLdd1.c **** **         This method starts one measurement of the selected group of
 205:../Generated_Code/AdcLdd1.c **** **         samples and exits immediately. This is ADC SW trigger method.
 206:../Generated_Code/AdcLdd1.c **** **         The group of samples for measurement is specified by
 207:../Generated_Code/AdcLdd1.c **** **         preceding call to [SelectSampleGroup()] or
 208:../Generated_Code/AdcLdd1.c **** **         [CreateSampleGroup] method. 
 209:../Generated_Code/AdcLdd1.c **** **         DMA disabled: The [OnMeasurementComplete() ] event is
 210:../Generated_Code/AdcLdd1.c **** **         invoked after the measurement is done and if the event is
 211:../Generated_Code/AdcLdd1.c **** **         enabled. Results of the measurement can be read by the
 212:../Generated_Code/AdcLdd1.c **** **         [GetMeasuredValues()] method. 
 213:../Generated_Code/AdcLdd1.c **** **         DMA enabled: DMA request from configured ADC is enabled
 214:../Generated_Code/AdcLdd1.c **** **         automatically. The [OnMeasurementComplete() ] event is
 215:../Generated_Code/AdcLdd1.c **** **         invoked after the requested number of results are
 216:../Generated_Code/AdcLdd1.c **** **         transferred to destination buffer by DMA and if the event is
 217:../Generated_Code/AdcLdd1.c **** **         enabled. [GetMeasuredValues()] method is not available if
 218:../Generated_Code/AdcLdd1.c **** **         DMA mode is enabled. If the DMA transfer was completed
 219:../Generated_Code/AdcLdd1.c **** **         before and DMA is not recofingured, DMA error can occur. See
 220:../Generated_Code/AdcLdd1.c **** **         also [SetBuffer()] method. 
 221:../Generated_Code/AdcLdd1.c **** **         The state of the measurement can be also polled by the
 222:../Generated_Code/AdcLdd1.c **** **         [GetMeasurementCompleteStatus()] method. The [Discontinuous
 223:../Generated_Code/AdcLdd1.c **** **         mode] doesn't support this method.
 224:../Generated_Code/AdcLdd1.c **** **     @param
 225:../Generated_Code/AdcLdd1.c **** **         DeviceDataPtr   - Device data structure
 226:../Generated_Code/AdcLdd1.c **** **                           pointer returned by [Init] method.
 227:../Generated_Code/AdcLdd1.c **** **     @return
 228:../Generated_Code/AdcLdd1.c **** **                         - Error code, possible codes:
 229:../Generated_Code/AdcLdd1.c **** **                           ERR_OK - OK
 230:../Generated_Code/AdcLdd1.c **** **                           ERR_SPEED - The device doesn't work in the
 231:../Generated_Code/AdcLdd1.c **** **                           active clock configuration
 232:../Generated_Code/AdcLdd1.c **** **                           ERR_DISABLED - Component is disabled
 233:../Generated_Code/AdcLdd1.c **** **                           ERR_BUSY - A measurement is in progress 
 234:../Generated_Code/AdcLdd1.c **** */
 235:../Generated_Code/AdcLdd1.c **** /* ===================================================================*/
 236:../Generated_Code/AdcLdd1.c **** LDD_TError AdcLdd1_StartSingleMeasurement(LDD_TDeviceData *DeviceDataPtr)
 237:../Generated_Code/AdcLdd1.c **** {
 173              		.loc 1 237 0
 174              		.cfi_startproc
 175              		@ args = 0, pretend = 0, frame = 8
 176              		@ frame_needed = 1, uses_anonymous_args = 0
 177              		@ link register save eliminated.
 178 0000 80B4     		push	{r7}
 179              	.LCFI3:
 180              		.cfi_def_cfa_offset 4
 181              		.cfi_offset 7, -4
 182 0002 83B0     		sub	sp, sp, #12
 183              	.LCFI4:
 184              		.cfi_def_cfa_offset 16
 185 0004 00AF     		add	r7, sp, #0
 186              	.LCFI5:
 187              		.cfi_def_cfa_register 7
 188 0006 7860     		str	r0, [r7, #4]
 238:../Generated_Code/AdcLdd1.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 239:../Generated_Code/AdcLdd1.c ****   if (ADC_PDD_GetConversionActiveFlag(ADC0_BASE_PTR) != 0U) { /* Last measurement still pending? */
 189              		.loc 1 239 0
 190 0008 4FF43043 		mov	r3, #45056
 191 000c C4F20303 		movt	r3, 16387
 192 0010 1B6A     		ldr	r3, [r3, #32]
 193 0012 03F08003 		and	r3, r3, #128
 194 0016 002B     		cmp	r3, #0
 195 0018 02D0     		beq	.L4
 240:../Generated_Code/AdcLdd1.c ****     return ERR_BUSY;                   /* Yes, return ERR_BUSY */
 196              		.loc 1 240 0
 197 001a 4FF00803 		mov	r3, #8
 198 001e 20E0     		b	.L5
 199              	.L4:
 241:../Generated_Code/AdcLdd1.c ****   }
 242:../Generated_Code/AdcLdd1.c ****   ADC_PDD_SetContinuousMode(ADC0_BASE_PTR, ADC_PDD_ONE_CONVERSION); /* Set one conversion mode */
 200              		.loc 1 242 0
 201 0020 4FF43043 		mov	r3, #45056
 202 0024 C4F20303 		movt	r3, 16387
 203 0028 4FF43042 		mov	r2, #45056
 204 002c C4F20302 		movt	r2, 16387
 205 0030 526A     		ldr	r2, [r2, #36]
 206 0032 22F00802 		bic	r2, r2, #8
 207 0036 5A62     		str	r2, [r3, #36]
 243:../Generated_Code/AdcLdd1.c ****   ADC_PDD_SetConversionTriggerType(ADC0_BASE_PTR, ADC_PDD_SW_TRIGGER); /* Select SW triggering */
 208              		.loc 1 243 0
 209 0038 4FF43043 		mov	r3, #45056
 210 003c C4F20303 		movt	r3, 16387
 211 0040 4FF43042 		mov	r2, #45056
 212 0044 C4F20302 		movt	r2, 16387
 213 0048 126A     		ldr	r2, [r2, #32]
 214 004a 22F04002 		bic	r2, r2, #64
 215 004e 1A62     		str	r2, [r3, #32]
 244:../Generated_Code/AdcLdd1.c ****   ADC_PDD_WriteStatusControl1Reg(ADC0_BASE_PTR, 0U, ((AdcLdd1_TDeviceDataPtr)DeviceDataPtr)->FirstS
 216              		.loc 1 244 0
 217 0050 4FF43043 		mov	r3, #45056
 218 0054 C4F20303 		movt	r3, 16387
 219 0058 7A68     		ldr	r2, [r7, #4]
 220 005a 5278     		ldrb	r2, [r2, #1]	@ zero_extendqisi2
 221 005c 1A60     		str	r2, [r3, #0]
 245:../Generated_Code/AdcLdd1.c ****   return ERR_OK;                       /* OK */
 222              		.loc 1 245 0
 223 005e 4FF00003 		mov	r3, #0
 224              	.L5:
 246:../Generated_Code/AdcLdd1.c **** }
 225              		.loc 1 246 0
 226 0062 1846     		mov	r0, r3
 227 0064 07F10C07 		add	r7, r7, #12
 228 0068 BD46     		mov	sp, r7
 229 006a 80BC     		pop	{r7}
 230 006c 7047     		bx	lr
 231              		.cfi_endproc
 232              	.LFE1:
 234 006e 00BF     		.section	.text.AdcLdd1_CancelMeasurement,"ax",%progbits
 235              		.align	2
 236              		.global	AdcLdd1_CancelMeasurement
 237              		.thumb
 238              		.thumb_func
 240              	AdcLdd1_CancelMeasurement:
 241              	.LFB2:
 247:../Generated_Code/AdcLdd1.c **** 
 248:../Generated_Code/AdcLdd1.c **** /*
 249:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 250:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_CancelMeasurement (component ADC_LDD)
 251:../Generated_Code/AdcLdd1.c **** */
 252:../Generated_Code/AdcLdd1.c **** /*!
 253:../Generated_Code/AdcLdd1.c **** **     @brief
 254:../Generated_Code/AdcLdd1.c **** **         This method cancels the measurement in progress. Typically
 255:../Generated_Code/AdcLdd1.c **** **         the OnMeasurementComplete() event is not invoked for
 256:../Generated_Code/AdcLdd1.c **** **         cancelled measurement. If DMA mode is enabled, DMA request
 257:../Generated_Code/AdcLdd1.c **** **         from ADC is disabled and DMA transfer is cancelled. 
 258:../Generated_Code/AdcLdd1.c **** **     @param
 259:../Generated_Code/AdcLdd1.c **** **         DeviceDataPtr   - Device data structure
 260:../Generated_Code/AdcLdd1.c **** **                           pointer returned by [Init] method.
 261:../Generated_Code/AdcLdd1.c **** **     @return
 262:../Generated_Code/AdcLdd1.c **** **                         - Error code, possible codes:
 263:../Generated_Code/AdcLdd1.c **** **                           ERR_OK - OK
 264:../Generated_Code/AdcLdd1.c **** **                           ERR_SPEED - The device doesn't work in the
 265:../Generated_Code/AdcLdd1.c **** **                           active clock configuration
 266:../Generated_Code/AdcLdd1.c **** **                           ERR_DISABLED - Component is disabled
 267:../Generated_Code/AdcLdd1.c **** */
 268:../Generated_Code/AdcLdd1.c **** /* ===================================================================*/
 269:../Generated_Code/AdcLdd1.c **** LDD_TError AdcLdd1_CancelMeasurement(LDD_TDeviceData *DeviceDataPtr)
 270:../Generated_Code/AdcLdd1.c **** {
 242              		.loc 1 270 0
 243              		.cfi_startproc
 244              		@ args = 0, pretend = 0, frame = 8
 245              		@ frame_needed = 1, uses_anonymous_args = 0
 246              		@ link register save eliminated.
 247 0000 80B4     		push	{r7}
 248              	.LCFI6:
 249              		.cfi_def_cfa_offset 4
 250              		.cfi_offset 7, -4
 251 0002 83B0     		sub	sp, sp, #12
 252              	.LCFI7:
 253              		.cfi_def_cfa_offset 16
 254 0004 00AF     		add	r7, sp, #0
 255              	.LCFI8:
 256              		.cfi_def_cfa_register 7
 257 0006 7860     		str	r0, [r7, #4]
 271:../Generated_Code/AdcLdd1.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 272:../Generated_Code/AdcLdd1.c ****   ADC_PDD_SetConversionTriggerType(ADC0_BASE_PTR, ADC_PDD_SW_TRIGGER); /* Select SW triggering */
 258              		.loc 1 272 0
 259 0008 4FF43043 		mov	r3, #45056
 260 000c C4F20303 		movt	r3, 16387
 261 0010 4FF43042 		mov	r2, #45056
 262 0014 C4F20302 		movt	r2, 16387
 263 0018 126A     		ldr	r2, [r2, #32]
 264 001a 22F04002 		bic	r2, r2, #64
 265 001e 1A62     		str	r2, [r3, #32]
 273:../Generated_Code/AdcLdd1.c ****   ADC_PDD_WriteStatusControl1Reg(ADC0_BASE_PTR, 0U, 0x1FU); /* Disable device - A */
 266              		.loc 1 273 0
 267 0020 4FF43043 		mov	r3, #45056
 268 0024 C4F20303 		movt	r3, 16387
 269 0028 4FF01F02 		mov	r2, #31
 270 002c 1A60     		str	r2, [r3, #0]
 274:../Generated_Code/AdcLdd1.c ****   
 275:../Generated_Code/AdcLdd1.c ****   return ERR_OK;                       /* If yes then set the flag "device enabled" */  
 271              		.loc 1 275 0
 272 002e 4FF00003 		mov	r3, #0
 276:../Generated_Code/AdcLdd1.c **** }
 273              		.loc 1 276 0
 274 0032 1846     		mov	r0, r3
 275 0034 07F10C07 		add	r7, r7, #12
 276 0038 BD46     		mov	sp, r7
 277 003a 80BC     		pop	{r7}
 278 003c 7047     		bx	lr
 279              		.cfi_endproc
 280              	.LFE2:
 282 003e 00BF     		.section	.text.AdcLdd1_CreateSampleGroup,"ax",%progbits
 283              		.align	2
 284              		.global	AdcLdd1_CreateSampleGroup
 285              		.thumb
 286              		.thumb_func
 288              	AdcLdd1_CreateSampleGroup:
 289              	.LFB3:
 277:../Generated_Code/AdcLdd1.c **** 
 278:../Generated_Code/AdcLdd1.c **** /*
 279:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 280:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_CreateSampleGroup (component ADC_LDD)
 281:../Generated_Code/AdcLdd1.c **** */
 282:../Generated_Code/AdcLdd1.c **** /*!
 283:../Generated_Code/AdcLdd1.c **** **     @brief
 284:../Generated_Code/AdcLdd1.c **** **         This method prepares HW for next measurement according to
 285:../Generated_Code/AdcLdd1.c **** **         array of samples defined during run-time. The array of
 286:../Generated_Code/AdcLdd1.c **** **         samples should be prepared prior to calling this method.
 287:../Generated_Code/AdcLdd1.c **** **         Pointer to the array is passed into this method in parameter
 288:../Generated_Code/AdcLdd1.c **** **         SampleGroupPtr. The number of samples is defined by
 289:../Generated_Code/AdcLdd1.c **** **         parameter SampleCount. Once any group is prepared, the
 290:../Generated_Code/AdcLdd1.c **** **         measurement can be started multiple times. Note: This method
 291:../Generated_Code/AdcLdd1.c **** **         works only with the sample groups defined during run-time.
 292:../Generated_Code/AdcLdd1.c **** **         For design-time defined groups use [SelectSampleGroup()]
 293:../Generated_Code/AdcLdd1.c **** **         method.
 294:../Generated_Code/AdcLdd1.c **** **     @param
 295:../Generated_Code/AdcLdd1.c **** **         DeviceDataPtr   - Device data structure
 296:../Generated_Code/AdcLdd1.c **** **                           pointer returned by [Init] method.
 297:../Generated_Code/AdcLdd1.c **** **     @param
 298:../Generated_Code/AdcLdd1.c **** **         SampleGroupPtr  - Pointer to the
 299:../Generated_Code/AdcLdd1.c **** **                           sample definition array. This array can be
 300:../Generated_Code/AdcLdd1.c **** **                           released as soon as the method ends.
 301:../Generated_Code/AdcLdd1.c **** **     @param
 302:../Generated_Code/AdcLdd1.c **** **         SampleCount     - Number of items in the
 303:../Generated_Code/AdcLdd1.c **** **                           sample definition array. Must be less than
 304:../Generated_Code/AdcLdd1.c **** **                           or equal to
 305:../Generated_Code/AdcLdd1.c **** **                           ComponentName_MAX_HW_SAMPLE_COUNT.
 306:../Generated_Code/AdcLdd1.c **** **     @return
 307:../Generated_Code/AdcLdd1.c **** **                         - Error code, possible codes:
 308:../Generated_Code/AdcLdd1.c **** **                           ERR_OK - OK
 309:../Generated_Code/AdcLdd1.c **** **                           ERR_SPEED - The device doesn't work in the
 310:../Generated_Code/AdcLdd1.c **** **                           active clock configuration
 311:../Generated_Code/AdcLdd1.c **** **                           ERR_DISABLED - Component is disabled
 312:../Generated_Code/AdcLdd1.c **** **                           ERR_PARAM_INDEX - Channel index in
 313:../Generated_Code/AdcLdd1.c **** **                           SampleGroup structure is out of range
 314:../Generated_Code/AdcLdd1.c **** **                           ERR_PARAM_SAMPLE_COUNT - SampleCount
 315:../Generated_Code/AdcLdd1.c **** **                           variable value is out of range
 316:../Generated_Code/AdcLdd1.c **** **                           ERR_BUSY - Measurement is in progress 
 317:../Generated_Code/AdcLdd1.c **** */
 318:../Generated_Code/AdcLdd1.c **** /* ===================================================================*/
 319:../Generated_Code/AdcLdd1.c **** LDD_TError AdcLdd1_CreateSampleGroup(LDD_TDeviceData *DeviceDataPtr, LDD_ADC_TSample *SampleGroupPt
 320:../Generated_Code/AdcLdd1.c **** {
 290              		.loc 1 320 0
 291              		.cfi_startproc
 292              		@ args = 0, pretend = 0, frame = 24
 293              		@ frame_needed = 1, uses_anonymous_args = 0
 294              		@ link register save eliminated.
 295 0000 80B4     		push	{r7}
 296              	.LCFI9:
 297              		.cfi_def_cfa_offset 4
 298              		.cfi_offset 7, -4
 299 0002 87B0     		sub	sp, sp, #28
 300              	.LCFI10:
 301              		.cfi_def_cfa_offset 32
 302 0004 00AF     		add	r7, sp, #0
 303              	.LCFI11:
 304              		.cfi_def_cfa_register 7
 305 0006 F860     		str	r0, [r7, #12]
 306 0008 B960     		str	r1, [r7, #8]
 307 000a 1346     		mov	r3, r2
 308 000c FB71     		strb	r3, [r7, #7]
 321:../Generated_Code/AdcLdd1.c ****   AdcLdd1_TDeviceDataPtr DeviceDataPrv = (AdcLdd1_TDeviceDataPtr)DeviceDataPtr;
 309              		.loc 1 321 0
 310 000e FB68     		ldr	r3, [r7, #12]
 311 0010 7B61     		str	r3, [r7, #20]
 322:../Generated_Code/AdcLdd1.c **** 
 323:../Generated_Code/AdcLdd1.c ****   /* Sample count test - this test can be disabled by setting the "Ignore range checking"
 324:../Generated_Code/AdcLdd1.c ****      property to the "yes" value in the "Configuration inspector" */
 325:../Generated_Code/AdcLdd1.c ****   if ((SampleCount > AdcLdd1_MAX_HW_SAMPLE_COUNT) || (SampleCount == 0U)) { /* Is number of sample 
 312              		.loc 1 325 0
 313 0012 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 314 0014 012B     		cmp	r3, #1
 315 0016 02D8     		bhi	.L9
 316              		.loc 1 325 0 is_stmt 0
 317 0018 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 318 001a 002B     		cmp	r3, #0
 319 001c 02D1     		bne	.L10
 320              	.L9:
 326:../Generated_Code/AdcLdd1.c ****     return ERR_PARAM_SAMPLE_COUNT;     /* Yes, return ERR_PARAM_SAMPLE_COUNT */
 321              		.loc 1 326 0 is_stmt 1
 322 001e 4FF09603 		mov	r3, #150
 323 0022 24E0     		b	.L11
 324              	.L10:
 327:../Generated_Code/AdcLdd1.c ****   }
 328:../Generated_Code/AdcLdd1.c ****   if (ADC_PDD_GetConversionActiveFlag(ADC0_BASE_PTR) != 0U) { /* Last measurement still pending? */
 325              		.loc 1 328 0
 326 0024 4FF43043 		mov	r3, #45056
 327 0028 C4F20303 		movt	r3, 16387
 328 002c 1B6A     		ldr	r3, [r3, #32]
 329 002e 03F08003 		and	r3, r3, #128
 330 0032 002B     		cmp	r3, #0
 331 0034 02D0     		beq	.L12
 329:../Generated_Code/AdcLdd1.c ****     return ERR_BUSY;                   /* Yes, return ERR_BUSY */
 332              		.loc 1 329 0
 333 0036 4FF00803 		mov	r3, #8
 334 003a 18E0     		b	.L11
 335              	.L12:
 330:../Generated_Code/AdcLdd1.c ****   }
 331:../Generated_Code/AdcLdd1.c ****   DeviceDataPrv->SampleCount = SampleCount; /* Remember sample count */
 336              		.loc 1 331 0
 337 003c 7B69     		ldr	r3, [r7, #20]
 338 003e FA79     		ldrb	r2, [r7, #7]
 339 0040 1A70     		strb	r2, [r3, #0]
 332:../Generated_Code/AdcLdd1.c ****   /* Channel index test - this test can be disabled by setting the "Ignore range checking"
 333:../Generated_Code/AdcLdd1.c ****      property to the "yes" value in the "Configuration inspector" */
 334:../Generated_Code/AdcLdd1.c ****   if (SampleGroupPtr[0].ChannelIdx >= AdcLdd1_CHANNEL_COUNT) { /* Is channel index out of range? */
 340              		.loc 1 334 0
 341 0042 BB68     		ldr	r3, [r7, #8]
 342 0044 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 343 0046 012B     		cmp	r3, #1
 344 0048 02D9     		bls	.L13
 335:../Generated_Code/AdcLdd1.c ****     return ERR_PARAM_INDEX;            /* Yes, return ERR_PARAM_INDEX */
 345              		.loc 1 335 0
 346 004a 4FF08203 		mov	r3, #130
 347 004e 0EE0     		b	.L11
 348              	.L13:
 336:../Generated_Code/AdcLdd1.c ****   }
 337:../Generated_Code/AdcLdd1.c ****   DeviceDataPrv->FirstSample = (ChannelToPin[SampleGroupPtr[0].ChannelIdx]) | (uint8_t)(LDD_ADC_ON_
 349              		.loc 1 337 0
 350 0050 BB68     		ldr	r3, [r7, #8]
 351 0052 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 352 0054 1A46     		mov	r2, r3
 353 0056 40F20003 		movw	r3, #:lower16:ChannelToPin
 354 005a C0F20003 		movt	r3, #:upper16:ChannelToPin
 355 005e 9B5C     		ldrb	r3, [r3, r2]	@ zero_extendqisi2
 356 0060 43F04003 		orr	r3, r3, #64
 357 0064 DAB2     		uxtb	r2, r3
 358 0066 7B69     		ldr	r3, [r7, #20]
 359 0068 5A70     		strb	r2, [r3, #1]
 338:../Generated_Code/AdcLdd1.c ****   return ERR_OK;                       /* OK */
 360              		.loc 1 338 0
 361 006a 4FF00003 		mov	r3, #0
 362              	.L11:
 339:../Generated_Code/AdcLdd1.c **** }
 363              		.loc 1 339 0
 364 006e 1846     		mov	r0, r3
 365 0070 07F11C07 		add	r7, r7, #28
 366 0074 BD46     		mov	sp, r7
 367 0076 80BC     		pop	{r7}
 368 0078 7047     		bx	lr
 369              		.cfi_endproc
 370              	.LFE3:
 372 007a 00BF     		.section	.text.AdcLdd1_GetMeasuredValues,"ax",%progbits
 373              		.align	2
 374              		.global	AdcLdd1_GetMeasuredValues
 375              		.thumb
 376              		.thumb_func
 378              	AdcLdd1_GetMeasuredValues:
 379              	.LFB4:
 340:../Generated_Code/AdcLdd1.c **** 
 341:../Generated_Code/AdcLdd1.c **** /*
 342:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 343:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_GetMeasuredValues (component ADC_LDD)
 344:../Generated_Code/AdcLdd1.c **** */
 345:../Generated_Code/AdcLdd1.c **** /*!
 346:../Generated_Code/AdcLdd1.c **** **     @brief
 347:../Generated_Code/AdcLdd1.c **** **         This method copies results of the last measurement to the
 348:../Generated_Code/AdcLdd1.c **** **         user supplied buffer. Data size depends on the size of
 349:../Generated_Code/AdcLdd1.c **** **         measured sample group (see [SelectSampleGroup()] or
 350:../Generated_Code/AdcLdd1.c **** **         [CreateSampleGroup()] method). Data representation is
 351:../Generated_Code/AdcLdd1.c **** **         defined by the [Result type] property. Typically this method
 352:../Generated_Code/AdcLdd1.c **** **         is called from [OnMeasurementComplete] event to get results
 353:../Generated_Code/AdcLdd1.c **** **         of the last measurement. This method is not available if DMA
 354:../Generated_Code/AdcLdd1.c **** **         is enabled.
 355:../Generated_Code/AdcLdd1.c **** **     @param
 356:../Generated_Code/AdcLdd1.c **** **         DeviceDataPtr   - Device data structure
 357:../Generated_Code/AdcLdd1.c **** **                           pointer returned by [Init] method.
 358:../Generated_Code/AdcLdd1.c **** **     @param
 359:../Generated_Code/AdcLdd1.c **** **         BufferPtr       - Pointer to the start of the
 360:../Generated_Code/AdcLdd1.c **** **                           buffer for new results. Count of stored
 361:../Generated_Code/AdcLdd1.c **** **                           measured values equals to the count of the
 362:../Generated_Code/AdcLdd1.c **** **                           samples in the active sample group. It is
 363:../Generated_Code/AdcLdd1.c **** **                           in the user responsibility to provide
 364:../Generated_Code/AdcLdd1.c **** **                           buffer with appropriate size.
 365:../Generated_Code/AdcLdd1.c **** **     @return
 366:../Generated_Code/AdcLdd1.c **** **                         - Error code, possible codes:
 367:../Generated_Code/AdcLdd1.c **** **                           ERR_OK - OK
 368:../Generated_Code/AdcLdd1.c **** **                           ERR_SPEED - The device doesn't work in the
 369:../Generated_Code/AdcLdd1.c **** **                           active clock configuration
 370:../Generated_Code/AdcLdd1.c **** **                           ERR_DISABLED - Component is disabled
 371:../Generated_Code/AdcLdd1.c **** */
 372:../Generated_Code/AdcLdd1.c **** /* ===================================================================*/
 373:../Generated_Code/AdcLdd1.c **** LDD_TError AdcLdd1_GetMeasuredValues(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr)
 374:../Generated_Code/AdcLdd1.c **** {
 380              		.loc 1 374 0
 381              		.cfi_startproc
 382              		@ args = 0, pretend = 0, frame = 16
 383              		@ frame_needed = 1, uses_anonymous_args = 0
 384              		@ link register save eliminated.
 385 0000 80B4     		push	{r7}
 386              	.LCFI12:
 387              		.cfi_def_cfa_offset 4
 388              		.cfi_offset 7, -4
 389 0002 85B0     		sub	sp, sp, #20
 390              	.LCFI13:
 391              		.cfi_def_cfa_offset 24
 392 0004 00AF     		add	r7, sp, #0
 393              	.LCFI14:
 394              		.cfi_def_cfa_register 7
 395 0006 7860     		str	r0, [r7, #4]
 396 0008 3960     		str	r1, [r7, #0]
 375:../Generated_Code/AdcLdd1.c ****   uint8_t Sample;
 376:../Generated_Code/AdcLdd1.c ****   AdcLdd1_TResultData *pBuffer = (AdcLdd1_TResultData *)BufferPtr;
 397              		.loc 1 376 0
 398 000a 3B68     		ldr	r3, [r7, #0]
 399 000c BB60     		str	r3, [r7, #8]
 377:../Generated_Code/AdcLdd1.c **** 
 378:../Generated_Code/AdcLdd1.c ****   /* Copy values from result registers defined in the active sample
 379:../Generated_Code/AdcLdd1.c ****      group to the user supplied buffer */
 380:../Generated_Code/AdcLdd1.c ****   for (Sample = 0U; Sample < ((AdcLdd1_TDeviceDataPtr)DeviceDataPtr)->SampleCount; Sample++) {
 400              		.loc 1 380 0
 401 000e 4FF00003 		mov	r3, #0
 402 0012 FB73     		strb	r3, [r7, #15]
 403 0014 13E0     		b	.L15
 404              	.L16:
 381:../Generated_Code/AdcLdd1.c ****     pBuffer[Sample] =(uint16_t)(ADC_PDD_GetResultValueRaw(ADC0_BASE_PTR, Sample));
 405              		.loc 1 381 0
 406 0016 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 407 0018 4FEA4303 		lsl	r3, r3, #1
 408 001c BA68     		ldr	r2, [r7, #8]
 409 001e D218     		adds	r2, r2, r3
 410 0020 4FF43043 		mov	r3, #45056
 411 0024 C4F20303 		movt	r3, 16387
 412 0028 F97B     		ldrb	r1, [r7, #15]	@ zero_extendqisi2
 413 002a 01F10401 		add	r1, r1, #4
 414 002e 53F82130 		ldr	r3, [r3, r1, lsl #2]
 415 0032 9BB2     		uxth	r3, r3
 416 0034 1380     		strh	r3, [r2, #0]	@ movhi
 380:../Generated_Code/AdcLdd1.c ****   for (Sample = 0U; Sample < ((AdcLdd1_TDeviceDataPtr)DeviceDataPtr)->SampleCount; Sample++) {
 417              		.loc 1 380 0
 418 0036 FB7B     		ldrb	r3, [r7, #15]
 419 0038 03F10103 		add	r3, r3, #1
 420 003c FB73     		strb	r3, [r7, #15]
 421              	.L15:
 380:../Generated_Code/AdcLdd1.c ****   for (Sample = 0U; Sample < ((AdcLdd1_TDeviceDataPtr)DeviceDataPtr)->SampleCount; Sample++) {
 422              		.loc 1 380 0 is_stmt 0
 423 003e 7B68     		ldr	r3, [r7, #4]
 424 0040 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 425 0042 FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 426 0044 9A42     		cmp	r2, r3
 427 0046 E6D3     		bcc	.L16
 382:../Generated_Code/AdcLdd1.c ****   }
 383:../Generated_Code/AdcLdd1.c ****   return ERR_OK;                       /* OK */
 428              		.loc 1 383 0 is_stmt 1
 429 0048 4FF00003 		mov	r3, #0
 384:../Generated_Code/AdcLdd1.c **** }
 430              		.loc 1 384 0
 431 004c 1846     		mov	r0, r3
 432 004e 07F11407 		add	r7, r7, #20
 433 0052 BD46     		mov	sp, r7
 434 0054 80BC     		pop	{r7}
 435 0056 7047     		bx	lr
 436              		.cfi_endproc
 437              	.LFE4:
 439              		.section	.text.AdcLdd1_GetMeasurementCompleteStatus,"ax",%progbits
 440              		.align	2
 441              		.global	AdcLdd1_GetMeasurementCompleteStatus
 442              		.thumb
 443              		.thumb_func
 445              	AdcLdd1_GetMeasurementCompleteStatus:
 446              	.LFB5:
 385:../Generated_Code/AdcLdd1.c **** 
 386:../Generated_Code/AdcLdd1.c **** /*
 387:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 388:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_GetMeasurementCompleteStatus (component ADC_LDD)
 389:../Generated_Code/AdcLdd1.c **** */
 390:../Generated_Code/AdcLdd1.c **** /*!
 391:../Generated_Code/AdcLdd1.c **** **     @brief
 392:../Generated_Code/AdcLdd1.c **** **         Returns whether the measurement is done and the results can
 393:../Generated_Code/AdcLdd1.c **** **         be read by the user. It can be used to poll the state of
 394:../Generated_Code/AdcLdd1.c **** **         measurement if [Interrupt service/event] is disabled or if
 395:../Generated_Code/AdcLdd1.c **** **         [OnMeasurementComplete] event is disabled by the
 396:../Generated_Code/AdcLdd1.c **** **         [SetEventMask()] methods.
 397:../Generated_Code/AdcLdd1.c **** **     @param
 398:../Generated_Code/AdcLdd1.c **** **         DeviceDataPtr   - Device data structure
 399:../Generated_Code/AdcLdd1.c **** **                           pointer returned by [Init] method.
 400:../Generated_Code/AdcLdd1.c **** **     @return
 401:../Generated_Code/AdcLdd1.c **** **                         - Error code
 402:../Generated_Code/AdcLdd1.c **** **                           true - Measurement is done
 403:../Generated_Code/AdcLdd1.c **** **                           false - Measurement is in progress
 404:../Generated_Code/AdcLdd1.c **** */
 405:../Generated_Code/AdcLdd1.c **** /* ===================================================================*/
 406:../Generated_Code/AdcLdd1.c **** bool AdcLdd1_GetMeasurementCompleteStatus(LDD_TDeviceData *DeviceDataPtr)
 407:../Generated_Code/AdcLdd1.c **** {
 447              		.loc 1 407 0
 448              		.cfi_startproc
 449              		@ args = 0, pretend = 0, frame = 16
 450              		@ frame_needed = 1, uses_anonymous_args = 0
 451              		@ link register save eliminated.
 452 0000 80B4     		push	{r7}
 453              	.LCFI15:
 454              		.cfi_def_cfa_offset 4
 455              		.cfi_offset 7, -4
 456 0002 85B0     		sub	sp, sp, #20
 457              	.LCFI16:
 458              		.cfi_def_cfa_offset 24
 459 0004 00AF     		add	r7, sp, #0
 460              	.LCFI17:
 461              		.cfi_def_cfa_register 7
 462 0006 7860     		str	r0, [r7, #4]
 408:../Generated_Code/AdcLdd1.c ****   uint8_t Status;
 409:../Generated_Code/AdcLdd1.c ****   AdcLdd1_TDeviceDataPtr DeviceDataPrv = (AdcLdd1_TDeviceDataPtr)DeviceDataPtr;
 463              		.loc 1 409 0
 464 0008 7B68     		ldr	r3, [r7, #4]
 465 000a FB60     		str	r3, [r7, #12]
 410:../Generated_Code/AdcLdd1.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 411:../Generated_Code/AdcLdd1.c ****   EnterCritical();
 466              		.loc 1 411 0
 467 000c 40F20003 		movw	r3, #:lower16:SR_lock
 468 0010 C0F20003 		movt	r3, #:upper16:SR_lock
 469 0014 1B78     		ldrb	r3, [r3, #0]
 470 0016 DBB2     		uxtb	r3, r3
 471 0018 03F10103 		add	r3, r3, #1
 472 001c DBB2     		uxtb	r3, r3
 473 001e 1A46     		mov	r2, r3
 474 0020 40F20003 		movw	r3, #:lower16:SR_lock
 475 0024 C0F20003 		movt	r3, #:upper16:SR_lock
 476 0028 1146     		mov	r1, r2
 477 002a 1970     		strb	r1, [r3, #0]
 478 002c 012A     		cmp	r2, #1
 479 002e 07D1     		bne	.L19
 480              		.loc 1 411 0 is_stmt 0
 481 0030 40F20003 		movw	r3, #:lower16:SR_reg
 482 0034 C0F20003 		movt	r3, #:upper16:SR_reg
 483              	@ 411 "../Generated_Code/AdcLdd1.c" 1
 484 0038 EFF31380 		MRS R0, FAULTMASK
 485 003c 71B6     		CPSID f
 486 003e 1870     		STRB R0, [r3, #0]
 487              	@ 0 "" 2
 488              		.thumb
 489              	.L19:
 412:../Generated_Code/AdcLdd1.c ****   Status = DeviceDataPrv->CompleteStatus; /* Save flag for return */
 490              		.loc 1 412 0 is_stmt 1
 491 0040 FB68     		ldr	r3, [r7, #12]
 492 0042 9B78     		ldrb	r3, [r3, #2]
 493 0044 FB72     		strb	r3, [r7, #11]
 413:../Generated_Code/AdcLdd1.c ****   DeviceDataPrv->CompleteStatus = FALSE; /* Clear measurement complete status flag */
 494              		.loc 1 413 0
 495 0046 FB68     		ldr	r3, [r7, #12]
 496 0048 4FF00002 		mov	r2, #0
 497 004c 9A70     		strb	r2, [r3, #2]
 414:../Generated_Code/AdcLdd1.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 415:../Generated_Code/AdcLdd1.c ****   ExitCritical();
 498              		.loc 1 415 0
 499 004e 40F20003 		movw	r3, #:lower16:SR_lock
 500 0052 C0F20003 		movt	r3, #:upper16:SR_lock
 501 0056 1B78     		ldrb	r3, [r3, #0]
 502 0058 DBB2     		uxtb	r3, r3
 503 005a 03F1FF33 		add	r3, r3, #-1
 504 005e DBB2     		uxtb	r3, r3
 505 0060 1A46     		mov	r2, r3
 506 0062 40F20003 		movw	r3, #:lower16:SR_lock
 507 0066 C0F20003 		movt	r3, #:upper16:SR_lock
 508 006a 1146     		mov	r1, r2
 509 006c 1970     		strb	r1, [r3, #0]
 510 006e 002A     		cmp	r2, #0
 511 0070 06D1     		bne	.L20
 512              		.loc 1 415 0 is_stmt 0
 513 0072 40F20003 		movw	r3, #:lower16:SR_reg
 514 0076 C0F20003 		movt	r3, #:upper16:SR_reg
 515              	@ 415 "../Generated_Code/AdcLdd1.c" 1
 516 007a 1878     		ldrb r0, [r3, #0]
 517 007c 80F31388 		msr FAULTMASK,r0;
 518              		
 519              	@ 0 "" 2
 520              		.thumb
 521              	.L20:
 416:../Generated_Code/AdcLdd1.c ****   return (bool)((Status)? TRUE : FALSE); /* Return saved status */
 522              		.loc 1 416 0 is_stmt 1
 523 0080 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 524 0082 002B     		cmp	r3, #0
 525 0084 02D0     		beq	.L21
 526              		.loc 1 416 0 is_stmt 0
 527 0086 4FF00103 		mov	r3, #1
 528 008a 01E0     		b	.L22
 529              	.L21:
 530              		.loc 1 416 0
 531 008c 4FF00003 		mov	r3, #0
 532              	.L22:
 417:../Generated_Code/AdcLdd1.c **** }
 533              		.loc 1 417 0 is_stmt 1
 534 0090 1846     		mov	r0, r3
 535 0092 07F11407 		add	r7, r7, #20
 536 0096 BD46     		mov	sp, r7
 537 0098 80BC     		pop	{r7}
 538 009a 7047     		bx	lr
 539              		.cfi_endproc
 540              	.LFE5:
 542              		.section	.text.AdcLdd1_StartCalibration,"ax",%progbits
 543              		.align	2
 544              		.global	AdcLdd1_StartCalibration
 545              		.thumb
 546              		.thumb_func
 548              	AdcLdd1_StartCalibration:
 549              	.LFB6:
 418:../Generated_Code/AdcLdd1.c **** 
 419:../Generated_Code/AdcLdd1.c **** /*
 420:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 421:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_StartCalibration (component ADC_LDD)
 422:../Generated_Code/AdcLdd1.c **** */
 423:../Generated_Code/AdcLdd1.c **** /*!
 424:../Generated_Code/AdcLdd1.c **** **     @brief
 425:../Generated_Code/AdcLdd1.c **** **         This method starts self calibration process. Calibration is
 426:../Generated_Code/AdcLdd1.c **** **         typically used to remove the effects of the gain and offset
 427:../Generated_Code/AdcLdd1.c **** **         from a specific reading.
 428:../Generated_Code/AdcLdd1.c **** **     @param
 429:../Generated_Code/AdcLdd1.c **** **         DeviceDataPtr   - Device data structure
 430:../Generated_Code/AdcLdd1.c **** **                           pointer returned by [Init] method.
 431:../Generated_Code/AdcLdd1.c **** **     @return
 432:../Generated_Code/AdcLdd1.c **** **                         - Error code
 433:../Generated_Code/AdcLdd1.c **** **                           ERR_OK - OK
 434:../Generated_Code/AdcLdd1.c **** **                           ERR_SPEED - The device doesn't work in the
 435:../Generated_Code/AdcLdd1.c **** **                           active clock configuration
 436:../Generated_Code/AdcLdd1.c **** **                           ERR_DISABLED - Component is disabled
 437:../Generated_Code/AdcLdd1.c **** **                           ERR_BUSY - A conversion is already running 
 438:../Generated_Code/AdcLdd1.c **** */
 439:../Generated_Code/AdcLdd1.c **** /* ===================================================================*/
 440:../Generated_Code/AdcLdd1.c **** LDD_TError AdcLdd1_StartCalibration(LDD_TDeviceData *DeviceDataPtr)
 441:../Generated_Code/AdcLdd1.c **** {
 550              		.loc 1 441 0
 551              		.cfi_startproc
 552              		@ args = 0, pretend = 0, frame = 8
 553              		@ frame_needed = 1, uses_anonymous_args = 0
 554              		@ link register save eliminated.
 555 0000 80B4     		push	{r7}
 556              	.LCFI18:
 557              		.cfi_def_cfa_offset 4
 558              		.cfi_offset 7, -4
 559 0002 83B0     		sub	sp, sp, #12
 560              	.LCFI19:
 561              		.cfi_def_cfa_offset 16
 562 0004 00AF     		add	r7, sp, #0
 563              	.LCFI20:
 564              		.cfi_def_cfa_register 7
 565 0006 7860     		str	r0, [r7, #4]
 442:../Generated_Code/AdcLdd1.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 443:../Generated_Code/AdcLdd1.c ****   if (ADC_PDD_GetConversionActiveFlag(ADC0_BASE_PTR) != 0U) { /* Last measurement still pending? */
 566              		.loc 1 443 0
 567 0008 4FF43043 		mov	r3, #45056
 568 000c C4F20303 		movt	r3, 16387
 569 0010 1B6A     		ldr	r3, [r3, #32]
 570 0012 03F08003 		and	r3, r3, #128
 571 0016 002B     		cmp	r3, #0
 572 0018 02D0     		beq	.L25
 444:../Generated_Code/AdcLdd1.c ****     return ERR_BUSY;                   /* Yes, return ERR_BUSY */
 573              		.loc 1 444 0
 574 001a 4FF00803 		mov	r3, #8
 575 001e 20E0     		b	.L26
 576              	.L25:
 445:../Generated_Code/AdcLdd1.c ****   }
 446:../Generated_Code/AdcLdd1.c ****   ADC_PDD_SetConversionTriggerType(ADC0_BASE_PTR, ADC_PDD_SW_TRIGGER); /* Select SW triggering */
 577              		.loc 1 446 0
 578 0020 4FF43043 		mov	r3, #45056
 579 0024 C4F20303 		movt	r3, 16387
 580 0028 4FF43042 		mov	r2, #45056
 581 002c C4F20302 		movt	r2, 16387
 582 0030 126A     		ldr	r2, [r2, #32]
 583 0032 22F04002 		bic	r2, r2, #64
 584 0036 1A62     		str	r2, [r3, #32]
 447:../Generated_Code/AdcLdd1.c ****   ADC_PDD_WriteStatusControl1Reg(ADC0_BASE_PTR, 0U, ADC_PDD_MODULE_DISABLED | ((uint32_t)LDD_ADC_ON
 585              		.loc 1 447 0
 586 0038 4FF43043 		mov	r3, #45056
 587 003c C4F20303 		movt	r3, 16387
 588 0040 4FF05F02 		mov	r2, #95
 589 0044 1A60     		str	r2, [r3, #0]
 448:../Generated_Code/AdcLdd1.c ****   ADC_PDD_StartCalibration(ADC0_BASE_PTR); /* Start calibration */
 590              		.loc 1 448 0
 591 0046 4FF43043 		mov	r3, #45056
 592 004a C4F20303 		movt	r3, 16387
 593 004e 4FF43042 		mov	r2, #45056
 594 0052 C4F20302 		movt	r2, 16387
 595 0056 526A     		ldr	r2, [r2, #36]
 596 0058 42F08002 		orr	r2, r2, #128
 597 005c 5A62     		str	r2, [r3, #36]
 449:../Generated_Code/AdcLdd1.c ****   return ERR_OK;
 598              		.loc 1 449 0
 599 005e 4FF00003 		mov	r3, #0
 600              	.L26:
 450:../Generated_Code/AdcLdd1.c **** }
 601              		.loc 1 450 0
 602 0062 1846     		mov	r0, r3
 603 0064 07F10C07 		add	r7, r7, #12
 604 0068 BD46     		mov	sp, r7
 605 006a 80BC     		pop	{r7}
 606 006c 7047     		bx	lr
 607              		.cfi_endproc
 608              	.LFE6:
 610 006e 00BF     		.section	.text.AdcLdd1_GetCalibrationResultStatus,"ax",%progbits
 611              		.align	2
 612              		.global	AdcLdd1_GetCalibrationResultStatus
 613              		.thumb
 614              		.thumb_func
 616              	AdcLdd1_GetCalibrationResultStatus:
 617              	.LFB7:
 451:../Generated_Code/AdcLdd1.c **** 
 452:../Generated_Code/AdcLdd1.c **** /*
 453:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 454:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_GetCalibrationResultStatus (component ADC_LDD)
 455:../Generated_Code/AdcLdd1.c **** */
 456:../Generated_Code/AdcLdd1.c **** /*!
 457:../Generated_Code/AdcLdd1.c **** **     @brief
 458:../Generated_Code/AdcLdd1.c **** **         This method should be used for check the last calibration
 459:../Generated_Code/AdcLdd1.c **** **         result. If calibration completed normally the method finish
 460:../Generated_Code/AdcLdd1.c **** **         calibration process by writing gain calibration values.
 461:../Generated_Code/AdcLdd1.c **** **     @param
 462:../Generated_Code/AdcLdd1.c **** **         DeviceDataPtr   - Device data structure
 463:../Generated_Code/AdcLdd1.c **** **                           pointer returned by [Init] method.
 464:../Generated_Code/AdcLdd1.c **** **     @return
 465:../Generated_Code/AdcLdd1.c **** **                         - Error code
 466:../Generated_Code/AdcLdd1.c **** **                           ERR_OK - OK 
 467:../Generated_Code/AdcLdd1.c **** **                           ERR_FAILED - Last calibration hasn't been
 468:../Generated_Code/AdcLdd1.c **** **                           finished correctly
 469:../Generated_Code/AdcLdd1.c **** */
 470:../Generated_Code/AdcLdd1.c **** /* ===================================================================*/
 471:../Generated_Code/AdcLdd1.c **** LDD_TError AdcLdd1_GetCalibrationResultStatus(LDD_TDeviceData *DeviceDataPtr)
 472:../Generated_Code/AdcLdd1.c **** {
 618              		.loc 1 472 0
 619              		.cfi_startproc
 620              		@ args = 0, pretend = 0, frame = 16
 621              		@ frame_needed = 1, uses_anonymous_args = 0
 622              		@ link register save eliminated.
 623 0000 80B4     		push	{r7}
 624              	.LCFI21:
 625              		.cfi_def_cfa_offset 4
 626              		.cfi_offset 7, -4
 627 0002 85B0     		sub	sp, sp, #20
 628              	.LCFI22:
 629              		.cfi_def_cfa_offset 24
 630 0004 00AF     		add	r7, sp, #0
 631              	.LCFI23:
 632              		.cfi_def_cfa_register 7
 633 0006 7860     		str	r0, [r7, #4]
 473:../Generated_Code/AdcLdd1.c ****   uint32_t GainValue;
 474:../Generated_Code/AdcLdd1.c **** 
 475:../Generated_Code/AdcLdd1.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 476:../Generated_Code/AdcLdd1.c ****   if (ADC_PDD_GetCalibrationFailedStatusFlag(ADC0_BASE_PTR)) {
 634              		.loc 1 476 0
 635 0008 4FF43043 		mov	r3, #45056
 636 000c C4F20303 		movt	r3, 16387
 637 0010 5B6A     		ldr	r3, [r3, #36]
 638 0012 03F04003 		and	r3, r3, #64
 639 0016 002B     		cmp	r3, #0
 640 0018 02D0     		beq	.L28
 477:../Generated_Code/AdcLdd1.c ****     return ERR_FAILED;
 641              		.loc 1 477 0
 642 001a 4FF01B03 		mov	r3, #27
 643 001e 75E0     		b	.L29
 644              	.L28:
 478:../Generated_Code/AdcLdd1.c ****   }
 479:../Generated_Code/AdcLdd1.c ****   /* If calibration is successfully passed place calibrated value into gain registers */
 480:../Generated_Code/AdcLdd1.c ****   /* Cumulated gradually because of undefined behavior: the order of volatile accesses is undefined
 481:../Generated_Code/AdcLdd1.c ****   GainValue = ADC_PDD_GetPlus0CalibrationValue(ADC0_BASE_PTR); /* Find plus gain value */
 645              		.loc 1 481 0
 646 0020 4FF43043 		mov	r3, #45056
 647 0024 C4F20303 		movt	r3, 16387
 648 0028 DB6C     		ldr	r3, [r3, #76]
 649 002a FB60     		str	r3, [r7, #12]
 482:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetPlus1CalibrationValue(ADC0_BASE_PTR);
 650              		.loc 1 482 0
 651 002c 4FF43043 		mov	r3, #45056
 652 0030 C4F20303 		movt	r3, 16387
 653 0034 9B6C     		ldr	r3, [r3, #72]
 654 0036 FA68     		ldr	r2, [r7, #12]
 655 0038 D318     		adds	r3, r2, r3
 656 003a FB60     		str	r3, [r7, #12]
 483:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetPlus2CalibrationValue(ADC0_BASE_PTR);
 657              		.loc 1 483 0
 658 003c 4FF43043 		mov	r3, #45056
 659 0040 C4F20303 		movt	r3, 16387
 660 0044 5B6C     		ldr	r3, [r3, #68]
 661 0046 FA68     		ldr	r2, [r7, #12]
 662 0048 D318     		adds	r3, r2, r3
 663 004a FB60     		str	r3, [r7, #12]
 484:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetPlus3CalibrationValue(ADC0_BASE_PTR);
 664              		.loc 1 484 0
 665 004c 4FF43043 		mov	r3, #45056
 666 0050 C4F20303 		movt	r3, 16387
 667 0054 1B6C     		ldr	r3, [r3, #64]
 668 0056 FA68     		ldr	r2, [r7, #12]
 669 0058 D318     		adds	r3, r2, r3
 670 005a FB60     		str	r3, [r7, #12]
 485:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetPlus4CalibrationValue(ADC0_BASE_PTR);
 671              		.loc 1 485 0
 672 005c 4FF43043 		mov	r3, #45056
 673 0060 C4F20303 		movt	r3, 16387
 674 0064 DB6B     		ldr	r3, [r3, #60]
 675 0066 FA68     		ldr	r2, [r7, #12]
 676 0068 D318     		adds	r3, r2, r3
 677 006a FB60     		str	r3, [r7, #12]
 486:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetPlusSCalibrationValue(ADC0_BASE_PTR);
 678              		.loc 1 486 0
 679 006c 4FF43043 		mov	r3, #45056
 680 0070 C4F20303 		movt	r3, 16387
 681 0074 9B6B     		ldr	r3, [r3, #56]
 682 0076 FA68     		ldr	r2, [r7, #12]
 683 0078 D318     		adds	r3, r2, r3
 684 007a FB60     		str	r3, [r7, #12]
 487:../Generated_Code/AdcLdd1.c ****   GainValue = (GainValue >> 1U) | 0x8000U;
 685              		.loc 1 487 0
 686 007c FB68     		ldr	r3, [r7, #12]
 687 007e 4FEA5303 		lsr	r3, r3, #1
 688 0082 43F40043 		orr	r3, r3, #32768
 689 0086 FB60     		str	r3, [r7, #12]
 488:../Generated_Code/AdcLdd1.c ****   ADC_PDD_SetPlusGainValue(ADC0_BASE_PTR,GainValue); /* Set plus gain value */
 690              		.loc 1 488 0
 691 0088 4FF43043 		mov	r3, #45056
 692 008c C4F20303 		movt	r3, 16387
 693 0090 FA68     		ldr	r2, [r7, #12]
 694 0092 DA62     		str	r2, [r3, #44]
 489:../Generated_Code/AdcLdd1.c ****   GainValue = ADC_PDD_GetMinus0CalibrationValue(ADC0_BASE_PTR); /* Find minus gain value */
 695              		.loc 1 489 0
 696 0094 4FF43043 		mov	r3, #45056
 697 0098 C4F20303 		movt	r3, 16387
 698 009c DB6E     		ldr	r3, [r3, #108]
 699 009e FB60     		str	r3, [r7, #12]
 490:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetMinus1CalibrationValue(ADC0_BASE_PTR);
 700              		.loc 1 490 0
 701 00a0 4FF43043 		mov	r3, #45056
 702 00a4 C4F20303 		movt	r3, 16387
 703 00a8 9B6E     		ldr	r3, [r3, #104]
 704 00aa FA68     		ldr	r2, [r7, #12]
 705 00ac D318     		adds	r3, r2, r3
 706 00ae FB60     		str	r3, [r7, #12]
 491:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetMinus2CalibrationValue(ADC0_BASE_PTR);
 707              		.loc 1 491 0
 708 00b0 4FF43043 		mov	r3, #45056
 709 00b4 C4F20303 		movt	r3, 16387
 710 00b8 5B6E     		ldr	r3, [r3, #100]
 711 00ba FA68     		ldr	r2, [r7, #12]
 712 00bc D318     		adds	r3, r2, r3
 713 00be FB60     		str	r3, [r7, #12]
 492:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetMinus3CalibrationValue(ADC0_BASE_PTR);
 714              		.loc 1 492 0
 715 00c0 4FF43043 		mov	r3, #45056
 716 00c4 C4F20303 		movt	r3, 16387
 717 00c8 1B6E     		ldr	r3, [r3, #96]
 718 00ca FA68     		ldr	r2, [r7, #12]
 719 00cc D318     		adds	r3, r2, r3
 720 00ce FB60     		str	r3, [r7, #12]
 493:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetMinus4CalibrationValue(ADC0_BASE_PTR);
 721              		.loc 1 493 0
 722 00d0 4FF43043 		mov	r3, #45056
 723 00d4 C4F20303 		movt	r3, 16387
 724 00d8 DB6D     		ldr	r3, [r3, #92]
 725 00da FA68     		ldr	r2, [r7, #12]
 726 00dc D318     		adds	r3, r2, r3
 727 00de FB60     		str	r3, [r7, #12]
 494:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetMinusSCalibrationValue(ADC0_BASE_PTR);
 728              		.loc 1 494 0
 729 00e0 4FF43043 		mov	r3, #45056
 730 00e4 C4F20303 		movt	r3, 16387
 731 00e8 9B6D     		ldr	r3, [r3, #88]
 732 00ea FA68     		ldr	r2, [r7, #12]
 733 00ec D318     		adds	r3, r2, r3
 734 00ee FB60     		str	r3, [r7, #12]
 495:../Generated_Code/AdcLdd1.c ****   GainValue =  (GainValue >> 1U) | 0x8000U;
 735              		.loc 1 495 0
 736 00f0 FB68     		ldr	r3, [r7, #12]
 737 00f2 4FEA5303 		lsr	r3, r3, #1
 738 00f6 43F40043 		orr	r3, r3, #32768
 739 00fa FB60     		str	r3, [r7, #12]
 496:../Generated_Code/AdcLdd1.c ****   ADC_PDD_SetMinusGainValue(ADC0_BASE_PTR,GainValue); /* Set minus gain value */
 740              		.loc 1 496 0
 741 00fc 4FF43043 		mov	r3, #45056
 742 0100 C4F20303 		movt	r3, 16387
 743 0104 FA68     		ldr	r2, [r7, #12]
 744 0106 1A63     		str	r2, [r3, #48]
 497:../Generated_Code/AdcLdd1.c ****   return ERR_OK;
 745              		.loc 1 497 0
 746 0108 4FF00003 		mov	r3, #0
 747              	.L29:
 498:../Generated_Code/AdcLdd1.c **** }
 748              		.loc 1 498 0
 749 010c 1846     		mov	r0, r3
 750 010e 07F11407 		add	r7, r7, #20
 751 0112 BD46     		mov	sp, r7
 752 0114 80BC     		pop	{r7}
 753 0116 7047     		bx	lr
 754              		.cfi_endproc
 755              	.LFE7:
 757              		.section	.text.AdcLdd1_MeasurementCompleteInterrupt,"ax",%progbits
 758              		.align	2
 759              		.global	AdcLdd1_MeasurementCompleteInterrupt
 760              		.thumb
 761              		.thumb_func
 763              	AdcLdd1_MeasurementCompleteInterrupt:
 764              	.LFB8:
 499:../Generated_Code/AdcLdd1.c **** 
 500:../Generated_Code/AdcLdd1.c **** /*
 501:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 502:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_MeasurementCompleteInterrupt (component ADC_LDD)
 503:../Generated_Code/AdcLdd1.c **** **
 504:../Generated_Code/AdcLdd1.c **** **     Description :
 505:../Generated_Code/AdcLdd1.c **** **         Measurement complete interrupt handler
 506:../Generated_Code/AdcLdd1.c **** **         This method is internal. It is used by Processor Expert only.
 507:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 508:../Generated_Code/AdcLdd1.c **** */
 509:../Generated_Code/AdcLdd1.c **** PE_ISR(AdcLdd1_MeasurementCompleteInterrupt)
 510:../Generated_Code/AdcLdd1.c **** {
 765              		.loc 1 510 0
 766              		.cfi_startproc
 767              		@ Stack Align: May be called with mis-aligned SP.
 768              		@ args = 0, pretend = 0, frame = 8
 769              		@ frame_needed = 1, uses_anonymous_args = 0
 770 0000 6846     		mov	r0, sp
 771              		.cfi_register 13, 0
 772 0002 20F00701 		bic	r1, r0, #7
 773 0006 8D46     		mov	sp, r1
 774 0008 81B5     		push	{r0, r7, lr}
 775              	.LCFI24:
 776              		.cfi_def_cfa_offset 12
 777              		.cfi_offset 13, -12
 778              		.cfi_offset 7, -8
 779              		.cfi_offset 14, -4
 780 000a 83B0     		sub	sp, sp, #12
 781              	.LCFI25:
 782              		.cfi_def_cfa_offset 24
 783 000c 00AF     		add	r7, sp, #0
 784              	.LCFI26:
 785              		.cfi_def_cfa_register 7
 511:../Generated_Code/AdcLdd1.c ****   /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
 512:../Generated_Code/AdcLdd1.c ****   AdcLdd1_TDeviceDataPtr DeviceDataPrv = INT_ADC0__DEFAULT_RTOS_ISRPARAM;
 786              		.loc 1 512 0
 787 000e 40F20003 		movw	r3, #:lower16:INT_ADC0__DEFAULT_RTOS_ISRPARAM
 788 0012 C0F20003 		movt	r3, #:upper16:INT_ADC0__DEFAULT_RTOS_ISRPARAM
 789 0016 1B68     		ldr	r3, [r3, #0]
 790 0018 7B60     		str	r3, [r7, #4]
 513:../Generated_Code/AdcLdd1.c ****   DeviceDataPrv->CompleteStatus = TRUE; /* Set measurement complete status flag */
 791              		.loc 1 513 0
 792 001a 7B68     		ldr	r3, [r7, #4]
 793 001c 4FF00102 		mov	r2, #1
 794 0020 9A70     		strb	r2, [r3, #2]
 514:../Generated_Code/AdcLdd1.c ****   AdcLdd1_OnMeasurementComplete(DeviceDataPrv->UserData);
 795              		.loc 1 514 0
 796 0022 7B68     		ldr	r3, [r7, #4]
 797 0024 5B68     		ldr	r3, [r3, #4]
 798 0026 1846     		mov	r0, r3
 799 0028 FFF7FEFF 		bl	AdcLdd1_OnMeasurementComplete
 515:../Generated_Code/AdcLdd1.c ****   (void)ADC_PDD_GetResultValueRaw(ADC0_BASE_PTR, 0U); /* Clear conversion complete flag */
 800              		.loc 1 515 0
 801 002c 4FF43043 		mov	r3, #45056
 802 0030 C4F20303 		movt	r3, 16387
 803 0034 1B69     		ldr	r3, [r3, #16]
 516:../Generated_Code/AdcLdd1.c **** }
 804              		.loc 1 516 0
 805 0036 07F10C07 		add	r7, r7, #12
 806 003a BD46     		mov	sp, r7
 807 003c BDE88140 		pop	{r0, r7, lr}
 808 0040 8546     		mov	sp, r0
 809 0042 7047     		bx	lr
 810              		.cfi_endproc
 811              	.LFE8:
 813              		.text
 814              	.Letext0:
 815              		.file 2 "C:/Freescale/CW MCU v10.5/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 816              		.file 3 "../Generated_Code/PE_Types.h"
 817              		.file 4 "../Generated_Code/IO_Map.h"
 818              		.file 5 "../Generated_Code/AdcLdd1.h"
 819              		.file 6 "../Generated_Code/Cpu.h"
DEFINED SYMBOLS
                            *ABS*:00000000 AdcLdd1.c
C:\Users\Jay\AppData\Local\Temp\cceKkpry.s:19     .rodata.ChannelToPin:00000000 $d
C:\Users\Jay\AppData\Local\Temp\cceKkpry.s:22     .rodata.ChannelToPin:00000000 ChannelToPin
C:\Users\Jay\AppData\Local\Temp\cceKkpry.s:26     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\Users\Jay\AppData\Local\Temp\cceKkpry.s:29     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\Users\Jay\AppData\Local\Temp\cceKkpry.s:32     .bss.INT_ADC0__DEFAULT_RTOS_ISRPARAM:00000000 $d
C:\Users\Jay\AppData\Local\Temp\cceKkpry.s:35     .bss.INT_ADC0__DEFAULT_RTOS_ISRPARAM:00000000 INT_ADC0__DEFAULT_RTOS_ISRPARAM
C:\Users\Jay\AppData\Local\Temp\cceKkpry.s:38     .text.AdcLdd1_Init:00000000 $t
C:\Users\Jay\AppData\Local\Temp\cceKkpry.s:43     .text.AdcLdd1_Init:00000000 AdcLdd1_Init
C:\Users\Jay\AppData\Local\Temp\cceKkpry.s:166    .text.AdcLdd1_StartSingleMeasurement:00000000 $t
C:\Users\Jay\AppData\Local\Temp\cceKkpry.s:171    .text.AdcLdd1_StartSingleMeasurement:00000000 AdcLdd1_StartSingleMeasurement
C:\Users\Jay\AppData\Local\Temp\cceKkpry.s:235    .text.AdcLdd1_CancelMeasurement:00000000 $t
C:\Users\Jay\AppData\Local\Temp\cceKkpry.s:240    .text.AdcLdd1_CancelMeasurement:00000000 AdcLdd1_CancelMeasurement
C:\Users\Jay\AppData\Local\Temp\cceKkpry.s:283    .text.AdcLdd1_CreateSampleGroup:00000000 $t
C:\Users\Jay\AppData\Local\Temp\cceKkpry.s:288    .text.AdcLdd1_CreateSampleGroup:00000000 AdcLdd1_CreateSampleGroup
C:\Users\Jay\AppData\Local\Temp\cceKkpry.s:373    .text.AdcLdd1_GetMeasuredValues:00000000 $t
C:\Users\Jay\AppData\Local\Temp\cceKkpry.s:378    .text.AdcLdd1_GetMeasuredValues:00000000 AdcLdd1_GetMeasuredValues
C:\Users\Jay\AppData\Local\Temp\cceKkpry.s:440    .text.AdcLdd1_GetMeasurementCompleteStatus:00000000 $t
C:\Users\Jay\AppData\Local\Temp\cceKkpry.s:445    .text.AdcLdd1_GetMeasurementCompleteStatus:00000000 AdcLdd1_GetMeasurementCompleteStatus
C:\Users\Jay\AppData\Local\Temp\cceKkpry.s:543    .text.AdcLdd1_StartCalibration:00000000 $t
C:\Users\Jay\AppData\Local\Temp\cceKkpry.s:548    .text.AdcLdd1_StartCalibration:00000000 AdcLdd1_StartCalibration
C:\Users\Jay\AppData\Local\Temp\cceKkpry.s:611    .text.AdcLdd1_GetCalibrationResultStatus:00000000 $t
C:\Users\Jay\AppData\Local\Temp\cceKkpry.s:616    .text.AdcLdd1_GetCalibrationResultStatus:00000000 AdcLdd1_GetCalibrationResultStatus
C:\Users\Jay\AppData\Local\Temp\cceKkpry.s:758    .text.AdcLdd1_MeasurementCompleteInterrupt:00000000 $t
C:\Users\Jay\AppData\Local\Temp\cceKkpry.s:763    .text.AdcLdd1_MeasurementCompleteInterrupt:00000000 AdcLdd1_MeasurementCompleteInterrupt
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
PE_LDD_DeviceDataList
SR_lock
SR_reg
AdcLdd1_OnMeasurementComplete
