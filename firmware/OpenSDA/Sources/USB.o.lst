   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"USB.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.comm	commandBuffer,300,4
  19              		.section	.text.noChange32,"ax",%progbits
  20              		.align	2
  21              		.thumb
  22              		.thumb_func
  24              	noChange32:
  25              	.LFB0:
  26              		.file 1 "../Sources/USB.c"
   1:../Sources/USB.c **** /*! \file
   2:../Sources/USB.c ****     \brief Simple USB Stack for JM60
   3:../Sources/USB.c ****     
   4:../Sources/USB.c ****    \verbatim
   5:../Sources/USB.c ****     Kinetis USB Code
   6:../Sources/USB.c ****     
   7:../Sources/USB.c ****     Copyright (C) 2008-12  Peter O'Donoghue
   8:../Sources/USB.c **** 
   9:../Sources/USB.c ****     This program is free software; you can redistribute it and/or modify
  10:../Sources/USB.c ****     it under the terms of the GNU General Public License as published by
  11:../Sources/USB.c ****     the Free Software Foundation; either version 2 of the License, or
  12:../Sources/USB.c ****     (at your option) any later version.
  13:../Sources/USB.c **** 
  14:../Sources/USB.c ****     This program is distributed in the hope that it will be useful,
  15:../Sources/USB.c ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  16:../Sources/USB.c ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  17:../Sources/USB.c ****     GNU General Public License for more details.
  18:../Sources/USB.c **** 
  19:../Sources/USB.c ****     You should have received a copy of the GNU General Public License
  20:../Sources/USB.c ****     along with this program; if not, write to the Free Software
  21:../Sources/USB.c ****     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  22:../Sources/USB.c ****     \endverbatim
  23:../Sources/USB.c **** 
  24:../Sources/USB.c **** \verbatim
  25:../Sources/USB.c **** Change History
  26:../Sources/USB.c **** +=================================================================================
  27:../Sources/USB.c **** | 04 Sep 2011 | Ported to MK20DX128
  28:../Sources/USB.c **** +=================================================================================
  29:../Sources/USB.c **** \endverbatim
  30:../Sources/USB.c **** */
  31:../Sources/USB.c **** #include <string.h>
  32:../Sources/USB.c **** #include "derivative.h" /* include peripheral declarations */
  33:../Sources/USB.c **** #include "Common.h"
  34:../Sources/USB.c **** //#include "BDM.h"
  35:../Sources/USB.c **** //#include "BDMCommon.h"
  36:../Sources/USB.c **** //#include "CmdProcessing.h"
  37:../Sources/USB.c **** #include "USBDefs.h"
  38:../Sources/USB.c **** #include "USB.h"
  39:../Sources/USB.c **** 
  40:../Sources/USB.c **** #if (HW_CAPABILITY&CAP_CDC)
  41:../Sources/USB.c **** static void ep3StartTxTransaction( void );
  42:../Sources/USB.c **** static void ep4InitialiseBdtRx( void );
  43:../Sources/USB.c **** static void ep5StartTxTransactionIfIdle();
  44:../Sources/USB.c **** #endif
  45:../Sources/USB.c **** 
  46:../Sources/USB.c **** #if CPU == MK20D5
  47:../Sources/USB.c ****    #define enableUSBIrq()   NVIC_ISER((INT_USB0-16)/32) = NVIC_ISER_SETENA(1<<((INT_USB0-16)%32));
  48:../Sources/USB.c ****    #define disableUSBIrq()  NVIC_ICER((INT_USB0-16)/32) = NVIC_ICER_CLRENA(1<<((INT_USB0-16)%32));
  49:../Sources/USB.c **** #elif CPU == MKL25Z4 
  50:../Sources/USB.c ****    #define enableUSBIrq()   NVIC_ISER = NVIC_ISER_SETENA(1<<((INT_USB0-16)%32));
  51:../Sources/USB.c ****    #define disableUSBIrq()  NVIC_ICER = NVIC_ICER_CLRENA(1<<((INT_USB0-16)%32));
  52:../Sources/USB.c **** #else
  53:../Sources/USB.c ****    #error "CPU not set"
  54:../Sources/USB.c **** #endif
  55:../Sources/USB.c **** 
  56:../Sources/USB.c **** uint8_t commandBuffer[300];
  57:../Sources/USB.c **** 
  58:../Sources/USB.c **** #ifdef __BIG_ENDIAN__
  59:../Sources/USB.c **** __inline
  60:../Sources/USB.c **** static uint32_t swap32(uint32_t data) {
  61:../Sources/USB.c ****    return ((data<<24)&0xFF000000)|((data<<8)&0x00FF0000)|
  62:../Sources/USB.c ****           ((data>>24)&0x000000FF)|((data>>8)&0x0000FF00);
  63:../Sources/USB.c **** }
  64:../Sources/USB.c **** __inline
  65:../Sources/USB.c **** static uint16_t swap16(uint16_t data) {
  66:../Sources/USB.c ****        return ((data<<16)&0xFF00)|((data>>8)&0xFF);
  67:../Sources/USB.c **** }
  68:../Sources/USB.c **** #define leToNative32(x) swap32(x)
  69:../Sources/USB.c **** #define leToNative16(x) swap16(x)
  70:../Sources/USB.c **** #define nativeToLe32(x) swap32(x)
  71:../Sources/USB.c **** #define nativeToLe16(x) swap16(x)
  72:../Sources/USB.c **** #elif defined(__LITTLE_ENDIAN__)
  73:../Sources/USB.c **** __inline
  74:../Sources/USB.c **** static uint32_t noChange32(uint32_t data) {
  27              		.loc 1 74 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32 0000 80B4     		push	{r7}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 4
  35              		.cfi_offset 7, -4
  36 0002 83B0     		sub	sp, sp, #12
  37              	.LCFI1:
  38              		.cfi_def_cfa_offset 16
  39 0004 00AF     		add	r7, sp, #0
  40              	.LCFI2:
  41              		.cfi_def_cfa_register 7
  42 0006 7860     		str	r0, [r7, #4]
  75:../Sources/USB.c ****    return data;
  43              		.loc 1 75 0
  44 0008 7B68     		ldr	r3, [r7, #4]
  76:../Sources/USB.c **** }
  45              		.loc 1 76 0
  46 000a 1846     		mov	r0, r3
  47 000c 07F10C07 		add	r7, r7, #12
  48 0010 BD46     		mov	sp, r7
  49 0012 80BC     		pop	{r7}
  50 0014 7047     		bx	lr
  51              		.cfi_endproc
  52              	.LFE0:
  54 0016 00BF     		.section	.text.noChange16,"ax",%progbits
  55              		.align	2
  56              		.thumb
  57              		.thumb_func
  59              	noChange16:
  60              	.LFB1:
  77:../Sources/USB.c **** __inline
  78:../Sources/USB.c **** static uint16_t noChange16(uint16_t data) {
  61              		.loc 1 78 0
  62              		.cfi_startproc
  63              		@ args = 0, pretend = 0, frame = 8
  64              		@ frame_needed = 1, uses_anonymous_args = 0
  65              		@ link register save eliminated.
  66 0000 80B4     		push	{r7}
  67              	.LCFI3:
  68              		.cfi_def_cfa_offset 4
  69              		.cfi_offset 7, -4
  70 0002 83B0     		sub	sp, sp, #12
  71              	.LCFI4:
  72              		.cfi_def_cfa_offset 16
  73 0004 00AF     		add	r7, sp, #0
  74              	.LCFI5:
  75              		.cfi_def_cfa_register 7
  76 0006 0346     		mov	r3, r0
  77 0008 FB80     		strh	r3, [r7, #6]	@ movhi
  79:../Sources/USB.c ****        return data;
  78              		.loc 1 79 0
  79 000a FB88     		ldrh	r3, [r7, #6]
  80:../Sources/USB.c **** }
  80              		.loc 1 80 0
  81 000c 1846     		mov	r0, r3
  82 000e 07F10C07 		add	r7, r7, #12
  83 0012 BD46     		mov	sp, r7
  84 0014 80BC     		pop	{r7}
  85 0016 7047     		bx	lr
  86              		.cfi_endproc
  87              	.LFE1:
  89              		.comm	ep0InDataBuffer,32,4
  90              		.comm	ep0OutDataBuffer,32,4
  91              		.comm	ep1DataBuffer,64,4
  92              		.comm	ep2DataBuffer,64,4
  93              		.section	.user_data2,"aw",%progbits
  94              		.align	2
  97              	endPointBdts:
  98 0000 00000000 		.space	512
  98      00000000 
  98      00000000 
  98      00000000 
  98      00000000 
  99              		.section	.rodata.deviceDescriptor,"a",%progbits
 100              		.align	2
 103              	deviceDescriptor:
 104 0000 12       		.byte	18
 105 0001 01       		.byte	1
 106 0002 0002     		.short	512
 107 0004 FF       		.byte	-1
 108 0005 FF       		.byte	-1
 109 0006 FF       		.byte	-1
 110 0007 20       		.byte	32
 111 0008 D804     		.short	1240
 112 000a 5300     		.short	83
 113 000c 1004     		.short	1040
 114 000e 01       		.byte	1
 115 000f 02       		.byte	2
 116 0010 03       		.byte	3
 117 0011 01       		.byte	1
 118 0012 0000     		.section	.rodata.otherDescriptors,"a",%progbits
 119              		.align	2
 122              	otherDescriptors:
 123 0000 09       		.byte	9
 124 0001 02       		.byte	2
 125 0002 2000     		.short	32
 126 0004 01       		.byte	1
 127 0005 01       		.byte	1
 128 0006 00       		.byte	0
 129 0007 80       		.byte	-128
 130 0008 FA       		.byte	-6
 131 0009 09       		.byte	9
 132 000a 04       		.byte	4
 133 000b 00       		.byte	0
 134 000c 00       		.byte	0
 135 000d 02       		.byte	2
 136 000e FF       		.byte	-1
 137 000f FF       		.byte	-1
 138 0010 FF       		.byte	-1
 139 0011 05       		.byte	5
 140 0012 07       		.byte	7
 141 0013 05       		.byte	5
 142 0014 01       		.byte	1
 143 0015 02       		.byte	2
 144 0016 4000     		.short	64
 145 0018 01       		.byte	1
 146 0019 07       		.byte	7
 147 001a 05       		.byte	5
 148 001b 82       		.byte	-126
 149 001c 02       		.byte	2
 150 001d 4000     		.2byte	64
 151 001f 01       		.byte	1
 152              		.section	.rodata.msCompatibleIdFeatureDescriptor,"a",%progbits
 153              		.align	2
 156              	msCompatibleIdFeatureDescriptor:
 157 0000 28000000 		.word	40
 158 0004 0001     		.short	256
 159 0006 0400     		.short	4
 160 0008 01       		.byte	1
 161 0009 00       		.byte	0
 162 000a 00000000 		.space	6
 162      0000
 163 0010 00       		.byte	0
 164 0011 01       		.byte	1
 165 0012 57494E55 		.ascii	"WINUSB\000\000"
 165      53420000 
 166 001a 00       		.byte	0
 167 001b 00000000 		.space	7
 167      000000
 168 0022 00       		.byte	0
 169 0023 00000000 		.space	5
 169      00
 170              		.section	.rodata.msPropertiesFeatureDescriptor,"a",%progbits
 171              		.align	2
 174              	msPropertiesFeatureDescriptor:
 175 0000 8E000000 		.word	142
 176 0004 0001     		.short	256
 177 0006 0500     		.short	5
 178 0008 0100     		.short	1
 179 000a 84000000 		.4byte	132
 180 000e 01000000 		.4byte	1
 181 0012 2800     		.short	40
 182 0014 44006500 		.ascii	"D\000e\000v\000i\000c\000e\000I\000n\000t\000e\000r"
 182      76006900 
 182      63006500 
 182      49006E00 
 182      74006500 
 183 0029 00660061 		.ascii	"\000f\000a\000c\000e\000G\000U\000I\000D\000\000\000"
 183      00630065 
 183      00470055 
 183      00490044 
 183      000000
 184 003c 4E000000 		.word	78
 185 0040 7B003500 		.ascii	"{\0005\0008\000d\0000\0007\0002\0001\0000\000-\0002"
 185      38006400 
 185      30003700 
 185      32003100 
 185      30002D00 
 186 0055 00370043 		.ascii	"\0007\000C\0001\000-\0001\0001\000D\000D\000-\000B\000"
 186      0031002D 
 186      00310031 
 186      00440044 
 186      002D0042 
 187 006a 44003000 		.ascii	"D\0000\000B\000-\0000\0008\0000\0000\0002\0000\0000"
 187      42002D00 
 187      30003800 
 187      30003000 
 187      32003000 
 188 007f 00430039 		.ascii	"\000C\0009\000A\0006\0006\000}\000\000"
 188      00410036 
 188      0036007D 
 188      0000
 189 008d 00       		.space	1
 190 008e 0000     		.section	.rodata.OS_StringDescriptor,"a",%progbits
 191              		.align	2
 194              	OS_StringDescriptor:
 195 0000 12       		.byte	18
 196 0001 03       		.byte	3
 197 0002 4D       		.byte	77
 198 0003 00       		.byte	0
 199 0004 53       		.byte	83
 200 0005 00       		.byte	0
 201 0006 46       		.byte	70
 202 0007 00       		.byte	0
 203 0008 54       		.byte	84
 204 0009 00       		.byte	0
 205 000a 31       		.byte	49
 206 000b 00       		.byte	0
 207 000c 30       		.byte	48
 208 000d 00       		.byte	0
 209 000e 30       		.byte	48
 210 000f 00       		.byte	0
 211 0010 30       		.byte	48
 212 0011 00       		.byte	0
 213 0012 0000     		.section	.rodata.sd0,"a",%progbits
 214              		.align	2
 217              	sd0:
 218 0000 04       		.byte	4
 219 0001 03       		.byte	3
 220 0002 09       		.byte	9
 221 0003 0C       		.byte	12
 222              		.section	.rodata.sd1,"a",%progbits
 223              		.align	2
 226              	sd1:
 227 0000 554E4C20 		.ascii	"UNL Robotics\000"
 227      526F626F 
 227      74696373 
 227      00
 228 000d 000000   		.section	.rodata.sd2,"a",%progbits
 229              		.align	2
 232              	sd2:
 233 0000 424C4443 		.ascii	"BLDC Motor controller\000"
 233      204D6F74 
 233      6F722063 
 233      6F6E7472 
 233      6F6C6C65 
 234 0016 0000     		.section	.rodata.sd3,"a",%progbits
 235              		.align	2
 238              	sd3:
 239 0000 424C4443 		.ascii	"BLDC000001\000"
 239      30303030 
 239      303100
 240 000b 00       		.section	.rodata.sd4,"a",%progbits
 241              		.align	2
 244              	sd4:
 245 0000 424C4443 		.ascii	"BLDC Motor\000"
 245      204D6F74 
 245      6F7200
 246 000b 00       		.section	.rodata.sd5,"a",%progbits
 247              		.align	2
 250              	sd5:
 251 0000 424C4443 		.ascii	"BLDC Motor WinUSB\000"
 251      204D6F74 
 251      6F722057 
 251      696E5553 
 251      4200
 252 0012 0000     		.section	.rodata.sd6,"a",%progbits
 253              		.align	2
 256              	sd6:
 257 0000 424C4443 		.ascii	"BLDC CDC Interface\000"
 257      20434443 
 257      20496E74 
 257      65726661 
 257      636500
 258 0013 00       		.section	.rodata.sd7,"a",%progbits
 259              		.align	2
 262              	sd7:
 263 0000 496E7465 		.ascii	"Interface 1 - CDC Control\000"
 263      72666163 
 263      65203120 
 263      2D204344 
 263      4320436F 
 264 001a 0000     		.section	.rodata.sd8,"a",%progbits
 265              		.align	2
 268              	sd8:
 269 0000 496E7465 		.ascii	"Interface 2 - CDC Data\000"
 269      72666163 
 269      65203220 
 269      2D204344 
 269      43204461 
 270 0017 00       		.section	.rodata.stringDescriptors,"a",%progbits
 271              		.align	2
 274              	stringDescriptors:
 275 0000 00000000 		.word	sd0
 276 0004 00000000 		.word	sd1
 277 0008 00000000 		.word	sd2
 278 000c 00000000 		.word	sd3
 279 0010 00000000 		.word	sd4
 280 0014 00000000 		.word	sd5
 281 0018 00000000 		.word	sd6
 282 001c 00000000 		.word	sd7
 283 0020 00000000 		.word	sd8
 284              		.global	deviceState
 285              		.section	.data.deviceState,"aw",%progbits
 286              		.align	2
 289              	deviceState:
 290 0000 01       		.byte	1
 291 0001 00       		.byte	0
 292 0002 00       		.byte	0
 293 0003 00       		.space	1
 294 0004 00       		.byte	0
 295 0005 00       		.byte	0
 296 0006 0000     		.space	2
 297 0008 00       		.byte	0
 298 0009 000000   		.space	3
 299              		.section	.bss.reInit,"aw",%nobits
 302              	reInit:
 303 0000 00       		.space	1
 304              		.section	.bss.ep0State,"aw",%nobits
 305              		.align	2
 308              	ep0State:
 309 0000 00000000 		.space	12
 309      00000000 
 309      00000000 
 310              		.section	.bss.ep1State,"aw",%nobits
 311              		.align	2
 314              	ep1State:
 315 0000 00000000 		.space	12
 315      00000000 
 315      00000000 
 316              		.section	.bss.ep2State,"aw",%nobits
 317              		.align	2
 320              	ep2State:
 321 0000 00000000 		.space	12
 321      00000000 
 321      00000000 
 322              		.section	.bss.epHardwareState,"aw",%nobits
 323              		.align	2
 326              	epHardwareState:
 327 0000 000000   		.space	3
 328 0003 00       		.section	.bss.usbActivityFlag,"aw",%nobits
 329              		.align	2
 332              	usbActivityFlag:
 333 0000 00000000 		.space	4
 334              		.section	.bss.ep0SetupBuffer,"aw",%nobits
 335              		.align	2
 338              	ep0SetupBuffer:
 339 0000 00000000 		.space	8
 339      00000000 
 340              		.section	.text.initEndpointBuffers,"ax",%progbits
 341              		.align	2
 342              		.thumb
 343              		.thumb_func
 345              	initEndpointBuffers:
 346              	.LFB2:
  81:../Sources/USB.c **** #define leToNative32(x) noChange32(x)
  82:../Sources/USB.c **** #define leToNative16(x) noChange16(x)
  83:../Sources/USB.c **** #define nativeToLe32(x) noChange32(x)
  84:../Sources/USB.c **** #define nativeToLe16(x) noChange16(x)
  85:../Sources/USB.c **** #else
  86:../Sources/USB.c **** #error "Please define __BIG_ENDIAN__ or __LITTLE_ENDIAN__"
  87:../Sources/USB.c **** #endif
  88:../Sources/USB.c **** 
  89:../Sources/USB.c **** //======================================================================
  90:../Sources/USB.c **** // Maximum packet sizes for each endpoint
  91:../Sources/USB.c **** //
  92:../Sources/USB.c **** #if (HW_CAPABILITY&CAP_CDC)
  93:../Sources/USB.c **** #define NUMBER_OF_EPS    (6)
  94:../Sources/USB.c **** #define ENDPT0MAXSIZE    (16) //!< USBDM - Control in/out 
  95:../Sources/USB.c **** #define ENDPT1MAXSIZE    (64) //!< USBDM - BDM out
  96:../Sources/USB.c **** #define ENDPT2MAXSIZE    (64) //!< USBDM - BDM in
  97:../Sources/USB.c **** #define ENDPT3MAXSIZE    (16) //!< USBDM - CDC control      
  98:../Sources/USB.c **** #define ENDPT4MAXSIZE    (16) //!< USBDM - CDC data out
  99:../Sources/USB.c **** #define ENDPT5MAXSIZE    (16) //!< USBDM - CDC data in
 100:../Sources/USB.c **** 
 101:../Sources/USB.c **** #else
 102:../Sources/USB.c **** #define NUMBER_OF_EPS    (3)  //!< Number of end-points in use
 103:../Sources/USB.c **** #define ENDPT0MAXSIZE    (32) //!< USBDM - Control in/out    
 104:../Sources/USB.c **** #define ENDPT1MAXSIZE    (64) //!< USBDM - BDM out
 105:../Sources/USB.c **** #define ENDPT2MAXSIZE    (64) //!< USBDM - BDM in
 106:../Sources/USB.c **** #define ENDPT3MAXSIZE    (0)  //!< USBDM - CDC control (not used)
 107:../Sources/USB.c **** #define ENDPT4MAXSIZE    (0)  //!< USBDM - CDC data out (not used)
 108:../Sources/USB.c **** #define ENDPT5MAXSIZE    (0)  //!< USBDM - CDC data in (not used)
 109:../Sources/USB.c **** #endif
 110:../Sources/USB.c **** 
 111:../Sources/USB.c **** //======================================================================
 112:../Sources/USB.c **** // Data packet odd/even indicator
 113:../Sources/USB.c **** enum {DATA0=0, //!< DATA0 indicator
 114:../Sources/USB.c ****       DATA1=1  //!< DATA1 indicator
 115:../Sources/USB.c ****      };
 116:../Sources/USB.c **** 
 117:../Sources/USB.c **** //======================================================================
 118:../Sources/USB.c **** //! Structure representing a BDT entry in USB controller
 119:../Sources/USB.c **** //!
 120:../Sources/USB.c **** #pragma pack(1)
 121:../Sources/USB.c **** #if 1
 122:../Sources/USB.c **** // Little-endian on Kinetis
 123:../Sources/USB.c **** typedef struct {
 124:../Sources/USB.c ****    union {
 125:../Sources/USB.c ****       volatile uint8_t bits:8;   // Access a bit masks
 126:../Sources/USB.c ****       volatile struct {          // BDT setup access
 127:../Sources/USB.c ****          uint8_t :2;
 128:../Sources/USB.c ****          uint8_t bdt_stall:1;
 129:../Sources/USB.c ****          uint8_t dts:1;
 130:../Sources/USB.c ****          uint8_t ninc:1;
 131:../Sources/USB.c ****          uint8_t keep:1;
 132:../Sources/USB.c ****          uint8_t data0_1:1;
 133:../Sources/USB.c ****          uint8_t own:1;
 134:../Sources/USB.c ****       } setup;
 135:../Sources/USB.c ****       volatile struct {          // BDT result access
 136:../Sources/USB.c ****          uint8_t :2;
 137:../Sources/USB.c ****          uint8_t tok_pid:4;
 138:../Sources/USB.c ****          uint8_t data0_1:1;
 139:../Sources/USB.c ****          uint8_t own:1;
 140:../Sources/USB.c ****       } result;
 141:../Sources/USB.c ****    } u;
 142:../Sources/USB.c ****    volatile uint8_t  :8;
 143:../Sources/USB.c ****    volatile uint16_t bc;          // Byte count
 144:../Sources/USB.c ****    volatile uint32_t addr;        // buffer address
 145:../Sources/USB.c **** } BdtEntry ;
 146:../Sources/USB.c **** #else
 147:../Sources/USB.c **** // Big-endian (Used on Coldfire)
 148:../Sources/USB.c **** typedef struct {
 149:../Sources/USB.c ****    union {
 150:../Sources/USB.c ****       struct { 
 151:../Sources/USB.c ****          uint8_t rsvd:2;
 152:../Sources/USB.c ****          uint8_t bdt_stall:1;
 153:../Sources/USB.c ****          uint8_t dts:1;
 154:../Sources/USB.c ****          uint8_t ninc:1;
 155:../Sources/USB.c ****          uint8_t keep:1;
 156:../Sources/USB.c ****          uint8_t data0_1:1;
 157:../Sources/USB.c ****          uint8_t own:1;
 158:../Sources/USB.c ****       } setup;           // BDT setup access
 159:../Sources/USB.c ****       struct {
 160:../Sources/USB.c ****          uint8_t rsvd:2;
 161:../Sources/USB.c ****          uint8_t tok_pid:4;
 162:../Sources/USB.c ****          uint8_t data0_1:1;
 163:../Sources/USB.c ****          uint8_t own:1;
 164:../Sources/USB.c ****       } result;          // BDT result access
 165:../Sources/USB.c ****       uint8_t bits;      // Access as bit masks
 166:../Sources/USB.c ****    } u;
 167:../Sources/USB.c ****    uint8_t  rsvd2:8;
 168:../Sources/USB.c ****    uint16_t bc:16;       // Byte count
 169:../Sources/USB.c ****    uint32_t addr;        // Buffer address
 170:../Sources/USB.c **** } BdtEntry ;
 171:../Sources/USB.c **** #endif
 172:../Sources/USB.c **** #pragma pack(0)
 173:../Sources/USB.c **** 
 174:../Sources/USB.c **** #define USB_INTMASKS (USB_INTEN_STALLEN_MASK|USB_INTEN_TOKDNEEN_MASK|\
 175:../Sources/USB.c ****         USB_INTEN_SOFTOKEN_MASK|USB_INTEN_USBRSTEN_MASK|\
 176:../Sources/USB.c ****         USB_INTEN_STALLEN_MASK)  //!< Mask for all USB interrupts
 177:../Sources/USB.c **** 
 178:../Sources/USB.c **** typedef struct {
 179:../Sources/USB.c ****    BdtEntry rxEven;
 180:../Sources/USB.c ****    BdtEntry rxOdd;
 181:../Sources/USB.c ****    BdtEntry txEven;
 182:../Sources/USB.c ****    BdtEntry txOdd;
 183:../Sources/USB.c **** } EndpointBdtEntry;
 184:../Sources/USB.c **** 
 185:../Sources/USB.c **** // Bit masks bits field in above 
 186:../Sources/USB.c **** #define BDTEntry_OWN_MASK        (1<<7)   //!< Mask for OWN bit in BDT
 187:../Sources/USB.c **** #define BDTEntry_DATA0_MASK      (0<<6)   //!< Mask for DATA1 bit in BDT (dummy)
 188:../Sources/USB.c **** #define BDTEntry_DATA1_MASK      (1<<6)   //!< Mask for DATA0 bit in BDT
 189:../Sources/USB.c **** #define BDTEntry_KEEP_MASK       (1<<5)   //!< KEEP
 190:../Sources/USB.c **** #define BDTEntry_NINC_MASK       (1<<4)   //!< NINC
 191:../Sources/USB.c **** #define BDTEntry_DTS_MASK        (1<<3)   //!< Mask for DTS bit in BDT
 192:../Sources/USB.c **** #define BDTEntry_STALL_MASK      (1<<2)   //!< Stall endpoint
 193:../Sources/USB.c **** 
 194:../Sources/USB.c **** //#pragma define_section data_type ".bdts" abs32 RW
 195:../Sources/USB.c **** 
 196:../Sources/USB.c **** //======================================================================
 197:../Sources/USB.c **** // Buffers for endpoint data packets (in USB RAM)
 198:../Sources/USB.c **** 
 199:../Sources/USB.c **** uint8_t ep0InDataBuffer[ENDPT0MAXSIZE];
 200:../Sources/USB.c **** uint8_t ep0OutDataBuffer[ENDPT0MAXSIZE];
 201:../Sources/USB.c **** uint8_t ep1DataBuffer[ENDPT1MAXSIZE];
 202:../Sources/USB.c **** uint8_t ep2DataBuffer[ENDPT2MAXSIZE];
 203:../Sources/USB.c **** #if (HW_CAPABILITY&CAP_CDC)   
 204:../Sources/USB.c **** uint8_t ep3DataBuffer[ENDPT3MAXSIZE];
 205:../Sources/USB.c **** uint8_t ep4DataBuffer[ENDPT4MAXSIZE];
 206:../Sources/USB.c **** uint8_t ep5DataBuffer0[ENDPT5MAXSIZE];
 207:../Sources/USB.c **** uint8_t ep5DataBuffer1[ENDPT5MAXSIZE];
 208:../Sources/USB.c **** #endif
 209:../Sources/USB.c **** 
 210:../Sources/USB.c **** __attribute__ ((section(".user_data2"))) 
 211:../Sources/USB.c **** static EndpointBdtEntry endPointBdts[16];
 212:../Sources/USB.c **** // Raw BDTS (0 - 4*#endpoints)
 213:../Sources/USB.c **** #define BDTS(n) (*((&endPointBdts[0].rxEven)+(n))) 
 214:../Sources/USB.c **** 
 215:../Sources/USB.c **** //======================================================================
 216:../Sources/USB.c **** // Descriptors
 217:../Sources/USB.c **** //
 218:../Sources/USB.c **** static const DeviceDescriptor deviceDescriptor = {
 219:../Sources/USB.c ****    sizeof(DeviceDescriptor),               // bLength
 220:../Sources/USB.c ****    DT_DEVICE,                              // bDescriptorType
 221:../Sources/USB.c ****    CONST_NATIVE_TO_LE16(0x0200),           // bcdUSB              = USB spec rel. No.      [BCD = 2
 222:../Sources/USB.c **** #if (HW_CAPABILITY&CAP_CDC)
 223:../Sources/USB.c ****    0xEF,                                   // bDeviceClass        = Device Class code [Miscellaneou
 224:../Sources/USB.c ****    0x02,                                   // bDeviceSubClass     = Sub Class code    [Common Class
 225:../Sources/USB.c ****    0x01,                                   // bDeviceProtocol     = Protocol          [Interface As
 226:../Sources/USB.c **** #else
 227:../Sources/USB.c ****    0xFF,                                   // Class code             [none]
 228:../Sources/USB.c ****    0xFF,                                   // Sub Class code         [none]
 229:../Sources/USB.c ****    0xFF,                                   // Protocol               [none]
 230:../Sources/USB.c **** #endif
 231:../Sources/USB.c ****    ENDPT0MAXSIZE,                          // bMaxPacketSize0    = EndPt 0 max packet size
 232:../Sources/USB.c ****    CONST_NATIVE_TO_LE16(0x04D8),         // idVendor           = Vendor ID
 233:../Sources/USB.c ****    CONST_NATIVE_TO_LE16(0x0053),        // idProduct          = Product ID
 234:../Sources/USB.c ****    CONST_NATIVE_TO_LE16(0x0410),           // bcdDevice          = Device Release         [BCD = 4.
 235:../Sources/USB.c ****    1,                                      // iManufacturer      = String index of Manufacturer nam
 236:../Sources/USB.c ****    2,                                      // iProduct           = String index of product desc.
 237:../Sources/USB.c ****    3,                                      // iSerialNumber      = String index desc. serial #
 238:../Sources/USB.c ****    1                                       // bNumConfigurations = Number of configurations
 239:../Sources/USB.c **** };
 240:../Sources/USB.c **** 
 241:../Sources/USB.c **** static const struct {
 242:../Sources/USB.c ****    ConfigurationDescriptor                  configDescriptor;
 243:../Sources/USB.c ****    InterfaceDescriptor                      interfaceDescriptor0;
 244:../Sources/USB.c ****    EndpointDescriptor                       endpointDescriptor1;
 245:../Sources/USB.c ****    EndpointDescriptor                       endpointDescriptor2;
 246:../Sources/USB.c **** #if (HW_CAPABILITY&CAP_CDC)
 247:../Sources/USB.c ****    InterfaceAssociationDescriptor           interfaceAssociationDescriptorCDC;
 248:../Sources/USB.c ****    InterfaceDescriptor                      interfaceDescriptor1;
 249:../Sources/USB.c ****    CDCHeaderFunctionalDescriptor            headerFunctionalDescriptor;
 250:../Sources/USB.c ****    CDCCallManagementFunctionalDescriptor    callManagementDescriptor;
 251:../Sources/USB.c ****    CDCAbstractControlManagementDescriptor   abstractControlManagementFunctionalDescriptor;
 252:../Sources/USB.c ****    CDCUnionFunctionalDescriptor             unionFunctionalDescriptor;
 253:../Sources/USB.c ****    EndpointDescriptor                       endpointDescriptor3;
 254:../Sources/USB.c ****    InterfaceDescriptor                      interfaceDescriptor2;
 255:../Sources/USB.c ****    EndpointDescriptor                       endpointDescriptor4;
 256:../Sources/USB.c ****    EndpointDescriptor                       endpointDescriptor5;
 257:../Sources/USB.c **** #endif   
 258:../Sources/USB.c **** } otherDescriptors =     
 259:../Sources/USB.c **** {
 260:../Sources/USB.c ****    { // configDescriptor
 261:../Sources/USB.c ****       sizeof(ConfigurationDescriptor),                // bLength
 262:../Sources/USB.c ****       DT_CONFIGURATION,                               // bDescriptorType
 263:../Sources/USB.c ****       CONST_NATIVE_TO_LE16(sizeof(otherDescriptors)), // wTotalLength
 264:../Sources/USB.c **** #if (HW_CAPABILITY&CAP_CDC)
 265:../Sources/USB.c ****       3,                                              // bNumInterfaces
 266:../Sources/USB.c **** #else   
 267:../Sources/USB.c ****       1,                                              // bNumInterfaces
 268:../Sources/USB.c **** #endif
 269:../Sources/USB.c ****       1,                                              // bConfigurationValue
 270:../Sources/USB.c ****       0,                                              // iConfiguration
 271:../Sources/USB.c ****       0x80,                                           // bmAttributes        = Bus powered, no wake
 272:../Sources/USB.c ****       USBMilliamps(500)                               // MaxPower
 273:../Sources/USB.c ****    },
 274:../Sources/USB.c ****    { // interfaceDescriptor0
 275:../Sources/USB.c ****       sizeof(InterfaceDescriptor),  // bLength
 276:../Sources/USB.c ****       DT_INTERFACE,                 // bDescriptorType
 277:../Sources/USB.c ****       0,                            // bInterfaceNumber
 278:../Sources/USB.c ****       0,                            // bAlternateSetting
 279:../Sources/USB.c ****       2,                            // bNumEndpoints
 280:../Sources/USB.c ****       0xFF,                         // bInterfaceClass      = (Vendor specific)
 281:../Sources/USB.c ****       0xFF,                         // bInterfaceSubClass   = (Vendor specific)
 282:../Sources/USB.c ****       0xFF,                         // bInterfaceProtocol   = (Vendor specific)
 283:../Sources/USB.c ****       5                             // iInterface desc
 284:../Sources/USB.c ****    },
 285:../Sources/USB.c ****    { // endpointDescriptor1 - #01,OUT,Bulk
 286:../Sources/USB.c ****      sizeof(EndpointDescriptor),          // bLength
 287:../Sources/USB.c ****      DT_ENDPOINT,                         // bDescriptorType
 288:../Sources/USB.c ****      EP_OUT|1,                            // bEndpointAddress
 289:../Sources/USB.c ****      ATTR_BULK,                           // bmAttributes
 290:../Sources/USB.c ****      CONST_NATIVE_TO_LE16(ENDPT1MAXSIZE), // wMaxPacketSize
 291:../Sources/USB.c ****      USBMilliseconds(1)                   // bInterval         = -
 292:../Sources/USB.c ****    },
 293:../Sources/USB.c ****    { // endpointDescriptor2 - #82,IN, BULK
 294:../Sources/USB.c ****      sizeof(EndpointDescriptor),          // bLength
 295:../Sources/USB.c ****      DT_ENDPOINT,                         // bDescriptorType
 296:../Sources/USB.c ****      EP_IN|2,                             // bEndpointAddress
 297:../Sources/USB.c ****      ATTR_BULK,                           // bmAttributes
 298:../Sources/USB.c ****      CONST_NATIVE_TO_LE16(ENDPT2MAXSIZE), // wMaxPacketSize
 299:../Sources/USB.c ****      USBMilliseconds(1)                   // bInterval         = -
 300:../Sources/USB.c ****    },
 301:../Sources/USB.c **** #if (HW_CAPABILITY&CAP_CDC)
 302:../Sources/USB.c ****    { // interfaceAssociationDescriptorCDC
 303:../Sources/USB.c ****        sizeof(InterfaceAssociationDescriptor), // bLength
 304:../Sources/USB.c ****        DT_INTERFACEASSOCIATION,                // bDescriptorType
 305:../Sources/USB.c ****        1,                                      // bFirstInterface
 306:../Sources/USB.c ****        2,                                      // bInterfaceCount
 307:../Sources/USB.c ****        0x02,                                   // bFunctionClass    = bInterfaceClass    = CDC Cont
 308:../Sources/USB.c ****        0x02,                                   // bFunctionSubClass = bInterfaceSubClass = Abstract
 309:../Sources/USB.c ****        0x01,                                   // bFunctionProtocol = bDeviceProtocol    = AT Comma
 310:../Sources/USB.c ****        6,                                      // iFunction = ""
 311:../Sources/USB.c ****    },
 312:../Sources/USB.c ****    { // interfaceDescriptor1
 313:../Sources/USB.c ****       sizeof(InterfaceDescriptor),  // bLength
 314:../Sources/USB.c ****       DT_INTERFACE,                 // bDescriptorType
 315:../Sources/USB.c ****       1,                            // bInterfaceNumber
 316:../Sources/USB.c ****       0,                            // bAlternateSetting
 317:../Sources/USB.c ****       1,                            // bNumEndpoints
 318:../Sources/USB.c ****       0x02,                         // bInterfaceClass      = CDC Control
 319:../Sources/USB.c ****       0x02,                         // bInterfaceSubClass   = Abstract Control Model
 320:../Sources/USB.c ****       0x01,                         // bInterfaceProtocol   = AT CommandL V.250
 321:../Sources/USB.c ****       7                             // iInterface desc
 322:../Sources/USB.c ****    },
 323:../Sources/USB.c ****    { // headerFunctionalDescriptor
 324:../Sources/USB.c ****       sizeof(CDCHeaderFunctionalDescriptor),  // bFunctionalLength
 325:../Sources/USB.c ****       CS_INTERFACE,                           // bDescriptorType
 326:../Sources/USB.c ****       DST_HEADER,                             // bDescriptorSubtype
 327:../Sources/USB.c ****       CONST_NATIVE_TO_LE16(0x0110),           // bcdCDC
 328:../Sources/USB.c ****    },
 329:../Sources/USB.c ****    { // callManagementDescriptor
 330:../Sources/USB.c ****       sizeof(CDCCallManagementFunctionalDescriptor), // bFunctionalLength
 331:../Sources/USB.c ****       CS_INTERFACE,                                  // bDescriptorType
 332:../Sources/USB.c ****       DST_CALL_MANAGEMENT,                           // bDescriptorSubtype
 333:../Sources/USB.c ****       1,                                             // bmCapabilities
 334:../Sources/USB.c ****       1,                                             // bDataInterface
 335:../Sources/USB.c ****    },
 336:../Sources/USB.c ****    { // abstractControlManagementFunctionalDescriptor
 337:../Sources/USB.c ****       sizeof(CDCAbstractControlManagementDescriptor), // bFunctionalLength
 338:../Sources/USB.c ****       CS_INTERFACE,                                   // bDescriptorType
 339:../Sources/USB.c ****       DST_ABSTRACT_CONTROL_MANAGEMENT,                // bDescriptorSubtype
 340:../Sources/USB.c ****       0x06,                                           // bmCapabilities
 341:../Sources/USB.c ****    },
 342:../Sources/USB.c ****    { // unionFunctionalDescriptor
 343:../Sources/USB.c ****       sizeof(CDCUnionFunctionalDescriptor),           // bFunctionalLength
 344:../Sources/USB.c ****       CS_INTERFACE,                                   // bDescriptorType
 345:../Sources/USB.c ****       DST_UNION_MANAGEMENT,                           // bDescriptorSubtype
 346:../Sources/USB.c ****       1,                                              // bmControlInterface
 347:../Sources/USB.c ****       {2},                                            // bSubordinateInterface0
 348:../Sources/USB.c ****    },
 349:../Sources/USB.c ****    { // endpointDescriptor3 - #83,IN,interrupt
 350:../Sources/USB.c ****      sizeof(EndpointDescriptor),          // bLength
 351:../Sources/USB.c ****      DT_ENDPOINT,                         // bDescriptorType
 352:../Sources/USB.c ****      EP_IN|3,                             // bEndpointAddress
 353:../Sources/USB.c ****      ATTR_INTERRUPT,                      // bmAttributes
 354:../Sources/USB.c ****      CONST_NATIVE_TO_LE16(ENDPT3MAXSIZE), // wMaxPacketSize
 355:../Sources/USB.c ****      USBMilliseconds(255)                 // bInterval
 356:../Sources/USB.c ****    },
 357:../Sources/USB.c ****    { // interfaceDescriptor2
 358:../Sources/USB.c ****       sizeof(InterfaceDescriptor),  // bLength
 359:../Sources/USB.c ****       DT_INTERFACE,                 // bDescriptorType
 360:../Sources/USB.c ****       2,                            // bInterfaceNumber
 361:../Sources/USB.c ****       0,                            // bAlternateSetting
 362:../Sources/USB.c ****       2,                            // bNumEndpoints
 363:../Sources/USB.c ****       0x0A,                         // bInterfaceClass      = CDC DATA
 364:../Sources/USB.c ****       0x00,                         // bInterfaceSubClass   = - 
 365:../Sources/USB.c ****       0x00,                         // bInterfaceProtocol   = -
 366:../Sources/USB.c ****       8                             // iInterface desc
 367:../Sources/USB.c ****    },
 368:../Sources/USB.c ****    { // endpointDescriptor4 - #4,OUT,bulk
 369:../Sources/USB.c ****      sizeof(EndpointDescriptor),          // bLength
 370:../Sources/USB.c ****      DT_ENDPOINT,                         // bDescriptorType
 371:../Sources/USB.c ****      EP_OUT|4,                            // bEndpointAddress
 372:../Sources/USB.c ****      ATTR_BULK,                           // bmAttributes
 373:../Sources/USB.c ****      CONST_NATIVE_TO_LE16(ENDPT4MAXSIZE), // wMaxPacketSize
 374:../Sources/USB.c ****      USBMilliseconds(1)                   // bInterval         = -
 375:../Sources/USB.c ****    },
 376:../Sources/USB.c ****    { // endpointDescriptor5 - #85,IN,bulk
 377:../Sources/USB.c ****      sizeof(EndpointDescriptor),            // bLength
 378:../Sources/USB.c ****      DT_ENDPOINT,                           // bDescriptorType
 379:../Sources/USB.c ****      EP_IN|5,                               // bEndpointAddress
 380:../Sources/USB.c ****      ATTR_BULK,                             // bmAttributes
 381:../Sources/USB.c ****      CONST_NATIVE_TO_LE16(2*ENDPT5MAXSIZE), // wMaxPacketSize (x2 so all pkts are terminating (shor
 382:../Sources/USB.c ****      USBMilliseconds(1)                     // bInterval         = -
 383:../Sources/USB.c ****    },
 384:../Sources/USB.c **** #endif   
 385:../Sources/USB.c **** };
 386:../Sources/USB.c **** 
 387:../Sources/USB.c **** static const MS_CompatibleIdFeatureDescriptor msCompatibleIdFeatureDescriptor = {
 388:../Sources/USB.c ****     /* lLength;             */  CONST_NATIVE_TO_LE32((uint32_t)sizeof(MS_CompatibleIdFeatureDescrip
 389:../Sources/USB.c ****     /* wVersion;            */  CONST_NATIVE_TO_LE16(0x0100),
 390:../Sources/USB.c ****     /* wIndex;              */  CONST_NATIVE_TO_LE16(0x0004),
 391:../Sources/USB.c ****     /* bnumSections;        */  1,
 392:../Sources/USB.c ****     /* bReserved1[7];       */  {0},
 393:../Sources/USB.c ****     /* bInterfaceNum;       */  0,
 394:../Sources/USB.c ****     /* bReserved2;          */  1,
 395:../Sources/USB.c ****     /* bCompatibleId[8];    */  "WINUSB\0",
 396:../Sources/USB.c ****     /* bSubCompatibleId[8]; */  {0},
 397:../Sources/USB.c ****     /* bReserved3[6];       */  {0}  
 398:../Sources/USB.c **** };
 399:../Sources/USB.c **** 
 400:../Sources/USB.c **** static const MS_PropertiesFeatureDescriptor msPropertiesFeatureDescriptor = {
 401:../Sources/USB.c ****     // DeviceGUID = "{93FEBD51-6000-4E7E-A20E-A80FC78C7EA1}"
 402:../Sources/USB.c ****     /* U32 lLength;         */ CONST_NATIVE_TO_LE32((uint32_t)sizeof(MS_PropertiesFeatureDescriptor
 403:../Sources/USB.c ****     /* U16 wVersion;        */ CONST_NATIVE_TO_LE16(0x0100),
 404:../Sources/USB.c ****     /* U16 wIndex;          */ CONST_NATIVE_TO_LE16(0x0005),
 405:../Sources/USB.c ****     /* U16 bnumSections;    */ CONST_NATIVE_TO_LE16(0x0001),
 406:../Sources/USB.c ****     /* U32 lPropertySize;   */ CONST_NATIVE_TO_LE32(132UL),
 407:../Sources/USB.c ****     /* U32 ldataType;       */ CONST_NATIVE_TO_LE32(1UL),
 408:../Sources/USB.c ****     /* U16 wNameLength;     */ CONST_NATIVE_TO_LE16(40),
 409:../Sources/USB.c ****     /* U8  bName[40];       */ "D\0e\0v\0i\0c\0e\0I\0n\0t\0e\0r\0f\0a\0c\0e\0G\0U\0I\0D\0\0",
 410:../Sources/USB.c ****     /* U32 wPropertyLength; */ CONST_NATIVE_TO_LE32(78UL),
 411:../Sources/USB.c ****     // U8  bData[78];       {93FEBD51-6000-4E7E-A20E-A80FC78C7EA1}
 412:../Sources/USB.c ****     // {'{','5','8','d','0','7','2','1','0','-','2','7','c','1','-','1','1','d','d','-','b','d','0'
 413:../Sources/USB.c ****                                "{\000"  
 414:../Sources/USB.c ****                                "5\0008\000d\0000\0007\0002\0001\0000\000"
 415:../Sources/USB.c ****                                "-\0002\0007\000C\0001\000"
 416:../Sources/USB.c ****                                "-\0001\0001\000D\000D\000"
 417:../Sources/USB.c ****                                "-\000B\000D\0000\000B\000"
 418:../Sources/USB.c ****                                "-\0000\0008\0000\0000\0002\0000\0000\000C\0009\000A\0006\0006\000"
 419:../Sources/USB.c ****                                "}\000"
 420:../Sources/USB.c **** }; 
 421:../Sources/USB.c **** 
 422:../Sources/USB.c **** #define VENDOR_CODE 0x30
 423:../Sources/USB.c **** static const U8 OS_StringDescriptor[] = {18, DT_STRING, 'M',0,'S',0,'F',0,'T',0,'1',0,'0',0,'0',0,V
 424:../Sources/USB.c **** 
 425:../Sources/USB.c **** static const uint8_t sd0[] = {4,  DT_STRING, 0x09, 0x0C};  // Language IDs
 426:../Sources/USB.c **** static const uint8_t sd1[] = "UNL Robotics";                        // Manufacturer
 427:../Sources/USB.c **** static const uint8_t sd2[] = "BLDC Motor controller";           // Product Description
 428:../Sources/USB.c **** static const uint8_t sd3[] = "BLDC000001";                    // Serial Number
 429:../Sources/USB.c **** static const uint8_t sd4[] = "BLDC Motor";        // Interface Association #1
 430:../Sources/USB.c **** static const uint8_t sd5[] = "BLDC Motor WinUSB";        // Interface #0
 431:../Sources/USB.c **** static const uint8_t sd6[] = "BLDC CDC Interface";        // Interface Association #2
 432:../Sources/USB.c **** static const uint8_t sd7[] = "Interface 1 - CDC Control";  // Interface #1
 433:../Sources/USB.c **** static const uint8_t sd8[] = "Interface 2 - CDC Data";     // Interface #2
 434:../Sources/USB.c **** 
 435:../Sources/USB.c **** static const uint8_t *const stringDescriptors[] = {sd0, sd1, sd2, sd3, sd4, sd5, sd6, sd7, sd8};
 436:../Sources/USB.c **** 
 437:../Sources/USB.c **** //===============================================================================
 438:../Sources/USB.c **** // Device Status
 439:../Sources/USB.c **** //       
 440:../Sources/USB.c **** typedef struct {
 441:../Sources/USB.c ****    int selfPowered  : 1;    //!< Device is self-powered
 442:../Sources/USB.c ****    int remoteWakeup : 1;    //!< Supports remote wakeup
 443:../Sources/USB.c ****    int portTest     : 1;    //!< Port test
 444:../Sources/USB.c ****    int res1         : 5;    //!< Reserved
 445:../Sources/USB.c ****    int res2         : 8;    //!< Reserved
 446:../Sources/USB.c **** } DeviceStatus; 
 447:../Sources/USB.c **** 
 448:../Sources/USB.c **** //! USB device states
 449:../Sources/USB.c **** typedef enum { USBpowered, USBattached, USBdefault, USBaddressed,
 450:../Sources/USB.c ****                USBconfigured, USBsuspended } USBstateType;
 451:../Sources/USB.c **** 
 452:../Sources/USB.c **** struct {
 453:../Sources/USB.c ****    USBstateType   state:8;
 454:../Sources/USB.c ****    uint8_t        configuration;
 455:../Sources/USB.c ****    uint8_t        interfaceAltSetting;
 456:../Sources/USB.c ****    DeviceStatus   status;
 457:../Sources/USB.c ****    uint8_t        newUSBAddress;
 458:../Sources/USB.c **** } deviceState = {USBattached, 0, 0, {0,0,0,0,0}, 0};  //!< USB device state information 
 459:../Sources/USB.c **** 
 460:../Sources/USB.c **** //===============================================================================
 461:../Sources/USB.c **** //! Endpoint Status
 462:../Sources/USB.c **** //!       
 463:../Sources/USB.c **** typedef struct {
 464:../Sources/USB.c ****    int stall  : 1;   //!< Endpoint is stalled
 465:../Sources/USB.c ****    int res1   : 7;   //!< Reserved
 466:../Sources/USB.c ****    int res2   : 8;   //!< Reserved
 467:../Sources/USB.c **** } EPStatus; //!< Endpoint status un USB format
 468:../Sources/USB.c **** 
 469:../Sources/USB.c **** // Endpoint state values
 470:../Sources/USB.c **** typedef enum { 
 471:../Sources/USB.c ****    EPIdle = 0,       //!< Idle (Tx complete)
 472:../Sources/USB.c ****    EPDataIn,         //!< Doing a sequence of IN packets (until data count <= EPSIZE)
 473:../Sources/USB.c ****    EPDataOut,        //!< Doing a sequence of OUT packets (until data count == 0)
 474:../Sources/USB.c ****    EPLastIn,         //!< Doing the last IN packet
 475:../Sources/USB.c ****    EPStatusIn,       //!< Doing an IN packet as a status handshake
 476:../Sources/USB.c ****    EPStatusOut,      //!< Doing an OUT packet as a status handshake
 477:../Sources/USB.c ****    EPThrottle,       //!< Doing OUT packets but no buffers available (NAKed)
 478:../Sources/USB.c ****    EPStall,          //!< Endpoint is stalled
 479:../Sources/USB.c ****    EPComplete,       //!< Used for command protocol - new command available
 480:../Sources/USB.c **** } EPModes;
 481:../Sources/USB.c **** 
 482:../Sources/USB.c **** //! Endpoint information
 483:../Sources/USB.c **** typedef struct {
 484:../Sources/USB.c ****    uint8_t* volatile       dataPtr;               //!< Pointer to data buffer
 485:../Sources/USB.c ****    uint8_t  volatile       dataRemaining;         //!< Count of remaining bytes to Rx/Tx
 486:../Sources/USB.c ****    uint8_t  volatile       dataCount;             //!< Count of bytes Rx/Tx so far
 487:../Sources/USB.c ****    uint8_t  volatile       shortInTransaction:1;  //!< Indicates that the IN transaction is undersi
 488:../Sources/USB.c ****    void   (*volatile callback)( void );   //!< Callback used on completion of pkt reception
 489:../Sources/USB.c **** } EPState;
 490:../Sources/USB.c **** 
 491:../Sources/USB.c **** //! Endpoint hardware state
 492:../Sources/USB.c **** typedef volatile struct {
 493:../Sources/USB.c ****    uint8_t   data0_1:1;  //!< Data 0/1 toggle state
 494:../Sources/USB.c ****    uint8_t   txOdd:1;    //!< Odd/Even tx buffer
 495:../Sources/USB.c ****    uint8_t   rxOdd:1;    //!< Odd/Even rx buffer
 496:../Sources/USB.c ****    EPModes   state:5;    //!< Endpoint state
 497:../Sources/USB.c **** } EPHardwareState;
 498:../Sources/USB.c **** 
 499:../Sources/USB.c **** // Used to flag USB system config change etc.
 500:../Sources/USB.c **** static volatile uint8_t reInit;
 501:../Sources/USB.c **** 
 502:../Sources/USB.c **** static EPState ep0State = {NULL, 0, 0, 0, NULL};
 503:../Sources/USB.c **** static EPState ep1State = {NULL, 0, 0, 0, NULL};
 504:../Sources/USB.c **** static EPState ep2State = {NULL, 0, 0, 0, NULL};
 505:../Sources/USB.c **** 
 506:../Sources/USB.c **** static EPHardwareState epHardwareState[NUMBER_OF_EPS] = {{0}};
 507:../Sources/USB.c **** 
 508:../Sources/USB.c **** //! Structure representing USB activity
 509:../Sources/USB.c **** typedef union {
 510:../Sources/USB.c ****    volatile uint8_t  byte;    //!< Allows access as byte (zero=>no activity, non-zero=>activity)
 511:../Sources/USB.c ****    volatile struct {
 512:../Sources/USB.c ****       int bdmActive:1;            //!< Any activity
 513:../Sources/USB.c ****       int serialOutActive:1;      //!< Serial out active 
 514:../Sources/USB.c ****       int serialInActive:1;       //!< Serial in active
 515:../Sources/USB.c ****    } flags;                 //!< Overall flags
 516:../Sources/USB.c **** } ActivityType ;
 517:../Sources/USB.c **** static ActivityType  usbActivityFlag;
 518:../Sources/USB.c **** 
 519:../Sources/USB.c **** //======================================================================
 520:../Sources/USB.c **** // Buffer for EP0 Setup packet (copied from USB RAM)
 521:../Sources/USB.c **** static SetupPacket ep0SetupBuffer;   //!< Buffer for EP0 Setup packet (copied from USB RAM)
 522:../Sources/USB.c **** 
 523:../Sources/USB.c **** //======================================================================
 524:../Sources/USB.c **** //! Initialise the endpoint buffer pointers once only
 525:../Sources/USB.c **** //!
 526:../Sources/USB.c **** static void initEndpointBuffers(void) {
 347              		.loc 1 526 0
 348              		.cfi_startproc
 349              		@ args = 0, pretend = 0, frame = 0
 350              		@ frame_needed = 1, uses_anonymous_args = 0
 351 0000 80B5     		push	{r7, lr}
 352              	.LCFI6:
 353              		.cfi_def_cfa_offset 8
 354              		.cfi_offset 7, -8
 355              		.cfi_offset 14, -4
 356 0002 00AF     		add	r7, sp, #0
 357              	.LCFI7:
 358              		.cfi_def_cfa_register 7
 527:../Sources/USB.c ****    // EP0 Control I/O
 528:../Sources/USB.c ****    endPointBdts[0].txEven.addr = nativeToLe32((uint32_t)ep0InDataBuffer);
 359              		.loc 1 528 0
 360 0004 40F20003 		movw	r3, #:lower16:ep0InDataBuffer
 361 0008 C0F20003 		movt	r3, #:upper16:ep0InDataBuffer
 362 000c 1846     		mov	r0, r3
 363 000e FFF7FEFF 		bl	noChange32
 364 0012 0246     		mov	r2, r0
 365 0014 40F20003 		movw	r3, #:lower16:endPointBdts
 366 0018 C0F20003 		movt	r3, #:upper16:endPointBdts
 367 001c 5A61     		str	r2, [r3, #20]
 529:../Sources/USB.c ****    endPointBdts[0].txOdd.addr  = nativeToLe32((uint32_t)ep0InDataBuffer);
 368              		.loc 1 529 0
 369 001e 40F20003 		movw	r3, #:lower16:ep0InDataBuffer
 370 0022 C0F20003 		movt	r3, #:upper16:ep0InDataBuffer
 371 0026 1846     		mov	r0, r3
 372 0028 FFF7FEFF 		bl	noChange32
 373 002c 0246     		mov	r2, r0
 374 002e 40F20003 		movw	r3, #:lower16:endPointBdts
 375 0032 C0F20003 		movt	r3, #:upper16:endPointBdts
 376 0036 DA61     		str	r2, [r3, #28]
 530:../Sources/USB.c ****    endPointBdts[0].rxEven.addr = nativeToLe32((uint32_t)ep0OutDataBuffer);
 377              		.loc 1 530 0
 378 0038 40F20003 		movw	r3, #:lower16:ep0OutDataBuffer
 379 003c C0F20003 		movt	r3, #:upper16:ep0OutDataBuffer
 380 0040 1846     		mov	r0, r3
 381 0042 FFF7FEFF 		bl	noChange32
 382 0046 0246     		mov	r2, r0
 383 0048 40F20003 		movw	r3, #:lower16:endPointBdts
 384 004c C0F20003 		movt	r3, #:upper16:endPointBdts
 385 0050 5A60     		str	r2, [r3, #4]
 531:../Sources/USB.c ****    endPointBdts[0].rxOdd.addr  = nativeToLe32((uint32_t)ep0OutDataBuffer);
 386              		.loc 1 531 0
 387 0052 40F20003 		movw	r3, #:lower16:ep0OutDataBuffer
 388 0056 C0F20003 		movt	r3, #:upper16:ep0OutDataBuffer
 389 005a 1846     		mov	r0, r3
 390 005c FFF7FEFF 		bl	noChange32
 391 0060 0246     		mov	r2, r0
 392 0062 40F20003 		movw	r3, #:lower16:endPointBdts
 393 0066 C0F20003 		movt	r3, #:upper16:endPointBdts
 394 006a DA60     		str	r2, [r3, #12]
 532:../Sources/USB.c ****    // EP1 USBDM out
 533:../Sources/USB.c ****    endPointBdts[1].rxEven.addr = nativeToLe32((uint32_t)ep1DataBuffer);
 395              		.loc 1 533 0
 396 006c 40F20003 		movw	r3, #:lower16:ep1DataBuffer
 397 0070 C0F20003 		movt	r3, #:upper16:ep1DataBuffer
 398 0074 1846     		mov	r0, r3
 399 0076 FFF7FEFF 		bl	noChange32
 400 007a 0246     		mov	r2, r0
 401 007c 40F20003 		movw	r3, #:lower16:endPointBdts
 402 0080 C0F20003 		movt	r3, #:upper16:endPointBdts
 403 0084 5A62     		str	r2, [r3, #36]
 534:../Sources/USB.c ****    endPointBdts[1].rxOdd.addr  = nativeToLe32((uint32_t)ep1DataBuffer);
 404              		.loc 1 534 0
 405 0086 40F20003 		movw	r3, #:lower16:ep1DataBuffer
 406 008a C0F20003 		movt	r3, #:upper16:ep1DataBuffer
 407 008e 1846     		mov	r0, r3
 408 0090 FFF7FEFF 		bl	noChange32
 409 0094 0246     		mov	r2, r0
 410 0096 40F20003 		movw	r3, #:lower16:endPointBdts
 411 009a C0F20003 		movt	r3, #:upper16:endPointBdts
 412 009e DA62     		str	r2, [r3, #44]
 535:../Sources/USB.c ****    // EP2 USBDM in
 536:../Sources/USB.c ****    endPointBdts[2].txEven.addr = nativeToLe32((uint32_t)ep2DataBuffer);
 413              		.loc 1 536 0
 414 00a0 40F20003 		movw	r3, #:lower16:ep2DataBuffer
 415 00a4 C0F20003 		movt	r3, #:upper16:ep2DataBuffer
 416 00a8 1846     		mov	r0, r3
 417 00aa FFF7FEFF 		bl	noChange32
 418 00ae 0246     		mov	r2, r0
 419 00b0 40F20003 		movw	r3, #:lower16:endPointBdts
 420 00b4 C0F20003 		movt	r3, #:upper16:endPointBdts
 421 00b8 5A65     		str	r2, [r3, #84]
 537:../Sources/USB.c ****    endPointBdts[2].txOdd.addr  = nativeToLe32((uint32_t)ep2DataBuffer);
 422              		.loc 1 537 0
 423 00ba 40F20003 		movw	r3, #:lower16:ep2DataBuffer
 424 00be C0F20003 		movt	r3, #:upper16:ep2DataBuffer
 425 00c2 1846     		mov	r0, r3
 426 00c4 FFF7FEFF 		bl	noChange32
 427 00c8 0246     		mov	r2, r0
 428 00ca 40F20003 		movw	r3, #:lower16:endPointBdts
 429 00ce C0F20003 		movt	r3, #:upper16:endPointBdts
 430 00d2 DA65     		str	r2, [r3, #92]
 538:../Sources/USB.c **** 
 539:../Sources/USB.c **** #if (HW_CAPABILITY&CAP_CDC)
 540:../Sources/USB.c ****    // EP3 CDC Control
 541:../Sources/USB.c ****    endPointBdts[3].rxEven.addr = nativeToLe32((uint32_t)ep3DataBuffer);
 542:../Sources/USB.c ****    endPointBdts[3].rxOdd.addr  = nativeToLe32((uint32_t)ep3DataBuffer);
 543:../Sources/USB.c ****    // EP4 CDC Rx (out)
 544:../Sources/USB.c ****    endPointBdts[4].rxEven.addr = nativeToLe32((uint32_t)ep4DataBuffer);
 545:../Sources/USB.c ****    endPointBdts[4].rxOdd.addr  = nativeToLe32((uint32_t)ep4DataBuffer);
 546:../Sources/USB.c ****    // EP5 CDC Tx (in)
 547:../Sources/USB.c ****    endPointBdts[5].txEven.addr = nativeToLe32((uint32_t)ep5DataBuffer0);
 548:../Sources/USB.c ****    endPointBdts[5].txOdd.addr  = nativeToLe32((uint32_t)ep5DataBuffer1);
 549:../Sources/USB.c ****    (void)cdc_setRxBuffer((char *)ep5DataBuffer0);
 550:../Sources/USB.c **** #endif
 551:../Sources/USB.c **** }
 431              		.loc 1 551 0
 432 00d4 80BD     		pop	{r7, pc}
 433              		.cfi_endproc
 434              	.LFE2:
 436 00d6 00BF     		.section	.text.ep0InitialiseBdtRx,"ax",%progbits
 437              		.align	2
 438              		.thumb
 439              		.thumb_func
 441              	ep0InitialiseBdtRx:
 442              	.LFB3:
 552:../Sources/USB.c **** 
 553:../Sources/USB.c **** static void epClearStall(uint8_t epNum);
 554:../Sources/USB.c **** 
 555:../Sources/USB.c **** //======================================================================
 556:../Sources/USB.c **** //! Configure the BDT for EP0 Out [Rx, device <- host, DATA0/1]
 557:../Sources/USB.c **** //!
 558:../Sources/USB.c **** //! @param data0_1 - value for USB Data toggle
 559:../Sources/USB.c **** //!
 560:../Sources/USB.c **** static void ep0InitialiseBdtRx( uint8_t data0_1 ) {
 443              		.loc 1 560 0
 444              		.cfi_startproc
 445              		@ args = 0, pretend = 0, frame = 16
 446              		@ frame_needed = 1, uses_anonymous_args = 0
 447              		@ link register save eliminated.
 448 0000 80B4     		push	{r7}
 449              	.LCFI8:
 450              		.cfi_def_cfa_offset 4
 451              		.cfi_offset 7, -4
 452 0002 85B0     		sub	sp, sp, #20
 453              	.LCFI9:
 454              		.cfi_def_cfa_offset 24
 455 0004 00AF     		add	r7, sp, #0
 456              	.LCFI10:
 457              		.cfi_def_cfa_register 7
 458 0006 0346     		mov	r3, r0
 459 0008 FB71     		strb	r3, [r7, #7]
 561:../Sources/USB.c ****    BdtEntry *bdt;
 562:../Sources/USB.c **** 
 563:../Sources/USB.c ****    // Set up to Rx packet
 564:../Sources/USB.c ****    bdt = epHardwareState[0].rxOdd?&endPointBdts[0].rxOdd:&endPointBdts[0].rxEven;
 460              		.loc 1 564 0
 461 000a 40F20003 		movw	r3, #:lower16:epHardwareState
 462 000e C0F20003 		movt	r3, #:upper16:epHardwareState
 463 0012 1B78     		ldrb	r3, [r3, #0]
 464 0014 DBB2     		uxtb	r3, r3
 465 0016 03F00403 		and	r3, r3, #4
 466 001a DBB2     		uxtb	r3, r3
 467 001c 002B     		cmp	r3, #0
 468 001e 01D0     		beq	.L7
 469              		.loc 1 564 0 is_stmt 0
 470 0020 0F4B     		ldr	r3, .L11
 471 0022 03E0     		b	.L8
 472              	.L7:
 473              		.loc 1 564 0
 474 0024 40F20003 		movw	r3, #:lower16:endPointBdts
 475 0028 C0F20003 		movt	r3, #:upper16:endPointBdts
 476              	.L8:
 477              		.loc 1 564 0
 478 002c FB60     		str	r3, [r7, #12]
 565:../Sources/USB.c ****    bdt->bc = ENDPT0MAXSIZE; // Always use ENDPT0MAXSIZE so can accept SETUP pkt
 479              		.loc 1 565 0 is_stmt 1
 480 002e FB68     		ldr	r3, [r7, #12]
 481 0030 5A88     		ldrh	r2, [r3, #2]	@ movhi
 482 0032 4FF00002 		mov	r2, #0
 483 0036 42F02002 		orr	r2, r2, #32
 484 003a 5A80     		strh	r2, [r3, #2]	@ movhi
 566:../Sources/USB.c ****    if (data0_1) 
 485              		.loc 1 566 0
 486 003c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 487 003e 002B     		cmp	r3, #0
 488 0040 04D0     		beq	.L9
 567:../Sources/USB.c ****       bdt->u.bits = BDTEntry_OWN_MASK|BDTEntry_DATA1_MASK|BDTEntry_DTS_MASK;
 489              		.loc 1 567 0
 490 0042 FB68     		ldr	r3, [r7, #12]
 491 0044 4FF0C802 		mov	r2, #200
 492 0048 1A70     		strb	r2, [r3, #0]
 493 004a 03E0     		b	.L6
 494              	.L9:
 568:../Sources/USB.c ****    else
 569:../Sources/USB.c ****       bdt->u.bits = BDTEntry_OWN_MASK|BDTEntry_DATA0_MASK|BDTEntry_DTS_MASK;
 495              		.loc 1 569 0
 496 004c FB68     		ldr	r3, [r7, #12]
 497 004e 4FF08802 		mov	r2, #136
 498 0052 1A70     		strb	r2, [r3, #0]
 499              	.L6:
 570:../Sources/USB.c **** }
 500              		.loc 1 570 0
 501 0054 07F11407 		add	r7, r7, #20
 502 0058 BD46     		mov	sp, r7
 503 005a 80BC     		pop	{r7}
 504 005c 7047     		bx	lr
 505              	.L12:
 506 005e 00BF     		.align	2
 507              	.L11:
 508 0060 08000000 		.word	endPointBdts+8
 509              		.cfi_endproc
 510              	.LFE3:
 512              		.section	.text.ep0SaveRxData,"ax",%progbits
 513              		.align	2
 514              		.thumb
 515              		.thumb_func
 517              	ep0SaveRxData:
 518              	.LFB4:
 571:../Sources/USB.c **** 
 572:../Sources/USB.c **** //=========================================================================
 573:../Sources/USB.c **** //! Save the data from an EP0 OUT pkt and advance ptrs etc.
 574:../Sources/USB.c **** //!
 575:../Sources/USB.c **** static uint8_t ep0SaveRxData( void ) {
 519              		.loc 1 575 0
 520              		.cfi_startproc
 521              		@ args = 0, pretend = 0, frame = 8
 522              		@ frame_needed = 1, uses_anonymous_args = 0
 523 0000 80B5     		push	{r7, lr}
 524              	.LCFI11:
 525              		.cfi_def_cfa_offset 8
 526              		.cfi_offset 7, -8
 527              		.cfi_offset 14, -4
 528 0002 82B0     		sub	sp, sp, #8
 529              	.LCFI12:
 530              		.cfi_def_cfa_offset 16
 531 0004 00AF     		add	r7, sp, #0
 532              	.LCFI13:
 533              		.cfi_def_cfa_register 7
 576:../Sources/USB.c ****    BdtEntry *bdt;
 577:../Sources/USB.c ****    uint16_t size;
 578:../Sources/USB.c **** 
 579:../Sources/USB.c ****    // Set up to Rx packet
 580:../Sources/USB.c ****    bdt = (!epHardwareState[0].rxOdd)?&endPointBdts[0].rxOdd:&endPointBdts[0].rxEven;
 534              		.loc 1 580 0
 535 0006 40F20003 		movw	r3, #:lower16:epHardwareState
 536 000a C0F20003 		movt	r3, #:upper16:epHardwareState
 537 000e 1B78     		ldrb	r3, [r3, #0]
 538 0010 DBB2     		uxtb	r3, r3
 539 0012 03F00403 		and	r3, r3, #4
 540 0016 DBB2     		uxtb	r3, r3
 541 0018 002B     		cmp	r3, #0
 542 001a 01D1     		bne	.L14
 543              		.loc 1 580 0 is_stmt 0
 544 001c 314B     		ldr	r3, .L20
 545 001e 03E0     		b	.L15
 546              	.L14:
 547              		.loc 1 580 0
 548 0020 40F20003 		movw	r3, #:lower16:endPointBdts
 549 0024 C0F20003 		movt	r3, #:upper16:endPointBdts
 550              	.L15:
 551              		.loc 1 580 0
 552 0028 3B60     		str	r3, [r7, #0]
 581:../Sources/USB.c ****    size = bdt->bc;
 553              		.loc 1 581 0 is_stmt 1
 554 002a 3B68     		ldr	r3, [r7, #0]
 555 002c 5B88     		ldrh	r3, [r3, #2]	@ movhi
 556 002e FB80     		strh	r3, [r7, #6]	@ movhi
 582:../Sources/USB.c ****    if (size > 0) {
 557              		.loc 1 582 0
 558 0030 FB88     		ldrh	r3, [r7, #6]
 559 0032 002B     		cmp	r3, #0
 560 0034 4ED0     		beq	.L16
 583:../Sources/USB.c ****       // Check if more data than requested - discard excess
 584:../Sources/USB.c ****       if (size > ep0State.dataRemaining)
 561              		.loc 1 584 0
 562 0036 40F20003 		movw	r3, #:lower16:ep0State
 563 003a C0F20003 		movt	r3, #:upper16:ep0State
 564 003e 1B79     		ldrb	r3, [r3, #4]
 565 0040 DBB2     		uxtb	r3, r3
 566 0042 FA88     		ldrh	r2, [r7, #6]
 567 0044 9A42     		cmp	r2, r3
 568 0046 06D9     		bls	.L17
 585:../Sources/USB.c ****          size = ep0State.dataRemaining;
 569              		.loc 1 585 0
 570 0048 40F20003 		movw	r3, #:lower16:ep0State
 571 004c C0F20003 		movt	r3, #:upper16:ep0State
 572 0050 1B79     		ldrb	r3, [r3, #4]
 573 0052 DBB2     		uxtb	r3, r3
 574 0054 FB80     		strh	r3, [r7, #6]	@ movhi
 575              	.L17:
 586:../Sources/USB.c ****       // Check if external buffer in use
 587:../Sources/USB.c ****       if (ep0State.dataPtr != NULL) {
 576              		.loc 1 587 0
 577 0056 40F20003 		movw	r3, #:lower16:ep0State
 578 005a C0F20003 		movt	r3, #:upper16:ep0State
 579 005e 1B68     		ldr	r3, [r3, #0]
 580 0060 002B     		cmp	r3, #0
 581 0062 19D0     		beq	.L18
 588:../Sources/USB.c ****          // Copy the data from the Rx buffer to external buffer
 589:../Sources/USB.c ****          ( void )memcpy(ep0State.dataPtr, ep0OutDataBuffer, size);
 582              		.loc 1 589 0
 583 0064 40F20003 		movw	r3, #:lower16:ep0State
 584 0068 C0F20003 		movt	r3, #:upper16:ep0State
 585 006c 1A68     		ldr	r2, [r3, #0]
 586 006e FB88     		ldrh	r3, [r7, #6]
 587 0070 1046     		mov	r0, r2
 588 0072 40F20001 		movw	r1, #:lower16:ep0OutDataBuffer
 589 0076 C0F20001 		movt	r1, #:upper16:ep0OutDataBuffer
 590 007a 1A46     		mov	r2, r3
 591 007c FFF7FEFF 		bl	memcpy
 590:../Sources/USB.c ****          ep0State.dataPtr    += size;   // Advance external buffer ptr
 592              		.loc 1 590 0
 593 0080 40F20003 		movw	r3, #:lower16:ep0State
 594 0084 C0F20003 		movt	r3, #:upper16:ep0State
 595 0088 1A68     		ldr	r2, [r3, #0]
 596 008a FB88     		ldrh	r3, [r7, #6]
 597 008c D218     		adds	r2, r2, r3
 598 008e 40F20003 		movw	r3, #:lower16:ep0State
 599 0092 C0F20003 		movt	r3, #:upper16:ep0State
 600 0096 1A60     		str	r2, [r3, #0]
 601              	.L18:
 591:../Sources/USB.c ****       }
 592:../Sources/USB.c ****       ep0State.dataRemaining -= size;   // Count down bytes to go
 602              		.loc 1 592 0
 603 0098 40F20003 		movw	r3, #:lower16:ep0State
 604 009c C0F20003 		movt	r3, #:upper16:ep0State
 605 00a0 1B79     		ldrb	r3, [r3, #4]
 606 00a2 DAB2     		uxtb	r2, r3
 607 00a4 FB88     		ldrh	r3, [r7, #6]	@ movhi
 608 00a6 DBB2     		uxtb	r3, r3
 609 00a8 D31A     		subs	r3, r2, r3
 610 00aa DAB2     		uxtb	r2, r3
 611 00ac 40F20003 		movw	r3, #:lower16:ep0State
 612 00b0 C0F20003 		movt	r3, #:upper16:ep0State
 613 00b4 1A71     		strb	r2, [r3, #4]
 593:../Sources/USB.c ****       ep0State.dataCount     += size;   // Count bytes so far
 614              		.loc 1 593 0
 615 00b6 40F20003 		movw	r3, #:lower16:ep0State
 616 00ba C0F20003 		movt	r3, #:upper16:ep0State
 617 00be 5B79     		ldrb	r3, [r3, #5]
 618 00c0 DAB2     		uxtb	r2, r3
 619 00c2 FB88     		ldrh	r3, [r7, #6]	@ movhi
 620 00c4 DBB2     		uxtb	r3, r3
 621 00c6 D318     		adds	r3, r2, r3
 622 00c8 DAB2     		uxtb	r2, r3
 623 00ca 40F20003 		movw	r3, #:lower16:ep0State
 624 00ce C0F20003 		movt	r3, #:upper16:ep0State
 625 00d2 5A71     		strb	r2, [r3, #5]
 626              	.L16:
 594:../Sources/USB.c ****       }
 595:../Sources/USB.c ****    return size;
 627              		.loc 1 595 0
 628 00d4 FB88     		ldrh	r3, [r7, #6]	@ movhi
 629 00d6 DBB2     		uxtb	r3, r3
 596:../Sources/USB.c **** }
 630              		.loc 1 596 0
 631 00d8 1846     		mov	r0, r3
 632 00da 07F10807 		add	r7, r7, #8
 633 00de BD46     		mov	sp, r7
 634 00e0 80BD     		pop	{r7, pc}
 635              	.L21:
 636 00e2 00BF     		.align	2
 637              	.L20:
 638 00e4 08000000 		.word	endPointBdts+8
 639              		.cfi_endproc
 640              	.LFE4:
 642              		.section	.text.ep0ConfigureSetupTransaction,"ax",%progbits
 643              		.align	2
 644              		.thumb
 645              		.thumb_func
 647              	ep0ConfigureSetupTransaction:
 648              	.LFB5:
 597:../Sources/USB.c **** 
 598:../Sources/USB.c **** #if (HW_CAPABILITY&CAP_CDC)   
 599:../Sources/USB.c **** //======================================================================
 600:../Sources/USB.c **** /*! Configure EP0 for an OUT transaction [Rx, device <- host, DATA0/1]
 601:../Sources/USB.c ****  *
 602:../Sources/USB.c ****  * @param bufSize - Size of data to transfer
 603:../Sources/USB.c ****  * @param bufPtr  - Buffer for data, may be NULL - Useful when:
 604:../Sources/USB.c ****  *                - The transfer is < ENDPT0MAXSIZE
 605:../Sources/USB.c ****  *                - Data may be used directly from ep0OutDataBuffer
 606:../Sources/USB.c ****  *                - So no additional buffer is needed
 607:../Sources/USB.c ****  * @param data0_1 - Initial DATA0/DATA1 toggle value
 608:../Sources/USB.c ****  */
 609:../Sources/USB.c **** static void ep0StartRxTransaction( uint8_t bufSize, uint8_t *bufPtr, uint8_t data0_1 ) {
 610:../Sources/USB.c **** 
 611:../Sources/USB.c ****    ep0State.dataRemaining     = bufSize; // Total bytes for Rx
 612:../Sources/USB.c ****    ep0State.dataCount         = 0;       // Reset count of bytes so far
 613:../Sources/USB.c ****    ep0State.dataPtr           = bufPtr;  // Where to (eventually) place data
 614:../Sources/USB.c ****    epHardwareState[0].data0_1 = data0_1; // Initial data toggle
 615:../Sources/USB.c ****    
 616:../Sources/USB.c ****    if (bufSize == 0) 
 617:../Sources/USB.c ****       epHardwareState[0].state = EPStatusOut;  // Assume status handshake
 618:../Sources/USB.c ****    else
 619:../Sources/USB.c ****       epHardwareState[0].state = EPDataOut;    // Assume first of several data pkts
 620:../Sources/USB.c **** 
 621:../Sources/USB.c ****    ep0InitialiseBdtRx(data0_1); // Configure the BDT for transfer
 622:../Sources/USB.c **** }
 623:../Sources/USB.c **** #endif
 624:../Sources/USB.c **** 
 625:../Sources/USB.c **** //================================================================================
 626:../Sources/USB.c **** // Configure EP0-out for a SETUP transaction [Rx, device<-host, DATA0]
 627:../Sources/USB.c **** // Endpoint state is changed to EPIdle
 628:../Sources/USB.c **** //
 629:../Sources/USB.c **** static void ep0ConfigureSetupTransaction( void ) {
 649              		.loc 1 629 0
 650              		.cfi_startproc
 651              		@ args = 0, pretend = 0, frame = 0
 652              		@ frame_needed = 1, uses_anonymous_args = 0
 653 0000 80B5     		push	{r7, lr}
 654              	.LCFI14:
 655              		.cfi_def_cfa_offset 8
 656              		.cfi_offset 7, -8
 657              		.cfi_offset 14, -4
 658 0002 00AF     		add	r7, sp, #0
 659              	.LCFI15:
 660              		.cfi_def_cfa_register 7
 630:../Sources/USB.c ****     // Set up EP0-RX to Rx SETUP packets
 631:../Sources/USB.c ****     ep0InitialiseBdtRx(DATA0); // ToDo v4.7 changed to DATA1
 661              		.loc 1 631 0
 662 0004 4FF00000 		mov	r0, #0
 663 0008 FFF7FEFF 		bl	ep0InitialiseBdtRx
 632:../Sources/USB.c ****     epHardwareState[0].state = EPIdle;
 664              		.loc 1 632 0
 665 000c 40F20003 		movw	r3, #:lower16:epHardwareState
 666 0010 C0F20003 		movt	r3, #:upper16:epHardwareState
 667 0014 1A78     		ldrb	r2, [r3, #0]
 668 0016 6FF3C702 		bfc	r2, #3, #5
 669 001a 1A70     		strb	r2, [r3, #0]
 633:../Sources/USB.c **** }
 670              		.loc 1 633 0
 671 001c 80BD     		pop	{r7, pc}
 672              		.cfi_endproc
 673              	.LFE5:
 675 001e 00BF     		.section	.text.ep0EnsureReadyForSetupTransaction,"ax",%progbits
 676              		.align	2
 677              		.thumb
 678              		.thumb_func
 680              	ep0EnsureReadyForSetupTransaction:
 681              	.LFB6:
 634:../Sources/USB.c **** 
 635:../Sources/USB.c **** //================================================================================
 636:../Sources/USB.c **** // Configure EP0-RX for a SETUP transaction [Rx, device<-host, DATA0]
 637:../Sources/USB.c **** // Only done if endpoint is not already configured for some other OUT transaction
 638:../Sources/USB.c **** // Endpoint state unchanged.
 639:../Sources/USB.c **** //
 640:../Sources/USB.c **** static void ep0EnsureReadyForSetupTransaction( void ) {
 682              		.loc 1 640 0
 683              		.cfi_startproc
 684              		@ args = 0, pretend = 0, frame = 8
 685              		@ frame_needed = 1, uses_anonymous_args = 0
 686 0000 80B5     		push	{r7, lr}
 687              	.LCFI16:
 688              		.cfi_def_cfa_offset 8
 689              		.cfi_offset 7, -8
 690              		.cfi_offset 14, -4
 691 0002 82B0     		sub	sp, sp, #8
 692              	.LCFI17:
 693              		.cfi_def_cfa_offset 16
 694 0004 00AF     		add	r7, sp, #0
 695              	.LCFI18:
 696              		.cfi_def_cfa_register 7
 641:../Sources/USB.c ****    EPModes currentEp0State = epHardwareState[0].state;
 697              		.loc 1 641 0
 698 0006 40F20003 		movw	r3, #:lower16:epHardwareState
 699 000a C0F20003 		movt	r3, #:upper16:epHardwareState
 700 000e 1B78     		ldrb	r3, [r3, #0]
 701 0010 C3F3C403 		ubfx	r3, r3, #3, #5
 702 0014 DBB2     		uxtb	r3, r3
 703 0016 FB71     		strb	r3, [r7, #7]
 642:../Sources/USB.c ****     
 643:../Sources/USB.c ****    switch (currentEp0State) {
 704              		.loc 1 643 0
 705 0018 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 706 001a 022B     		cmp	r3, #2
 707 001c 11D0     		beq	.L27
 708 001e 052B     		cmp	r3, #5
 709 0020 0FD0     		beq	.L27
 644:../Sources/USB.c ****       case EPDataOut:        // Doing a sequence of OUT packets (until data count <= EPSIZE)
 645:../Sources/USB.c ****       case EPStatusOut:      // Doing an OUT packet as a status handshake
 646:../Sources/USB.c ****          // EP0-OUT is already set up for an OUT pkt
 647:../Sources/USB.c ****          break;
 648:../Sources/USB.c **** 
 649:../Sources/USB.c ****       case EPStall:            // Stalled
 650:../Sources/USB.c ****       case EPIdle:           // Idle
 651:../Sources/USB.c ****       case EPDataIn:         // Doing a sequence of IN packets
 652:../Sources/USB.c ****       case EPLastIn:         // Doing the last IN packet
 653:../Sources/USB.c ****       case EPStatusIn:       // Doing an IN packet as a status handshake for an OUT Data transfer
 654:../Sources/USB.c ****       default:
 655:../Sources/USB.c ****          // Set up EP0-OUT to Rx SETUP packets
 656:../Sources/USB.c ****          ep0ConfigureSetupTransaction();
 710              		.loc 1 656 0
 711 0022 FFF7FEFF 		bl	ep0ConfigureSetupTransaction
 657:../Sources/USB.c ****          epHardwareState[0].state = currentEp0State;
 712              		.loc 1 657 0
 713 0026 FB79     		ldrb	r3, [r7, #7]
 714 0028 03F01F03 		and	r3, r3, #31
 715 002c D9B2     		uxtb	r1, r3
 716 002e 40F20003 		movw	r3, #:lower16:epHardwareState
 717 0032 C0F20003 		movt	r3, #:upper16:epHardwareState
 718 0036 1A78     		ldrb	r2, [r3, #0]
 719 0038 61F3C702 		bfi	r2, r1, #3, #5
 720 003c 1A70     		strb	r2, [r3, #0]
 658:../Sources/USB.c ****          break;
 721              		.loc 1 658 0
 722 003e 00BF     		nop
 723 0040 00E0     		b	.L23
 724              	.L27:
 647:../Sources/USB.c ****          break;
 725              		.loc 1 647 0
 726 0042 00BF     		nop
 727              	.L23:
 659:../Sources/USB.c ****    }
 660:../Sources/USB.c **** }
 728              		.loc 1 660 0
 729 0044 07F10807 		add	r7, r7, #8
 730 0048 BD46     		mov	sp, r7
 731 004a 80BD     		pop	{r7, pc}
 732              		.cfi_endproc
 733              	.LFE6:
 735              		.section	.text.ep0InitialiseBdtTx,"ax",%progbits
 736              		.align	2
 737              		.thumb
 738              		.thumb_func
 740              	ep0InitialiseBdtTx:
 741              	.LFB7:
 661:../Sources/USB.c **** 
 662:../Sources/USB.c **** //======================================================================
 663:../Sources/USB.c **** // Configure the BDT for EP0 In [Tx, device -> host]
 664:../Sources/USB.c **** //
 665:../Sources/USB.c **** static void ep0InitialiseBdtTx( void ) {
 742              		.loc 1 665 0
 743              		.cfi_startproc
 744              		@ args = 0, pretend = 0, frame = 8
 745              		@ frame_needed = 1, uses_anonymous_args = 0
 746 0000 80B5     		push	{r7, lr}
 747              	.LCFI19:
 748              		.cfi_def_cfa_offset 8
 749              		.cfi_offset 7, -8
 750              		.cfi_offset 14, -4
 751 0002 82B0     		sub	sp, sp, #8
 752              	.LCFI20:
 753              		.cfi_def_cfa_offset 16
 754 0004 00AF     		add	r7, sp, #0
 755              	.LCFI21:
 756              		.cfi_def_cfa_register 7
 666:../Sources/USB.c ****    BdtEntry *bdt;
 667:../Sources/USB.c ****    U16 size;
 668:../Sources/USB.c **** 
 669:../Sources/USB.c ****    size = ep0State.dataRemaining;
 757              		.loc 1 669 0
 758 0006 40F20003 		movw	r3, #:lower16:ep0State
 759 000a C0F20003 		movt	r3, #:upper16:ep0State
 760 000e 1B79     		ldrb	r3, [r3, #4]
 761 0010 DBB2     		uxtb	r3, r3
 762 0012 FB80     		strh	r3, [r7, #6]	@ movhi
 670:../Sources/USB.c ****    if (size > ENDPT0MAXSIZE) {
 763              		.loc 1 670 0
 764 0014 FB88     		ldrh	r3, [r7, #6]
 765 0016 202B     		cmp	r3, #32
 766 0018 02D9     		bls	.L29
 671:../Sources/USB.c ****       size = ENDPT0MAXSIZE;
 767              		.loc 1 671 0
 768 001a 4FF02003 		mov	r3, #32
 769 001e FB80     		strh	r3, [r7, #6]	@ movhi
 770              	.L29:
 672:../Sources/USB.c ****    }
 673:../Sources/USB.c ****    // Copy the Tx data to EP buffer
 674:../Sources/USB.c ****    ( void )memcpy(ep0InDataBuffer, ep0State.dataPtr, size);
 771              		.loc 1 674 0
 772 0020 40F20003 		movw	r3, #:lower16:ep0State
 773 0024 C0F20003 		movt	r3, #:upper16:ep0State
 774 0028 1A68     		ldr	r2, [r3, #0]
 775 002a FB88     		ldrh	r3, [r7, #6]
 776 002c 40F20000 		movw	r0, #:lower16:ep0InDataBuffer
 777 0030 C0F20000 		movt	r0, #:upper16:ep0InDataBuffer
 778 0034 1146     		mov	r1, r2
 779 0036 1A46     		mov	r2, r3
 780 0038 FFF7FEFF 		bl	memcpy
 675:../Sources/USB.c ****       
 676:../Sources/USB.c ****    ep0State.dataPtr         += size;  // Ptr to _next_ data
 781              		.loc 1 676 0
 782 003c 40F20003 		movw	r3, #:lower16:ep0State
 783 0040 C0F20003 		movt	r3, #:upper16:ep0State
 784 0044 1A68     		ldr	r2, [r3, #0]
 785 0046 FB88     		ldrh	r3, [r7, #6]
 786 0048 D218     		adds	r2, r2, r3
 787 004a 40F20003 		movw	r3, #:lower16:ep0State
 788 004e C0F20003 		movt	r3, #:upper16:ep0State
 789 0052 1A60     		str	r2, [r3, #0]
 677:../Sources/USB.c ****    ep0State.dataRemaining   -= size;  // Count of remaining bytes
 790              		.loc 1 677 0
 791 0054 40F20003 		movw	r3, #:lower16:ep0State
 792 0058 C0F20003 		movt	r3, #:upper16:ep0State
 793 005c 1B79     		ldrb	r3, [r3, #4]
 794 005e DAB2     		uxtb	r2, r3
 795 0060 FB88     		ldrh	r3, [r7, #6]	@ movhi
 796 0062 DBB2     		uxtb	r3, r3
 797 0064 D31A     		subs	r3, r2, r3
 798 0066 DAB2     		uxtb	r2, r3
 799 0068 40F20003 		movw	r3, #:lower16:ep0State
 800 006c C0F20003 		movt	r3, #:upper16:ep0State
 801 0070 1A71     		strb	r2, [r3, #4]
 678:../Sources/USB.c ****    ep0State.dataCount       += size;  // Count of bytes so far
 802              		.loc 1 678 0
 803 0072 40F20003 		movw	r3, #:lower16:ep0State
 804 0076 C0F20003 		movt	r3, #:upper16:ep0State
 805 007a 5B79     		ldrb	r3, [r3, #5]
 806 007c DAB2     		uxtb	r2, r3
 807 007e FB88     		ldrh	r3, [r7, #6]	@ movhi
 808 0080 DBB2     		uxtb	r3, r3
 809 0082 D318     		adds	r3, r2, r3
 810 0084 DAB2     		uxtb	r2, r3
 811 0086 40F20003 		movw	r3, #:lower16:ep0State
 812 008a C0F20003 		movt	r3, #:upper16:ep0State
 813 008e 5A71     		strb	r2, [r3, #5]
 679:../Sources/USB.c ****    
 680:../Sources/USB.c ****    // Set up to Tx packet
 681:../Sources/USB.c ****    bdt = epHardwareState[0].txOdd?&endPointBdts[0].txOdd:&endPointBdts[0].txEven;
 814              		.loc 1 681 0
 815 0090 40F20003 		movw	r3, #:lower16:epHardwareState
 816 0094 C0F20003 		movt	r3, #:upper16:epHardwareState
 817 0098 1B78     		ldrb	r3, [r3, #0]
 818 009a DBB2     		uxtb	r3, r3
 819 009c 03F00203 		and	r3, r3, #2
 820 00a0 DBB2     		uxtb	r3, r3
 821 00a2 002B     		cmp	r3, #0
 822 00a4 01D0     		beq	.L30
 823              		.loc 1 681 0 is_stmt 0
 824 00a6 124B     		ldr	r3, .L34
 825 00a8 00E0     		b	.L31
 826              	.L30:
 827              		.loc 1 681 0
 828 00aa 124B     		ldr	r3, .L34+4
 829              	.L31:
 830              		.loc 1 681 0
 831 00ac 3B60     		str	r3, [r7, #0]
 682:../Sources/USB.c ****    bdt->bc = size;
 832              		.loc 1 682 0 is_stmt 1
 833 00ae 3B68     		ldr	r3, [r7, #0]
 834 00b0 5A88     		ldrh	r2, [r3, #2]	@ movhi
 835 00b2 4FF00002 		mov	r2, #0
 836 00b6 1146     		mov	r1, r2	@ movhi
 837 00b8 FA88     		ldrh	r2, [r7, #6]	@ movhi
 838 00ba 0A43     		orrs	r2, r2, r1
 839 00bc 5A80     		strh	r2, [r3, #2]	@ movhi
 683:../Sources/USB.c ****    if (epHardwareState[0].data0_1) {
 840              		.loc 1 683 0
 841 00be 40F20003 		movw	r3, #:lower16:epHardwareState
 842 00c2 C0F20003 		movt	r3, #:upper16:epHardwareState
 843 00c6 1B78     		ldrb	r3, [r3, #0]
 844 00c8 DBB2     		uxtb	r3, r3
 845 00ca 03F00103 		and	r3, r3, #1
 846 00ce DBB2     		uxtb	r3, r3
 847 00d0 002B     		cmp	r3, #0
 848 00d2 04D0     		beq	.L32
 684:../Sources/USB.c ****       bdt->u.bits = BDTEntry_OWN_MASK|BDTEntry_DATA1_MASK|BDTEntry_DTS_MASK;
 849              		.loc 1 684 0
 850 00d4 3B68     		ldr	r3, [r7, #0]
 851 00d6 4FF0C802 		mov	r2, #200
 852 00da 1A70     		strb	r2, [r3, #0]
 853 00dc 03E0     		b	.L28
 854              	.L32:
 685:../Sources/USB.c ****    }
 686:../Sources/USB.c ****    else {
 687:../Sources/USB.c ****       bdt->u.bits = BDTEntry_OWN_MASK|BDTEntry_DATA0_MASK|BDTEntry_DTS_MASK;
 855              		.loc 1 687 0
 856 00de 3B68     		ldr	r3, [r7, #0]
 857 00e0 4FF08802 		mov	r2, #136
 858 00e4 1A70     		strb	r2, [r3, #0]
 859              	.L28:
 688:../Sources/USB.c ****    }
 689:../Sources/USB.c **** }
 860              		.loc 1 689 0
 861 00e6 07F10807 		add	r7, r7, #8
 862 00ea BD46     		mov	sp, r7
 863 00ec 80BD     		pop	{r7, pc}
 864              	.L35:
 865 00ee 00BF     		.align	2
 866              	.L34:
 867 00f0 18000000 		.word	endPointBdts+24
 868 00f4 10000000 		.word	endPointBdts+16
 869              		.cfi_endproc
 870              	.LFE7:
 872              		.section	.text.ep0StartTxTransaction,"ax",%progbits
 873              		.align	2
 874              		.thumb
 875              		.thumb_func
 877              	ep0StartTxTransaction:
 878              	.LFB8:
 690:../Sources/USB.c **** 
 691:../Sources/USB.c **** //======================================================================
 692:../Sources/USB.c **** //! Configure EP0 for an IN transaction [Tx, device -> host, DATA0/1]
 693:../Sources/USB.c **** //!
 694:../Sources/USB.c **** static void ep0StartTxTransaction( uint8_t bufSize, const uint8_t *bufPtr, uint8_t data0_1 ) {
 879              		.loc 1 694 0
 880              		.cfi_startproc
 881              		@ args = 0, pretend = 0, frame = 8
 882              		@ frame_needed = 1, uses_anonymous_args = 0
 883 0000 80B5     		push	{r7, lr}
 884              	.LCFI22:
 885              		.cfi_def_cfa_offset 8
 886              		.cfi_offset 7, -8
 887              		.cfi_offset 14, -4
 888 0002 82B0     		sub	sp, sp, #8
 889              	.LCFI23:
 890              		.cfi_def_cfa_offset 16
 891 0004 00AF     		add	r7, sp, #0
 892              	.LCFI24:
 893              		.cfi_def_cfa_register 7
 894 0006 3960     		str	r1, [r7, #0]
 895 0008 1346     		mov	r3, r2
 896 000a 0246     		mov	r2, r0
 897 000c FA71     		strb	r2, [r7, #7]
 898 000e BB71     		strb	r3, [r7, #6]
 695:../Sources/USB.c **** 
 696:../Sources/USB.c ****    if (bufSize > ep0SetupBuffer.wLength.word) // More data than requested - truncate
 899              		.loc 1 696 0
 900 0010 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 901 0012 9AB2     		uxth	r2, r3
 902 0014 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 903 0018 C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 904 001c DB88     		ldrh	r3, [r3, #6]
 905 001e 9A42     		cmp	r2, r3
 906 0020 05D9     		bls	.L37
 697:../Sources/USB.c ****       bufSize = (uint8_t)ep0SetupBuffer.wLength.word;
 907              		.loc 1 697 0
 908 0022 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 909 0026 C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 910 002a DB88     		ldrh	r3, [r3, #6]
 911 002c FB71     		strb	r3, [r7, #7]
 912              	.L37:
 698:../Sources/USB.c **** 
 699:../Sources/USB.c ****    ep0State.dataPtr            = (uint8_t*)bufPtr;   // Ptr to _next_ data
 913              		.loc 1 699 0
 914 002e 40F20003 		movw	r3, #:lower16:ep0State
 915 0032 C0F20003 		movt	r3, #:upper16:ep0State
 916 0036 3A68     		ldr	r2, [r7, #0]
 917 0038 1A60     		str	r2, [r3, #0]
 700:../Sources/USB.c ****    ep0State.dataRemaining      = bufSize;       // Count of remaining bytes
 918              		.loc 1 700 0
 919 003a 40F20003 		movw	r3, #:lower16:ep0State
 920 003e C0F20003 		movt	r3, #:upper16:ep0State
 921 0042 FA79     		ldrb	r2, [r7, #7]
 922 0044 1A71     		strb	r2, [r3, #4]
 701:../Sources/USB.c ****    ep0State.dataCount          = 0;             // Reset count of bytes so far
 923              		.loc 1 701 0
 924 0046 40F20003 		movw	r3, #:lower16:ep0State
 925 004a C0F20003 		movt	r3, #:upper16:ep0State
 926 004e 4FF00002 		mov	r2, #0
 927 0052 5A71     		strb	r2, [r3, #5]
 702:../Sources/USB.c ****    epHardwareState[0].data0_1  = data0_1;       // Initial data toggle
 928              		.loc 1 702 0
 929 0054 BB79     		ldrb	r3, [r7, #6]
 930 0056 03F00103 		and	r3, r3, #1
 931 005a D9B2     		uxtb	r1, r3
 932 005c 40F20003 		movw	r3, #:lower16:epHardwareState
 933 0060 C0F20003 		movt	r3, #:upper16:epHardwareState
 934 0064 1A78     		ldrb	r2, [r3, #0]
 935 0066 61F30002 		bfi	r2, r1, #0, #1
 936 006a 1A70     		strb	r2, [r3, #0]
 703:../Sources/USB.c ****    ep0State.shortInTransaction = bufSize < ep0SetupBuffer.wLength.word; // Short transaction?
 937              		.loc 1 703 0
 938 006c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 939 006e 9AB2     		uxth	r2, r3
 940 0070 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 941 0074 C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 942 0078 DB88     		ldrh	r3, [r3, #6]
 943 007a 9A42     		cmp	r2, r3
 944 007c 2CBF     		ite	cs
 945 007e 0023     		movcs	r3, #0
 946 0080 0123     		movcc	r3, #1
 947 0082 D9B2     		uxtb	r1, r3
 948 0084 40F20003 		movw	r3, #:lower16:ep0State
 949 0088 C0F20003 		movt	r3, #:upper16:ep0State
 950 008c 9A79     		ldrb	r2, [r3, #6]
 951 008e 61F30002 		bfi	r2, r1, #0, #1
 952 0092 9A71     		strb	r2, [r3, #6]
 704:../Sources/USB.c **** 
 705:../Sources/USB.c ****    if (bufSize == 0)
 953              		.loc 1 705 0
 954 0094 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 955 0096 002B     		cmp	r3, #0
 956 0098 0AD1     		bne	.L38
 706:../Sources/USB.c ****       epHardwareState[0].state = EPStatusIn;   // Assume status handshake
 957              		.loc 1 706 0
 958 009a 40F20003 		movw	r3, #:lower16:epHardwareState
 959 009e C0F20003 		movt	r3, #:upper16:epHardwareState
 960 00a2 1A78     		ldrb	r2, [r3, #0]
 961 00a4 4FF00401 		mov	r1, #4
 962 00a8 61F3C702 		bfi	r2, r1, #3, #5
 963 00ac 1A70     		strb	r2, [r3, #0]
 964 00ae 25E0     		b	.L39
 965              	.L38:
 707:../Sources/USB.c ****    else if ((bufSize < ENDPT0MAXSIZE) ||       // Undersize pkt OR
 966              		.loc 1 707 0
 967 00b0 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 968 00b2 1F2B     		cmp	r3, #31
 969 00b4 0DD9     		bls	.L40
 970              		.loc 1 707 0 is_stmt 0
 971 00b6 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 972 00b8 202B     		cmp	r3, #32
 973 00ba 15D1     		bne	.L41
 708:../Sources/USB.c ****             ((bufSize == ENDPT0MAXSIZE) &&     // Full size AND
 709:../Sources/USB.c ****              !ep0State.shortInTransaction))    //   Don't need to flag undersize transaction 
 974              		.loc 1 709 0 is_stmt 1
 975 00bc 40F20003 		movw	r3, #:lower16:ep0State
 976 00c0 C0F20003 		movt	r3, #:upper16:ep0State
 977 00c4 9B79     		ldrb	r3, [r3, #6]
 978 00c6 DBB2     		uxtb	r3, r3
 979 00c8 03F00103 		and	r3, r3, #1
 980 00cc DBB2     		uxtb	r3, r3
 708:../Sources/USB.c ****             ((bufSize == ENDPT0MAXSIZE) &&     // Full size AND
 981              		.loc 1 708 0
 982 00ce 002B     		cmp	r3, #0
 983 00d0 0AD1     		bne	.L41
 984              	.L40:
 710:../Sources/USB.c ****       epHardwareState[0].state = EPLastIn;     // Sending one and only pkt
 985              		.loc 1 710 0
 986 00d2 40F20003 		movw	r3, #:lower16:epHardwareState
 987 00d6 C0F20003 		movt	r3, #:upper16:epHardwareState
 988 00da 1A78     		ldrb	r2, [r3, #0]
 989 00dc 4FF00301 		mov	r1, #3
 990 00e0 61F3C702 		bfi	r2, r1, #3, #5
 991 00e4 1A70     		strb	r2, [r3, #0]
 992 00e6 09E0     		b	.L39
 993              	.L41:
 711:../Sources/USB.c ****    else 
 712:../Sources/USB.c ****       epHardwareState[0].state = EPDataIn;     // Sending first of several pkts
 994              		.loc 1 712 0
 995 00e8 40F20003 		movw	r3, #:lower16:epHardwareState
 996 00ec C0F20003 		movt	r3, #:upper16:epHardwareState
 997 00f0 1A78     		ldrb	r2, [r3, #0]
 998 00f2 4FF00101 		mov	r1, #1
 999 00f6 61F3C702 		bfi	r2, r1, #3, #5
 1000 00fa 1A70     		strb	r2, [r3, #0]
 1001              	.L39:
 713:../Sources/USB.c ****       
 714:../Sources/USB.c ****    ep0InitialiseBdtTx(); // Configure the BDT for transfer
 1002              		.loc 1 714 0
 1003 00fc FFF7FEFF 		bl	ep0InitialiseBdtTx
 715:../Sources/USB.c **** }
 1004              		.loc 1 715 0
 1005 0100 07F10807 		add	r7, r7, #8
 1006 0104 BD46     		mov	sp, r7
 1007 0106 80BD     		pop	{r7, pc}
 1008              		.cfi_endproc
 1009              	.LFE8:
 1011              		.section	.text.ep1InitialiseBdtRx,"ax",%progbits
 1012              		.align	2
 1013              		.thumb
 1014              		.thumb_func
 1016              	ep1InitialiseBdtRx:
 1017              	.LFB9:
 716:../Sources/USB.c **** 
 717:../Sources/USB.c **** //======================================================================
 718:../Sources/USB.c **** // Configure the BDT for EP1 Out [Rx, device <- host, DATA0/1]
 719:../Sources/USB.c **** //
 720:../Sources/USB.c **** static void ep1InitialiseBdtRx( void ) {
 1018              		.loc 1 720 0
 1019              		.cfi_startproc
 1020              		@ args = 0, pretend = 0, frame = 8
 1021              		@ frame_needed = 1, uses_anonymous_args = 0
 1022              		@ link register save eliminated.
 1023 0000 80B4     		push	{r7}
 1024              	.LCFI25:
 1025              		.cfi_def_cfa_offset 4
 1026              		.cfi_offset 7, -4
 1027 0002 83B0     		sub	sp, sp, #12
 1028              	.LCFI26:
 1029              		.cfi_def_cfa_offset 16
 1030 0004 00AF     		add	r7, sp, #0
 1031              	.LCFI27:
 1032              		.cfi_def_cfa_register 7
 721:../Sources/USB.c ****    BdtEntry *bdt;
 722:../Sources/USB.c **** 
 723:../Sources/USB.c ****    // Set up to Rx packet
 724:../Sources/USB.c ****    bdt = epHardwareState[1].rxOdd?&endPointBdts[1].rxOdd:&endPointBdts[1].rxEven;
 1033              		.loc 1 724 0
 1034 0006 40F20003 		movw	r3, #:lower16:epHardwareState
 1035 000a C0F20003 		movt	r3, #:upper16:epHardwareState
 1036 000e 5B78     		ldrb	r3, [r3, #1]
 1037 0010 DBB2     		uxtb	r3, r3
 1038 0012 03F00403 		and	r3, r3, #4
 1039 0016 DBB2     		uxtb	r3, r3
 1040 0018 002B     		cmp	r3, #0
 1041 001a 01D0     		beq	.L43
 1042              		.loc 1 724 0 is_stmt 0
 1043 001c 114B     		ldr	r3, .L47
 1044 001e 00E0     		b	.L44
 1045              	.L43:
 1046              		.loc 1 724 0
 1047 0020 114B     		ldr	r3, .L47+4
 1048              	.L44:
 1049              		.loc 1 724 0
 1050 0022 7B60     		str	r3, [r7, #4]
 725:../Sources/USB.c **** 
 726:../Sources/USB.c ****    // Set up to Rx packet
 727:../Sources/USB.c ****    bdt->bc = ENDPT1MAXSIZE;
 1051              		.loc 1 727 0 is_stmt 1
 1052 0024 7B68     		ldr	r3, [r7, #4]
 1053 0026 5A88     		ldrh	r2, [r3, #2]	@ movhi
 1054 0028 4FF00002 		mov	r2, #0
 1055 002c 42F04002 		orr	r2, r2, #64
 1056 0030 5A80     		strh	r2, [r3, #2]	@ movhi
 728:../Sources/USB.c ****    if (epHardwareState[1].data0_1) {
 1057              		.loc 1 728 0
 1058 0032 40F20003 		movw	r3, #:lower16:epHardwareState
 1059 0036 C0F20003 		movt	r3, #:upper16:epHardwareState
 1060 003a 5B78     		ldrb	r3, [r3, #1]
 1061 003c DBB2     		uxtb	r3, r3
 1062 003e 03F00103 		and	r3, r3, #1
 1063 0042 DBB2     		uxtb	r3, r3
 1064 0044 002B     		cmp	r3, #0
 1065 0046 04D0     		beq	.L45
 729:../Sources/USB.c ****       bdt->u.bits  = BDTEntry_OWN_MASK|BDTEntry_DATA1_MASK|BDTEntry_DTS_MASK;
 1066              		.loc 1 729 0
 1067 0048 7B68     		ldr	r3, [r7, #4]
 1068 004a 4FF0C802 		mov	r2, #200
 1069 004e 1A70     		strb	r2, [r3, #0]
 1070 0050 03E0     		b	.L42
 1071              	.L45:
 730:../Sources/USB.c ****    }
 731:../Sources/USB.c ****    else {
 732:../Sources/USB.c ****       bdt->u.bits  = BDTEntry_OWN_MASK|BDTEntry_DATA0_MASK|BDTEntry_DTS_MASK;
 1072              		.loc 1 732 0
 1073 0052 7B68     		ldr	r3, [r7, #4]
 1074 0054 4FF08802 		mov	r2, #136
 1075 0058 1A70     		strb	r2, [r3, #0]
 1076              	.L42:
 733:../Sources/USB.c ****    }
 734:../Sources/USB.c **** }
 1077              		.loc 1 734 0
 1078 005a 07F10C07 		add	r7, r7, #12
 1079 005e BD46     		mov	sp, r7
 1080 0060 80BC     		pop	{r7}
 1081 0062 7047     		bx	lr
 1082              	.L48:
 1083              		.align	2
 1084              	.L47:
 1085 0064 28000000 		.word	endPointBdts+40
 1086 0068 20000000 		.word	endPointBdts+32
 1087              		.cfi_endproc
 1088              	.LFE9:
 1090              		.section	.text.ep1SaveRxData,"ax",%progbits
 1091              		.align	2
 1092              		.thumb
 1093              		.thumb_func
 1095              	ep1SaveRxData:
 1096              	.LFB10:
 735:../Sources/USB.c **** 
 736:../Sources/USB.c **** //=========================================================================
 737:../Sources/USB.c **** // Save the data from an EP1 OUT pkt and advance ptrs etc.
 738:../Sources/USB.c **** //
 739:../Sources/USB.c **** static uint8_t ep1SaveRxData( void ) {
 1097              		.loc 1 739 0
 1098              		.cfi_startproc
 1099              		@ args = 0, pretend = 0, frame = 8
 1100              		@ frame_needed = 1, uses_anonymous_args = 0
 1101 0000 80B5     		push	{r7, lr}
 1102              	.LCFI28:
 1103              		.cfi_def_cfa_offset 8
 1104              		.cfi_offset 7, -8
 1105              		.cfi_offset 14, -4
 1106 0002 82B0     		sub	sp, sp, #8
 1107              	.LCFI29:
 1108              		.cfi_def_cfa_offset 16
 1109 0004 00AF     		add	r7, sp, #0
 1110              	.LCFI30:
 1111              		.cfi_def_cfa_register 7
 740:../Sources/USB.c ****    BdtEntry *bdt;
 741:../Sources/USB.c ****    uint8_t size;
 742:../Sources/USB.c ****    
 743:../Sources/USB.c ****    // Get BDT
 744:../Sources/USB.c ****    bdt = (!epHardwareState[1].rxOdd)?&endPointBdts[1].rxOdd:&endPointBdts[1].rxEven;
 1112              		.loc 1 744 0
 1113 0006 40F20003 		movw	r3, #:lower16:epHardwareState
 1114 000a C0F20003 		movt	r3, #:upper16:epHardwareState
 1115 000e 5B78     		ldrb	r3, [r3, #1]
 1116 0010 DBB2     		uxtb	r3, r3
 1117 0012 03F00403 		and	r3, r3, #4
 1118 0016 DBB2     		uxtb	r3, r3
 1119 0018 002B     		cmp	r3, #0
 1120 001a 01D1     		bne	.L50
 1121              		.loc 1 744 0 is_stmt 0
 1122 001c 2E4B     		ldr	r3, .L56
 1123 001e 00E0     		b	.L51
 1124              	.L50:
 1125              		.loc 1 744 0
 1126 0020 2E4B     		ldr	r3, .L56+4
 1127              	.L51:
 1128              		.loc 1 744 0
 1129 0022 3B60     		str	r3, [r7, #0]
 745:../Sources/USB.c ****    size = bdt->bc;
 1130              		.loc 1 745 0 is_stmt 1
 1131 0024 3B68     		ldr	r3, [r7, #0]
 1132 0026 5B88     		ldrh	r3, [r3, #2]	@ movhi
 1133 0028 9BB2     		uxth	r3, r3
 1134 002a FB71     		strb	r3, [r7, #7]
 746:../Sources/USB.c **** 
 747:../Sources/USB.c ****    if (size > 0) {
 1135              		.loc 1 747 0
 1136 002c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1137 002e 002B     		cmp	r3, #0
 1138 0030 4BD0     		beq	.L52
 748:../Sources/USB.c ****       if (size > ep1State.dataRemaining)
 1139              		.loc 1 748 0
 1140 0032 40F20003 		movw	r3, #:lower16:ep1State
 1141 0036 C0F20003 		movt	r3, #:upper16:ep1State
 1142 003a 1B79     		ldrb	r3, [r3, #4]
 1143 003c DBB2     		uxtb	r3, r3
 1144 003e FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 1145 0040 9A42     		cmp	r2, r3
 1146 0042 05D9     		bls	.L53
 749:../Sources/USB.c ****          size = ep1State.dataRemaining;
 1147              		.loc 1 749 0
 1148 0044 40F20003 		movw	r3, #:lower16:ep1State
 1149 0048 C0F20003 		movt	r3, #:upper16:ep1State
 1150 004c 1B79     		ldrb	r3, [r3, #4]
 1151 004e FB71     		strb	r3, [r7, #7]
 1152              	.L53:
 750:../Sources/USB.c ****       if (ep1State.dataPtr != NULL) {
 1153              		.loc 1 750 0
 1154 0050 40F20003 		movw	r3, #:lower16:ep1State
 1155 0054 C0F20003 		movt	r3, #:upper16:ep1State
 1156 0058 1B68     		ldr	r3, [r3, #0]
 1157 005a 002B     		cmp	r3, #0
 1158 005c 19D0     		beq	.L54
 751:../Sources/USB.c ****          // Copy the data from the Rx buffer
 752:../Sources/USB.c ****          ( void )memcpy(ep1State.dataPtr, ep1DataBuffer, size);
 1159              		.loc 1 752 0
 1160 005e 40F20003 		movw	r3, #:lower16:ep1State
 1161 0062 C0F20003 		movt	r3, #:upper16:ep1State
 1162 0066 1A68     		ldr	r2, [r3, #0]
 1163 0068 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1164 006a 1046     		mov	r0, r2
 1165 006c 40F20001 		movw	r1, #:lower16:ep1DataBuffer
 1166 0070 C0F20001 		movt	r1, #:upper16:ep1DataBuffer
 1167 0074 1A46     		mov	r2, r3
 1168 0076 FFF7FEFF 		bl	memcpy
 753:../Sources/USB.c ****          ep1State.dataPtr    += size;   // Advance buffer ptr
 1169              		.loc 1 753 0
 1170 007a 40F20003 		movw	r3, #:lower16:ep1State
 1171 007e C0F20003 		movt	r3, #:upper16:ep1State
 1172 0082 1A68     		ldr	r2, [r3, #0]
 1173 0084 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1174 0086 D218     		adds	r2, r2, r3
 1175 0088 40F20003 		movw	r3, #:lower16:ep1State
 1176 008c C0F20003 		movt	r3, #:upper16:ep1State
 1177 0090 1A60     		str	r2, [r3, #0]
 1178              	.L54:
 754:../Sources/USB.c ****       }
 755:../Sources/USB.c ****       ep1State.dataRemaining -= size;   // Count down bytes to go
 1179              		.loc 1 755 0
 1180 0092 40F20003 		movw	r3, #:lower16:ep1State
 1181 0096 C0F20003 		movt	r3, #:upper16:ep1State
 1182 009a 1B79     		ldrb	r3, [r3, #4]
 1183 009c DAB2     		uxtb	r2, r3
 1184 009e FB79     		ldrb	r3, [r7, #7]
 1185 00a0 D31A     		subs	r3, r2, r3
 1186 00a2 DAB2     		uxtb	r2, r3
 1187 00a4 40F20003 		movw	r3, #:lower16:ep1State
 1188 00a8 C0F20003 		movt	r3, #:upper16:ep1State
 1189 00ac 1A71     		strb	r2, [r3, #4]
 756:../Sources/USB.c ****       ep1State.dataCount     += size;   // Count bytes so far
 1190              		.loc 1 756 0
 1191 00ae 40F20003 		movw	r3, #:lower16:ep1State
 1192 00b2 C0F20003 		movt	r3, #:upper16:ep1State
 1193 00b6 5B79     		ldrb	r3, [r3, #5]
 1194 00b8 DAB2     		uxtb	r2, r3
 1195 00ba FB79     		ldrb	r3, [r7, #7]
 1196 00bc D318     		adds	r3, r2, r3
 1197 00be DAB2     		uxtb	r2, r3
 1198 00c0 40F20003 		movw	r3, #:lower16:ep1State
 1199 00c4 C0F20003 		movt	r3, #:upper16:ep1State
 1200 00c8 5A71     		strb	r2, [r3, #5]
 1201              	.L52:
 757:../Sources/USB.c ****       }
 758:../Sources/USB.c ****    return size;
 1202              		.loc 1 758 0
 1203 00ca FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 759:../Sources/USB.c **** }
 1204              		.loc 1 759 0
 1205 00cc 1846     		mov	r0, r3
 1206 00ce 07F10807 		add	r7, r7, #8
 1207 00d2 BD46     		mov	sp, r7
 1208 00d4 80BD     		pop	{r7, pc}
 1209              	.L57:
 1210 00d6 00BF     		.align	2
 1211              	.L56:
 1212 00d8 28000000 		.word	endPointBdts+40
 1213 00dc 20000000 		.word	endPointBdts+32
 1214              		.cfi_endproc
 1215              	.LFE10:
 1217              		.section	.text.ep1StartRxTransaction,"ax",%progbits
 1218              		.align	2
 1219              		.thumb
 1220              		.thumb_func
 1222              	ep1StartRxTransaction:
 1223              	.LFB11:
 760:../Sources/USB.c **** 
 761:../Sources/USB.c **** 
 762:../Sources/USB.c **** 
 763:../Sources/USB.c **** //======================================================================
 764:../Sources/USB.c **** /*! Configure EP1-out for an OUT transaction [Rx, device <- host, DATA0/1]
 765:../Sources/USB.c ****  *
 766:../Sources/USB.c ****  * @param bufSize - Size of data to transfer
 767:../Sources/USB.c ****  * @param bufPtr  - Buffer for data
 768:../Sources/USB.c ****  */
 769:../Sources/USB.c **** static void ep1StartRxTransaction( uint8_t bufSize, uint8_t *bufPtr ) {
 1224              		.loc 1 769 0
 1225              		.cfi_startproc
 1226              		@ args = 0, pretend = 0, frame = 8
 1227              		@ frame_needed = 1, uses_anonymous_args = 0
 1228 0000 80B5     		push	{r7, lr}
 1229              	.LCFI31:
 1230              		.cfi_def_cfa_offset 8
 1231              		.cfi_offset 7, -8
 1232              		.cfi_offset 14, -4
 1233 0002 82B0     		sub	sp, sp, #8
 1234              	.LCFI32:
 1235              		.cfi_def_cfa_offset 16
 1236 0004 00AF     		add	r7, sp, #0
 1237              	.LCFI33:
 1238              		.cfi_def_cfa_register 7
 1239 0006 0346     		mov	r3, r0
 1240 0008 3960     		str	r1, [r7, #0]
 1241 000a FB71     		strb	r3, [r7, #7]
 770:../Sources/USB.c ****    ep1State.dataRemaining  = bufSize; // Total bytes to Rx
 1242              		.loc 1 770 0
 1243 000c 40F20003 		movw	r3, #:lower16:ep1State
 1244 0010 C0F20003 		movt	r3, #:upper16:ep1State
 1245 0014 FA79     		ldrb	r2, [r7, #7]
 1246 0016 1A71     		strb	r2, [r3, #4]
 771:../Sources/USB.c ****    ep1State.dataCount      = 0;       // Reset count of bytes so far
 1247              		.loc 1 771 0
 1248 0018 40F20003 		movw	r3, #:lower16:ep1State
 1249 001c C0F20003 		movt	r3, #:upper16:ep1State
 1250 0020 4FF00002 		mov	r2, #0
 1251 0024 5A71     		strb	r2, [r3, #5]
 772:../Sources/USB.c ****    ep1State.dataPtr        = bufPtr;  // Where to (eventually) place data
 1252              		.loc 1 772 0
 1253 0026 40F20003 		movw	r3, #:lower16:ep1State
 1254 002a C0F20003 		movt	r3, #:upper16:ep1State
 1255 002e 3A68     		ldr	r2, [r7, #0]
 1256 0030 1A60     		str	r2, [r3, #0]
 773:../Sources/USB.c ****    
 774:../Sources/USB.c ****    epHardwareState[1].state = EPDataOut;    // Assume first of several data pkts
 1257              		.loc 1 774 0
 1258 0032 40F20003 		movw	r3, #:lower16:epHardwareState
 1259 0036 C0F20003 		movt	r3, #:upper16:epHardwareState
 1260 003a 5A78     		ldrb	r2, [r3, #1]
 1261 003c 4FF00201 		mov	r1, #2
 1262 0040 61F3C702 		bfi	r2, r1, #3, #5
 1263 0044 5A70     		strb	r2, [r3, #1]
 775:../Sources/USB.c **** 
 776:../Sources/USB.c ****    ep1InitialiseBdtRx(); // Configure the BDT for transfer
 1264              		.loc 1 776 0
 1265 0046 FFF7FEFF 		bl	ep1InitialiseBdtRx
 777:../Sources/USB.c **** }
 1266              		.loc 1 777 0
 1267 004a 07F10807 		add	r7, r7, #8
 1268 004e BD46     		mov	sp, r7
 1269 0050 80BD     		pop	{r7, pc}
 1270              		.cfi_endproc
 1271              	.LFE11:
 1273 0052 00BF     		.section	.text.ep2InitialiseBdtTx,"ax",%progbits
 1274              		.align	2
 1275              		.thumb
 1276              		.thumb_func
 1278              	ep2InitialiseBdtTx:
 1279              	.LFB12:
 778:../Sources/USB.c **** 
 779:../Sources/USB.c **** //======================================================================
 780:../Sources/USB.c **** // Configure the BDT for EP2 In [Tx, device -> host]
 781:../Sources/USB.c **** //
 782:../Sources/USB.c **** static void ep2InitialiseBdtTx( void ) {
 1280              		.loc 1 782 0
 1281              		.cfi_startproc
 1282              		@ args = 0, pretend = 0, frame = 8
 1283              		@ frame_needed = 1, uses_anonymous_args = 0
 1284 0000 80B5     		push	{r7, lr}
 1285              	.LCFI34:
 1286              		.cfi_def_cfa_offset 8
 1287              		.cfi_offset 7, -8
 1288              		.cfi_offset 14, -4
 1289 0002 82B0     		sub	sp, sp, #8
 1290              	.LCFI35:
 1291              		.cfi_def_cfa_offset 16
 1292 0004 00AF     		add	r7, sp, #0
 1293              	.LCFI36:
 1294              		.cfi_def_cfa_register 7
 783:../Sources/USB.c ****    U16 size;
 784:../Sources/USB.c ****    BdtEntry *bdt;
 785:../Sources/USB.c ****    
 786:../Sources/USB.c ****    // Set up to Rx packet
 787:../Sources/USB.c ****    bdt = epHardwareState[2].txOdd?&endPointBdts[2].txOdd:&endPointBdts[2].txEven;
 1295              		.loc 1 787 0
 1296 0006 40F20003 		movw	r3, #:lower16:epHardwareState
 1297 000a C0F20003 		movt	r3, #:upper16:epHardwareState
 1298 000e 9B78     		ldrb	r3, [r3, #2]
 1299 0010 DBB2     		uxtb	r3, r3
 1300 0012 03F00203 		and	r3, r3, #2
 1301 0016 DBB2     		uxtb	r3, r3
 1302 0018 002B     		cmp	r3, #0
 1303 001a 01D0     		beq	.L60
 1304              		.loc 1 787 0 is_stmt 0
 1305 001c 344B     		ldr	r3, .L65
 1306 001e 00E0     		b	.L61
 1307              	.L60:
 1308              		.loc 1 787 0
 1309 0020 344B     		ldr	r3, .L65+4
 1310              	.L61:
 1311              		.loc 1 787 0
 1312 0022 3B60     		str	r3, [r7, #0]
 788:../Sources/USB.c **** 
 789:../Sources/USB.c ****    size = ep2State.dataRemaining;
 1313              		.loc 1 789 0 is_stmt 1
 1314 0024 40F20003 		movw	r3, #:lower16:ep2State
 1315 0028 C0F20003 		movt	r3, #:upper16:ep2State
 1316 002c 1B79     		ldrb	r3, [r3, #4]
 1317 002e DBB2     		uxtb	r3, r3
 1318 0030 FB80     		strh	r3, [r7, #6]	@ movhi
 790:../Sources/USB.c ****    if (size > ENDPT2MAXSIZE)
 1319              		.loc 1 790 0
 1320 0032 FB88     		ldrh	r3, [r7, #6]
 1321 0034 402B     		cmp	r3, #64
 1322 0036 02D9     		bls	.L62
 791:../Sources/USB.c ****       size = ENDPT2MAXSIZE;
 1323              		.loc 1 791 0
 1324 0038 4FF04003 		mov	r3, #64
 1325 003c FB80     		strh	r3, [r7, #6]	@ movhi
 1326              	.L62:
 792:../Sources/USB.c ****    
 793:../Sources/USB.c ****    // Copy the Tx data to EP buffer
 794:../Sources/USB.c ****    (void) memcpy(ep2DataBuffer, ep2State.dataPtr, size);
 1327              		.loc 1 794 0
 1328 003e 40F20003 		movw	r3, #:lower16:ep2State
 1329 0042 C0F20003 		movt	r3, #:upper16:ep2State
 1330 0046 1A68     		ldr	r2, [r3, #0]
 1331 0048 FB88     		ldrh	r3, [r7, #6]
 1332 004a 40F20000 		movw	r0, #:lower16:ep2DataBuffer
 1333 004e C0F20000 		movt	r0, #:upper16:ep2DataBuffer
 1334 0052 1146     		mov	r1, r2
 1335 0054 1A46     		mov	r2, r3
 1336 0056 FFF7FEFF 		bl	memcpy
 795:../Sources/USB.c ****       
 796:../Sources/USB.c ****    ep2State.dataPtr         += size;  // Ptr to _next_ data
 1337              		.loc 1 796 0
 1338 005a 40F20003 		movw	r3, #:lower16:ep2State
 1339 005e C0F20003 		movt	r3, #:upper16:ep2State
 1340 0062 1A68     		ldr	r2, [r3, #0]
 1341 0064 FB88     		ldrh	r3, [r7, #6]
 1342 0066 D218     		adds	r2, r2, r3
 1343 0068 40F20003 		movw	r3, #:lower16:ep2State
 1344 006c C0F20003 		movt	r3, #:upper16:ep2State
 1345 0070 1A60     		str	r2, [r3, #0]
 797:../Sources/USB.c ****    ep2State.dataRemaining   -= size;  // Count of remaining bytes
 1346              		.loc 1 797 0
 1347 0072 40F20003 		movw	r3, #:lower16:ep2State
 1348 0076 C0F20003 		movt	r3, #:upper16:ep2State
 1349 007a 1B79     		ldrb	r3, [r3, #4]
 1350 007c DAB2     		uxtb	r2, r3
 1351 007e FB88     		ldrh	r3, [r7, #6]	@ movhi
 1352 0080 DBB2     		uxtb	r3, r3
 1353 0082 D31A     		subs	r3, r2, r3
 1354 0084 DAB2     		uxtb	r2, r3
 1355 0086 40F20003 		movw	r3, #:lower16:ep2State
 1356 008a C0F20003 		movt	r3, #:upper16:ep2State
 1357 008e 1A71     		strb	r2, [r3, #4]
 798:../Sources/USB.c ****    ep2State.dataCount       += size;  // Count of bytes so far
 1358              		.loc 1 798 0
 1359 0090 40F20003 		movw	r3, #:lower16:ep2State
 1360 0094 C0F20003 		movt	r3, #:upper16:ep2State
 1361 0098 5B79     		ldrb	r3, [r3, #5]
 1362 009a DAB2     		uxtb	r2, r3
 1363 009c FB88     		ldrh	r3, [r7, #6]	@ movhi
 1364 009e DBB2     		uxtb	r3, r3
 1365 00a0 D318     		adds	r3, r2, r3
 1366 00a2 DAB2     		uxtb	r2, r3
 1367 00a4 40F20003 		movw	r3, #:lower16:ep2State
 1368 00a8 C0F20003 		movt	r3, #:upper16:ep2State
 1369 00ac 5A71     		strb	r2, [r3, #5]
 799:../Sources/USB.c ****    
 800:../Sources/USB.c ****    // Set up to Tx packet
 801:../Sources/USB.c ****    bdt->bc     = (uint8_t)size;
 1370              		.loc 1 801 0
 1371 00ae FB88     		ldrh	r3, [r7, #6]	@ movhi
 1372 00b0 DBB2     		uxtb	r3, r3
 1373 00b2 1946     		mov	r1, r3
 1374 00b4 3B68     		ldr	r3, [r7, #0]
 1375 00b6 5A88     		ldrh	r2, [r3, #2]	@ movhi
 1376 00b8 4FF00002 		mov	r2, #0
 1377 00bc 0A43     		orrs	r2, r2, r1
 1378 00be 5A80     		strh	r2, [r3, #2]	@ movhi
 802:../Sources/USB.c ****    if (epHardwareState[2].data0_1) {
 1379              		.loc 1 802 0
 1380 00c0 40F20003 		movw	r3, #:lower16:epHardwareState
 1381 00c4 C0F20003 		movt	r3, #:upper16:epHardwareState
 1382 00c8 9B78     		ldrb	r3, [r3, #2]
 1383 00ca DBB2     		uxtb	r3, r3
 1384 00cc 03F00103 		and	r3, r3, #1
 1385 00d0 DBB2     		uxtb	r3, r3
 1386 00d2 002B     		cmp	r3, #0
 1387 00d4 04D0     		beq	.L63
 803:../Sources/USB.c ****       bdt->u.bits  = BDTEntry_OWN_MASK|BDTEntry_DATA1_MASK|BDTEntry_DTS_MASK;
 1388              		.loc 1 803 0
 1389 00d6 3B68     		ldr	r3, [r7, #0]
 1390 00d8 4FF0C802 		mov	r2, #200
 1391 00dc 1A70     		strb	r2, [r3, #0]
 1392 00de 03E0     		b	.L59
 1393              	.L63:
 804:../Sources/USB.c ****    }
 805:../Sources/USB.c ****    else {
 806:../Sources/USB.c ****       bdt->u.bits  = BDTEntry_OWN_MASK|BDTEntry_DATA0_MASK|BDTEntry_DTS_MASK;
 1394              		.loc 1 806 0
 1395 00e0 3B68     		ldr	r3, [r7, #0]
 1396 00e2 4FF08802 		mov	r2, #136
 1397 00e6 1A70     		strb	r2, [r3, #0]
 1398              	.L59:
 807:../Sources/USB.c ****    }
 808:../Sources/USB.c **** }
 1399              		.loc 1 808 0
 1400 00e8 07F10807 		add	r7, r7, #8
 1401 00ec BD46     		mov	sp, r7
 1402 00ee 80BD     		pop	{r7, pc}
 1403              	.L66:
 1404              		.align	2
 1405              	.L65:
 1406 00f0 58000000 		.word	endPointBdts+88
 1407 00f4 50000000 		.word	endPointBdts+80
 1408              		.cfi_endproc
 1409              	.LFE12:
 1411              		.section	.text.ep2StartTxTransaction,"ax",%progbits
 1412              		.align	2
 1413              		.thumb
 1414              		.thumb_func
 1416              	ep2StartTxTransaction:
 1417              	.LFB13:
 809:../Sources/USB.c **** 
 810:../Sources/USB.c **** 
 811:../Sources/USB.c **** 
 812:../Sources/USB.c **** //======================================================================
 813:../Sources/USB.c **** // Configure EP2 for an IN transaction [Tx, device -> host, DATA0/1]
 814:../Sources/USB.c **** //
 815:../Sources/USB.c **** static void ep2StartTxTransaction( uint8_t bufSize, const uint8_t *bufPtr ) {
 1418              		.loc 1 815 0
 1419              		.cfi_startproc
 1420              		@ args = 0, pretend = 0, frame = 8
 1421              		@ frame_needed = 1, uses_anonymous_args = 0
 1422 0000 80B5     		push	{r7, lr}
 1423              	.LCFI37:
 1424              		.cfi_def_cfa_offset 8
 1425              		.cfi_offset 7, -8
 1426              		.cfi_offset 14, -4
 1427 0002 82B0     		sub	sp, sp, #8
 1428              	.LCFI38:
 1429              		.cfi_def_cfa_offset 16
 1430 0004 00AF     		add	r7, sp, #0
 1431              	.LCFI39:
 1432              		.cfi_def_cfa_register 7
 1433 0006 0346     		mov	r3, r0
 1434 0008 3960     		str	r1, [r7, #0]
 1435 000a FB71     		strb	r3, [r7, #7]
 816:../Sources/USB.c **** 
 817:../Sources/USB.c ****    ep2State.dataPtr            = (uint8_t*)bufPtr;   // Ptr to _next_ data
 1436              		.loc 1 817 0
 1437 000c 40F20003 		movw	r3, #:lower16:ep2State
 1438 0010 C0F20003 		movt	r3, #:upper16:ep2State
 1439 0014 3A68     		ldr	r2, [r7, #0]
 1440 0016 1A60     		str	r2, [r3, #0]
 818:../Sources/USB.c ****    ep2State.dataRemaining      = bufSize;       // Count of remaining bytes
 1441              		.loc 1 818 0
 1442 0018 40F20003 		movw	r3, #:lower16:ep2State
 1443 001c C0F20003 		movt	r3, #:upper16:ep2State
 1444 0020 FA79     		ldrb	r2, [r7, #7]
 1445 0022 1A71     		strb	r2, [r3, #4]
 819:../Sources/USB.c ****    ep2State.dataCount          = 0;             // Reset count of bytes so far
 1446              		.loc 1 819 0
 1447 0024 40F20003 		movw	r3, #:lower16:ep2State
 1448 0028 C0F20003 		movt	r3, #:upper16:ep2State
 1449 002c 4FF00002 		mov	r2, #0
 1450 0030 5A71     		strb	r2, [r3, #5]
 820:../Sources/USB.c ****    
 821:../Sources/USB.c ****    // Note - Always terminates transfers with a truncated/zero pkt
 822:../Sources/USB.c ****    if (bufSize < ENDPT2MAXSIZE) {   // Undersize pkt OR
 1451              		.loc 1 822 0
 1452 0032 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1453 0034 3F2B     		cmp	r3, #63
 1454 0036 0AD8     		bhi	.L68
 823:../Sources/USB.c ****       epHardwareState[2].state = EPLastIn;    // Sending one and only pkt
 1455              		.loc 1 823 0
 1456 0038 40F20003 		movw	r3, #:lower16:epHardwareState
 1457 003c C0F20003 		movt	r3, #:upper16:epHardwareState
 1458 0040 9A78     		ldrb	r2, [r3, #2]
 1459 0042 4FF00301 		mov	r1, #3
 1460 0046 61F3C702 		bfi	r2, r1, #3, #5
 1461 004a 9A70     		strb	r2, [r3, #2]
 1462 004c 09E0     		b	.L69
 1463              	.L68:
 824:../Sources/USB.c ****    }
 825:../Sources/USB.c ****    else { 
 826:../Sources/USB.c ****       epHardwareState[2].state = EPDataIn;    // Sending first of several pkts
 1464              		.loc 1 826 0
 1465 004e 40F20003 		movw	r3, #:lower16:epHardwareState
 1466 0052 C0F20003 		movt	r3, #:upper16:epHardwareState
 1467 0056 9A78     		ldrb	r2, [r3, #2]
 1468 0058 4FF00101 		mov	r1, #1
 1469 005c 61F3C702 		bfi	r2, r1, #3, #5
 1470 0060 9A70     		strb	r2, [r3, #2]
 1471              	.L69:
 827:../Sources/USB.c ****    }  
 828:../Sources/USB.c ****    ep2InitialiseBdtTx(); // Configure the BDT for transfer
 1472              		.loc 1 828 0
 1473 0062 FFF7FEFF 		bl	ep2InitialiseBdtTx
 829:../Sources/USB.c **** }
 1474              		.loc 1 829 0
 1475 0066 07F10807 		add	r7, r7, #8
 1476 006a BD46     		mov	sp, r7
 1477 006c 80BD     		pop	{r7, pc}
 1478              		.cfi_endproc
 1479              	.LFE13:
 1481 006e 00BF     		.section	.text.initialiseEndpoints,"ax",%progbits
 1482              		.align	2
 1483              		.thumb
 1484              		.thumb_func
 1486              	initialiseEndpoints:
 1487              	.LFB14:
 830:../Sources/USB.c **** 
 831:../Sources/USB.c **** //! Set BDM busy flag
 832:../Sources/USB.c **** //!
 833:../Sources/USB.c **** static void initialiseEndpoints(void) {
 1488              		.loc 1 833 0
 1489              		.cfi_startproc
 1490              		@ args = 0, pretend = 0, frame = 0
 1491              		@ frame_needed = 1, uses_anonymous_args = 0
 1492 0000 80B5     		push	{r7, lr}
 1493              	.LCFI40:
 1494              		.cfi_def_cfa_offset 8
 1495              		.cfi_offset 7, -8
 1496              		.cfi_offset 14, -4
 1497 0002 00AF     		add	r7, sp, #0
 1498              	.LCFI41:
 1499              		.cfi_def_cfa_register 7
 834:../Sources/USB.c **** 
 835:../Sources/USB.c ****    // Clear USB BDTS
 836:../Sources/USB.c ****    memset((uint8_t*)endPointBdts, 0, sizeof(endPointBdts));
 1500              		.loc 1 836 0
 1501 0004 40F20000 		movw	r0, #:lower16:endPointBdts
 1502 0008 C0F20000 		movt	r0, #:upper16:endPointBdts
 1503 000c 4FF00001 		mov	r1, #0
 1504 0010 4FF40072 		mov	r2, #512
 1505 0014 FFF7FEFF 		bl	memset
 837:../Sources/USB.c ****    
 838:../Sources/USB.c ****    epHardwareState[0].rxOdd = 0;
 1506              		.loc 1 838 0
 1507 0018 40F20003 		movw	r3, #:lower16:epHardwareState
 1508 001c C0F20003 		movt	r3, #:upper16:epHardwareState
 1509 0020 1A78     		ldrb	r2, [r3, #0]
 1510 0022 6FF38202 		bfc	r2, #2, #1
 1511 0026 1A70     		strb	r2, [r3, #0]
 839:../Sources/USB.c ****    epHardwareState[0].txOdd = 0;
 1512              		.loc 1 839 0
 1513 0028 40F20003 		movw	r3, #:lower16:epHardwareState
 1514 002c C0F20003 		movt	r3, #:upper16:epHardwareState
 1515 0030 1A78     		ldrb	r2, [r3, #0]
 1516 0032 6FF34102 		bfc	r2, #1, #1
 1517 0036 1A70     		strb	r2, [r3, #0]
 840:../Sources/USB.c ****    epHardwareState[1].rxOdd = 0;
 1518              		.loc 1 840 0
 1519 0038 40F20003 		movw	r3, #:lower16:epHardwareState
 1520 003c C0F20003 		movt	r3, #:upper16:epHardwareState
 1521 0040 5A78     		ldrb	r2, [r3, #1]
 1522 0042 6FF38202 		bfc	r2, #2, #1
 1523 0046 5A70     		strb	r2, [r3, #1]
 841:../Sources/USB.c ****    epHardwareState[1].txOdd = 0;
 1524              		.loc 1 841 0
 1525 0048 40F20003 		movw	r3, #:lower16:epHardwareState
 1526 004c C0F20003 		movt	r3, #:upper16:epHardwareState
 1527 0050 5A78     		ldrb	r2, [r3, #1]
 1528 0052 6FF34102 		bfc	r2, #1, #1
 1529 0056 5A70     		strb	r2, [r3, #1]
 842:../Sources/USB.c ****    epHardwareState[2].rxOdd = 0;
 1530              		.loc 1 842 0
 1531 0058 40F20003 		movw	r3, #:lower16:epHardwareState
 1532 005c C0F20003 		movt	r3, #:upper16:epHardwareState
 1533 0060 9A78     		ldrb	r2, [r3, #2]
 1534 0062 6FF38202 		bfc	r2, #2, #1
 1535 0066 9A70     		strb	r2, [r3, #2]
 843:../Sources/USB.c ****    epHardwareState[2].txOdd = 0;
 1536              		.loc 1 843 0
 1537 0068 40F20003 		movw	r3, #:lower16:epHardwareState
 1538 006c C0F20003 		movt	r3, #:upper16:epHardwareState
 1539 0070 9A78     		ldrb	r2, [r3, #2]
 1540 0072 6FF34102 		bfc	r2, #1, #1
 1541 0076 9A70     		strb	r2, [r3, #2]
 844:../Sources/USB.c **** #if (HW_CAPABILITY&CAP_CDC)
 845:../Sources/USB.c ****    epHardwareState[3].rxOdd = 0;
 846:../Sources/USB.c ****    epHardwareState[3].txOdd = 0;
 847:../Sources/USB.c ****    epHardwareState[4].rxOdd = 0;
 848:../Sources/USB.c ****    epHardwareState[4].txOdd = 0;
 849:../Sources/USB.c ****    epHardwareState[5].rxOdd = 0;
 850:../Sources/USB.c ****    epHardwareState[5].txOdd = 0;
 851:../Sources/USB.c **** #endif
 852:../Sources/USB.c ****    
 853:../Sources/USB.c ****    initEndpointBuffers();
 1542              		.loc 1 853 0
 1543 0078 FFF7FEFF 		bl	initEndpointBuffers
 854:../Sources/USB.c ****    epClearStall(0);
 1544              		.loc 1 854 0
 1545 007c 4FF00000 		mov	r0, #0
 1546 0080 FFF7FEFF 		bl	epClearStall
 855:../Sources/USB.c ****    epClearStall(1);  reInit = TRUE;
 1547              		.loc 1 855 0
 1548 0084 4FF00100 		mov	r0, #1
 1549 0088 FFF7FEFF 		bl	epClearStall
 1550 008c 40F20003 		movw	r3, #:lower16:reInit
 1551 0090 C0F20003 		movt	r3, #:upper16:reInit
 1552 0094 4FF00102 		mov	r2, #1
 1553 0098 1A70     		strb	r2, [r3, #0]
 856:../Sources/USB.c ****    epClearStall(2);
 1554              		.loc 1 856 0
 1555 009a 4FF00200 		mov	r0, #2
 1556 009e FFF7FEFF 		bl	epClearStall
 857:../Sources/USB.c **** 
 858:../Sources/USB.c **** #if (HW_CAPABILITY&CAP_CDC)
 859:../Sources/USB.c ****    epClearStall(3);
 860:../Sources/USB.c ****    epClearStall(4);
 861:../Sources/USB.c ****    epClearStall(5);   
 862:../Sources/USB.c **** #endif
 863:../Sources/USB.c **** 
 864:../Sources/USB.c ****    // Set up to receive 1st SETUP packet
 865:../Sources/USB.c ****    ep0ConfigureSetupTransaction(); // re-initialise EP0 OUT // v4.7
 1557              		.loc 1 865 0
 1558 00a2 FFF7FEFF 		bl	ep0ConfigureSetupTransaction
 866:../Sources/USB.c **** 
 867:../Sources/USB.c **** #if (HW_CAPABILITY&CAP_CDC)
 868:../Sources/USB.c ****    //ToDo - check is sensible on re-init????
 869:../Sources/USB.c ****    ep3StartTxTransaction();       // Interrupt pipe IN - status
 870:../Sources/USB.c ****    ep4InitialiseBdtRx();          // Tx pipe OUT
 871:../Sources/USB.c ****    ep5StartTxTransactionIfIdle(); // Rx pipe IN
 872:../Sources/USB.c **** #endif
 873:../Sources/USB.c **** 
 874:../Sources/USB.c ****    // Clear odd/even bits & Enable Rx/Tx
 875:../Sources/USB.c ****    USB0_CTL = USB_CTL_USBENSOFEN_MASK|USB_CTL_ODDRST_MASK;
 1559              		.loc 1 875 0
 1560 00a6 4FF40053 		mov	r3, #8192
 1561 00aa C4F20703 		movt	r3, 16391
 1562 00ae 4FF00302 		mov	r2, #3
 1563 00b2 83F89420 		strb	r2, [r3, #148]
 876:../Sources/USB.c ****    USB0_CTL = USB_CTL_USBENSOFEN_MASK;
 1564              		.loc 1 876 0
 1565 00b6 4FF40053 		mov	r3, #8192
 1566 00ba C4F20703 		movt	r3, 16391
 1567 00be 4FF00102 		mov	r2, #1
 1568 00c2 83F89420 		strb	r2, [r3, #148]
 877:../Sources/USB.c **** 
 878:../Sources/USB.c ****    // Enable endpoints
 879:../Sources/USB.c ****    USB0_ENDPT0  = USB_ENDPT_EPRXEN_MASK|USB_ENDPT_EPTXEN_MASK|USB_ENDPT_EPHSHK_MASK; // Rx/Tx/SEUP
 1569              		.loc 1 879 0
 1570 00c6 4FF40053 		mov	r3, #8192
 1571 00ca C4F20703 		movt	r3, 16391
 1572 00ce 4FF00D02 		mov	r2, #13
 1573 00d2 83F8C020 		strb	r2, [r3, #192]
 880:../Sources/USB.c ****    USB0_ENDPT1  = USB_ENDPT_EPRXEN_MASK|USB_ENDPT_EPTXEN_MASK|USB_ENDPT_EPHSHK_MASK; // Tx/Rx
 1574              		.loc 1 880 0
 1575 00d6 4FF40053 		mov	r3, #8192
 1576 00da C4F20703 		movt	r3, 16391
 1577 00de 4FF00D02 		mov	r2, #13
 1578 00e2 83F8C420 		strb	r2, [r3, #196]
 881:../Sources/USB.c ****    USB0_ENDPT2  =                       USB_ENDPT_EPTXEN_MASK|USB_ENDPT_EPHSHK_MASK; // Tx
 1579              		.loc 1 881 0
 1580 00e6 4FF40053 		mov	r3, #8192
 1581 00ea C4F20703 		movt	r3, 16391
 1582 00ee 4FF00502 		mov	r2, #5
 1583 00f2 83F8C820 		strb	r2, [r3, #200]
 882:../Sources/USB.c **** #if (HW_CAPABILITY&CAP_CDC)   
 883:../Sources/USB.c ****    USB0_ENDPT3  =                       USB_ENDPT_EPTXEN_MASK|USB_ENDPT_EPHSHK_MASK; // Tx
 884:../Sources/USB.c ****    USB0_ENDPT4  = USB_ENDPT_EPRXEN_MASK|                      USB_ENDPT_EPHSHK_MASK; // Rx
 885:../Sources/USB.c ****    USB0_ENDPT5  =                       USB_ENDPT_EPTXEN_MASK|USB_ENDPT_EPHSHK_MASK; // Tx
 886:../Sources/USB.c **** #else
 887:../Sources/USB.c ****    USB0_ENDPT3 = 0;
 1584              		.loc 1 887 0
 1585 00f6 4FF40053 		mov	r3, #8192
 1586 00fa C4F20703 		movt	r3, 16391
 1587 00fe 4FF00002 		mov	r2, #0
 1588 0102 83F8CC20 		strb	r2, [r3, #204]
 888:../Sources/USB.c ****    USB0_ENDPT4 = 0;
 1589              		.loc 1 888 0
 1590 0106 4FF40053 		mov	r3, #8192
 1591 010a C4F20703 		movt	r3, 16391
 1592 010e 4FF00002 		mov	r2, #0
 1593 0112 83F8D020 		strb	r2, [r3, #208]
 889:../Sources/USB.c ****    USB0_ENDPT5 = 0;
 1594              		.loc 1 889 0
 1595 0116 4FF40053 		mov	r3, #8192
 1596 011a C4F20703 		movt	r3, 16391
 1597 011e 4FF00002 		mov	r2, #0
 1598 0122 83F8D420 		strb	r2, [r3, #212]
 890:../Sources/USB.c **** #endif
 891:../Sources/USB.c **** }
 1599              		.loc 1 891 0
 1600 0126 80BD     		pop	{r7, pc}
 1601              		.cfi_endproc
 1602              	.LFE14:
 1604              		.section	.text.receiveUSBCommand,"ax",%progbits
 1605              		.align	2
 1606              		.global	receiveUSBCommand
 1607              		.thumb
 1608              		.thumb_func
 1610              	receiveUSBCommand:
 1611              	.LFB15:
 892:../Sources/USB.c **** 
 893:../Sources/USB.c **** 
 894:../Sources/USB.c **** #if (HW_CAPABILITY&CAP_CDC)
 895:../Sources/USB.c **** //======================================================================
 896:../Sources/USB.c **** // Configure EP3 for an IN transaction [Tx, device -> host, DATA0/1]
 897:../Sources/USB.c **** //
 898:../Sources/USB.c **** static void ep3StartTxTransaction( void ) {
 899:../Sources/USB.c ****    const CDCNotification cdcNotification= {CDC_NOTIFICATION, SERIAL_STATE, 0, RT_INTERFACE, CONST_N
 900:../Sources/USB.c ****    BdtEntry *bdt;
 901:../Sources/USB.c ****    uint8_t status = cdc_getSerialState();
 902:../Sources/USB.c **** 
 903:../Sources/USB.c ****    if ((status & SERIAL_STATE_CHANGE) == 0) {
 904:../Sources/USB.c ****       epHardwareState[3].state = EPIdle; // Not busy
 905:../Sources/USB.c ****       return;
 906:../Sources/USB.c ****    }
 907:../Sources/USB.c ****    // Copy the Tx data to Tx buffer
 908:../Sources/USB.c ****    (void)memcpy(ep3DataBuffer, &cdcNotification, sizeof(cdcNotification));
 909:../Sources/USB.c ****    ep3DataBuffer[sizeof(cdcNotification)+0] = status&~SERIAL_STATE_CHANGE;
 910:../Sources/USB.c ****    ep3DataBuffer[sizeof(cdcNotification)+1] = 0;
 911:../Sources/USB.c ****    
 912:../Sources/USB.c ****    // Set up to Tx packet
 913:../Sources/USB.c ****    bdt = epHardwareState[3].txOdd?&endPointBdts[3].txOdd:&endPointBdts[3].txEven;
 914:../Sources/USB.c ****    bdt->bc = sizeof(cdcNotification)+2;
 915:../Sources/USB.c ****    if (epHardwareState[3].data0_1) {
 916:../Sources/USB.c ****       bdt->u.bits = BDTEntry_OWN_MASK|BDTEntry_DATA1_MASK|BDTEntry_DTS_MASK;
 917:../Sources/USB.c ****    }
 918:../Sources/USB.c ****    else {
 919:../Sources/USB.c ****       bdt->u.bits = BDTEntry_OWN_MASK|BDTEntry_DATA0_MASK|BDTEntry_DTS_MASK;
 920:../Sources/USB.c ****    }
 921:../Sources/USB.c ****    epHardwareState[3].state = EPLastIn;    // Sending one and only pkt
 922:../Sources/USB.c **** }
 923:../Sources/USB.c **** 
 924:../Sources/USB.c **** //======================================================================
 925:../Sources/USB.c **** // Configure the BDT for EP4 Out [Rx, device <- host, DATA0/1]
 926:../Sources/USB.c **** // CDC - OUT
 927:../Sources/USB.c **** static void ep4InitialiseBdtRx( void ) {
 928:../Sources/USB.c ****    BdtEntry *bdt;
 929:../Sources/USB.c **** 
 930:../Sources/USB.c ****    bdt = epHardwareState[4].rxOdd?&endPointBdts[4].rxOdd:&endPointBdts[4].rxEven;
 931:../Sources/USB.c **** 
 932:../Sources/USB.c ****    // Set up to Rx packet
 933:../Sources/USB.c ****    bdt->bc = ENDPT4MAXSIZE;
 934:../Sources/USB.c ****    if (epHardwareState[4].data0_1) {
 935:../Sources/USB.c ****       bdt->u.bits  = BDTEntry_OWN_MASK|BDTEntry_DATA1_MASK|BDTEntry_DTS_MASK;
 936:../Sources/USB.c ****    }
 937:../Sources/USB.c ****    else {
 938:../Sources/USB.c ****       bdt->u.bits  = BDTEntry_OWN_MASK|BDTEntry_DATA0_MASK|BDTEntry_DTS_MASK;
 939:../Sources/USB.c ****    }
 940:../Sources/USB.c **** }
 941:../Sources/USB.c **** 
 942:../Sources/USB.c **** //=========================================================================
 943:../Sources/USB.c **** // Save the data from an EP4 OUT pkt
 944:../Sources/USB.c **** // CDC - OUT
 945:../Sources/USB.c **** static void ep4SaveRxData( void ) {
 946:../Sources/USB.c **** uint8_t size; 
 947:../Sources/USB.c **** BdtEntry *bdt;
 948:../Sources/USB.c **** 
 949:../Sources/USB.c ****    // Get BDT
 950:../Sources/USB.c ****    bdt = (!epHardwareState[4].rxOdd)?&endPointBdts[4].rxOdd:&endPointBdts[4].rxEven;
 951:../Sources/USB.c ****    size = bdt->bc;
 952:../Sources/USB.c ****    (void)cdc_putTxBuffer((char*)ep4DataBuffer, size);
 953:../Sources/USB.c ****    
 954:../Sources/USB.c ****    // Toggle on successful reception
 955:../Sources/USB.c ****    epHardwareState[4].data0_1 = !epHardwareState[4].data0_1;
 956:../Sources/USB.c **** }
 957:../Sources/USB.c **** 
 958:../Sources/USB.c **** //======================================================================
 959:../Sources/USB.c **** // Configure the BDT for EP5 In [Tx, device -> host]
 960:../Sources/USB.c **** // CDC - IN
 961:../Sources/USB.c **** static void ep5InitialiseBdtTx(void) {
 962:../Sources/USB.c **** //    uint8_t controlValue;
 963:../Sources/USB.c **** //    if (epHardwareState[5].data0_1 == DATA0) {
 964:../Sources/USB.c **** //        controlValue = BDTEntry_OWN_MASK|BDTEntry_DATA0_MASK|BDTEntry_DTS_MASK;
 965:../Sources/USB.c **** //    }
 966:../Sources/USB.c **** //    else {
 967:../Sources/USB.c **** //        controlValue = BDTEntry_OWN_MASK|BDTEntry_DATA1_MASK|BDTEntry_DTS_MASK;
 968:../Sources/USB.c **** //    }
 969:../Sources/USB.c ****    // Set up to Tx packet
 970:../Sources/USB.c **** 	//ToDo Fix
 971:../Sources/USB.c ****    if (epHardwareState[5].txOdd) {
 972:../Sources/USB.c ****       // Set to write to other buffer & get count in current buffer
 973:../Sources/USB.c ****       endPointBdts[5].txOdd.bc     = cdc_setRxBuffer((char*)ep5DataBuffer0);
 974:../Sources/USB.c **** //       ep5DataBuffer1[0]       = '|';
 975:../Sources/USB.c ****       endPointBdts[5].txOdd.u.bits = BDTEntry_OWN_MASK|BDTEntry_DATA1_MASK;
 976:../Sources/USB.c ****    }
 977:../Sources/USB.c ****    else {
 978:../Sources/USB.c ****       // Set to write to other buffer & get count in current buffer
 979:../Sources/USB.c ****       endPointBdts[5].txEven.bc    = cdc_setRxBuffer((char*)ep5DataBuffer1);
 980:../Sources/USB.c **** //       ep5DataBuffer0[0]       = '^';
 981:../Sources/USB.c ****       endPointBdts[5].txEven.u.bits = BDTEntry_OWN_MASK|BDTEntry_DATA0_MASK;
 982:../Sources/USB.c ****    }
 983:../Sources/USB.c **** //   epHardwareState[5].data0_1 = !epHardwareState[5].data0_1; // Toggle data0/1
 984:../Sources/USB.c ****    epHardwareState[5].txOdd     = !epHardwareState[5].txOdd;
 985:../Sources/USB.c **** }
 986:../Sources/USB.c **** 
 987:../Sources/USB.c **** static uint8_t serialDelayCount = 0;
 988:../Sources/USB.c **** 
 989:../Sources/USB.c **** // This value controls how long the serial interface will wait before
 990:../Sources/USB.c **** // sending a buffered character. (count of SOFs ~ ms)
 991:../Sources/USB.c **** #define SERIAL_THRESHOLD (0) // ms
 992:../Sources/USB.c **** 
 993:../Sources/USB.c **** //======================================================================
 994:../Sources/USB.c **** // Configure the BDT for EP5 In [Tx, device -> host]
 995:../Sources/USB.c **** // CDC - IN
 996:../Sources/USB.c **** static void ep5StartTxTransactionIfIdle() {
 997:../Sources/USB.c ****    if ((epHardwareState[5].state == EPIdle) && (cdc_rxBufferItemCount()>0)) {
 998:../Sources/USB.c **** //#if (DEBUG&USB_PING_DEBUG)
 999:../Sources/USB.c **** //      DEBUG_PIN_PCOR = DEBUG_PIN_MASK;
1000:../Sources/USB.c **** //#endif
1001:../Sources/USB.c ****       ep5InitialiseBdtTx();
1002:../Sources/USB.c ****       epHardwareState[5].state = EPDataIn;
1003:../Sources/USB.c ****       serialDelayCount = 0;
1004:../Sources/USB.c ****    }
1005:../Sources/USB.c **** }
1006:../Sources/USB.c **** 
1007:../Sources/USB.c **** void checkUsbCdcRxData(void) {
1008:../Sources/USB.c ****     ep5StartTxTransactionIfIdle();
1009:../Sources/USB.c **** }
1010:../Sources/USB.c **** #endif
1011:../Sources/USB.c **** 
1012:../Sources/USB.c **** //======================================================================
1013:../Sources/USB.c **** //! Receive a command over EP1
1014:../Sources/USB.c **** //!
1015:../Sources/USB.c **** //! @param maxSize  = max # of bytes to receive
1016:../Sources/USB.c **** //! @param buffer   = ptr to buffer for bytes received
1017:../Sources/USB.c **** //!
1018:../Sources/USB.c **** //! @note : Doesn't return until command has been received.
1019:../Sources/USB.c **** //! @note : Format 
1020:../Sources/USB.c **** //!     - [0]    = size of command (N)
1021:../Sources/USB.c **** //!     - [1]    = command
1022:../Sources/USB.c **** //!     - [2..N] = parameters
1023:../Sources/USB.c **** //!
1024:../Sources/USB.c **** //! =======================================================
1025:../Sources/USB.c **** //! Format - a command is made up of up to 2 pkts
1026:../Sources/USB.c **** //! The size of the 1st pkt indicates if subsequent pkts 
1027:../Sources/USB.c **** //! are used.
1028:../Sources/USB.c **** //!
1029:../Sources/USB.c **** //!  1st pkt
1030:../Sources/USB.c **** //! +--------------------------+
1031:../Sources/USB.c **** //! |  Size of entire command  |  0 - size includes 2nd pkt
1032:../Sources/USB.c **** //! +--------------------------+
1033:../Sources/USB.c **** //! |  Command byte            |  1
1034:../Sources/USB.c **** //! +--------------------------+
1035:../Sources/USB.c **** //! |                          |  2... up to ENDPT1MAXSIZE-2
1036:../Sources/USB.c **** //! | //// DATA ////////////// |
1037:../Sources/USB.c **** //! |                          |
1038:../Sources/USB.c **** //! +--------------------------+
1039:../Sources/USB.c **** //!  2nd pkt (optional)
1040:../Sources/USB.c **** //! +--------------------------+
1041:../Sources/USB.c **** //! |  0                       |  0 - Ensures pkt can't be mistaken as 1st pkt 
1042:../Sources/USB.c **** //! +--------------------------+
1043:../Sources/USB.c **** //! |                          |  1... up to ENDPT1MAXSIZE-1
1044:../Sources/USB.c **** //! | //// DATA ////////////// |  
1045:../Sources/USB.c **** //! |                          |
1046:../Sources/USB.c **** //! +--------------------------+
1047:../Sources/USB.c **** void receiveUSBCommand(uint8_t maxSize, uint8_t *buffer) {
 1612              		.loc 1 1047 0
 1613              		.cfi_startproc
 1614              		@ args = 0, pretend = 0, frame = 16
 1615              		@ frame_needed = 1, uses_anonymous_args = 0
 1616 0000 80B5     		push	{r7, lr}
 1617              	.LCFI42:
 1618              		.cfi_def_cfa_offset 8
 1619              		.cfi_offset 7, -8
 1620              		.cfi_offset 14, -4
 1621 0002 84B0     		sub	sp, sp, #16
 1622              	.LCFI43:
 1623              		.cfi_def_cfa_offset 24
 1624 0004 00AF     		add	r7, sp, #0
 1625              	.LCFI44:
 1626              		.cfi_def_cfa_register 7
 1627 0006 0346     		mov	r3, r0
 1628 0008 3960     		str	r1, [r7, #0]
 1629 000a FB71     		strb	r3, [r7, #7]
1048:../Sources/USB.c **** uint8_t size;
1049:../Sources/USB.c ****    enableUSBIrq();
 1630              		.loc 1 1049 0
 1631 000c 4FF46143 		mov	r3, #57600
 1632 0010 CEF20003 		movt	r3, 57344
 1633 0014 4FF00802 		mov	r2, #8
 1634 0018 5A60     		str	r2, [r3, #4]
1050:../Sources/USB.c ****    // Size of first (command) transaction
1051:../Sources/USB.c **** //   do {
1052:../Sources/USB.c ****       size = ENDPT1MAXSIZE;   
 1635              		.loc 1 1052 0
 1636 001a 4FF04003 		mov	r3, #64
 1637 001e FB73     		strb	r3, [r7, #15]
1053:../Sources/USB.c ****       if (size > maxSize) {
 1638              		.loc 1 1053 0
 1639 0020 FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 1640 0022 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1641 0024 9A42     		cmp	r2, r3
 1642 0026 01D9     		bls	.L72
1054:../Sources/USB.c ****          size = maxSize;
 1643              		.loc 1 1054 0
 1644 0028 FB79     		ldrb	r3, [r7, #7]
 1645 002a FB73     		strb	r3, [r7, #15]
 1646              	.L72:
1055:../Sources/USB.c ****       }
1056:../Sources/USB.c ****       // Get 1st/only pkt of command
1057:../Sources/USB.c ****       reInit = FALSE;
 1647              		.loc 1 1057 0
 1648 002c 40F20003 		movw	r3, #:lower16:reInit
 1649 0030 C0F20003 		movt	r3, #:upper16:reInit
 1650 0034 4FF00002 		mov	r2, #0
 1651 0038 1A70     		strb	r2, [r3, #0]
1058:../Sources/USB.c ****       ep1StartRxTransaction( size, buffer );
 1652              		.loc 1 1058 0
 1653 003a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 1654 003c 1846     		mov	r0, r3
 1655 003e 3968     		ldr	r1, [r7, #0]
 1656 0040 FFF7FEFF 		bl	ep1StartRxTransaction
1059:../Sources/USB.c ****       while ((epHardwareState[1].state != EPComplete) && !reInit) {
 1657              		.loc 1 1059 0
 1658 0044 00E0     		b	.L73
 1659              	.L75:
1060:../Sources/USB.c ****           waitForInterrupts();
 1660              		.loc 1 1060 0
 1661              	@ 1060 "../Sources/USB.c" 1
 1662 0046 30BF     		wfi
 1663              	@ 0 "" 2
 1664              		.thumb
 1665              	.L73:
1059:../Sources/USB.c ****       while ((epHardwareState[1].state != EPComplete) && !reInit) {
 1666              		.loc 1 1059 0
 1667 0048 40F20003 		movw	r3, #:lower16:epHardwareState
 1668 004c C0F20003 		movt	r3, #:upper16:epHardwareState
 1669 0050 5B78     		ldrb	r3, [r3, #1]
 1670 0052 DBB2     		uxtb	r3, r3
 1671 0054 23F00703 		bic	r3, r3, #7
 1672 0058 DBB2     		uxtb	r3, r3
 1673 005a 402B     		cmp	r3, #64
 1674 005c 07D0     		beq	.L71
1059:../Sources/USB.c ****       while ((epHardwareState[1].state != EPComplete) && !reInit) {
 1675              		.loc 1 1059 0 is_stmt 0
 1676 005e 40F20003 		movw	r3, #:lower16:reInit
 1677 0062 C0F20003 		movt	r3, #:upper16:reInit
 1678 0066 1B78     		ldrb	r3, [r3, #0]
 1679 0068 DBB2     		uxtb	r3, r3
 1680 006a 002B     		cmp	r3, #0
 1681 006c EBD0     		beq	.L75
 1682              	.L71:
1061:../Sources/USB.c ****       }
1062:../Sources/USB.c **** //      if (reInit) {
1063:../Sources/USB.c **** //         continue;
1064:../Sources/USB.c **** //      }
1065:../Sources/USB.c **** //      // Size for entire command from 1st pkt 
1066:../Sources/USB.c **** //      size = buffer[0];  
1067:../Sources/USB.c **** //      if (size > maxSize) {
1068:../Sources/USB.c **** //         size = maxSize;
1069:../Sources/USB.c **** //      }
1070:../Sources/USB.c **** //      if (size == 0) {
1071:../Sources/USB.c **** //          // Invalid pkt - try again
1072:../Sources/USB.c **** //          // 0 indicates this is not an initial command pkt
1073:../Sources/USB.c **** //          // but part of a longer command
1074:../Sources/USB.c **** //          reInit = TRUE;
1075:../Sources/USB.c **** //          continue;
1076:../Sources/USB.c **** //      }
1077:../Sources/USB.c **** //      // Receive rest of data if present (only possibly 2 transactions total)
1078:../Sources/USB.c **** //      if (size > ep1State.dataCount) {
1079:../Sources/USB.c **** //         // Save last byte of 1st pkt as overwritten by
1080:../Sources/USB.c **** //         // second pkt (to save moving 2nd pkt when size is discarded)
1081:../Sources/USB.c **** //         uint8_t saveByteOffset = ep1State.dataCount-1;   
1082:../Sources/USB.c **** //         uint8_t saveByte       = buffer[saveByteOffset];
1083:../Sources/USB.c **** //         ep1StartRxTransaction( size-saveByteOffset, buffer+saveByteOffset );
1084:../Sources/USB.c **** //         while ((epHardwareState[1].state != EPComplete) && !reInit) {
1085:../Sources/USB.c **** //             waitForInterrupts();
1086:../Sources/USB.c **** //         }
1087:../Sources/USB.c **** //         // Check if second pkt has correct marker
1088:../Sources/USB.c **** //         if (buffer[saveByteOffset] != 0) {
1089:../Sources/USB.c **** //            // packet corrupt
1090:../Sources/USB.c **** //            reInit = TRUE;
1091:../Sources/USB.c **** //         }
1092:../Sources/USB.c **** //         // Restore saved byte
1093:../Sources/USB.c **** //         buffer[saveByteOffset] = saveByte;
1094:../Sources/USB.c **** //      }
1095:../Sources/USB.c **** //   } while (reInit);
1096:../Sources/USB.c **** }
 1683              		.loc 1 1096 0 is_stmt 1
 1684 006e 07F11007 		add	r7, r7, #16
 1685 0072 BD46     		mov	sp, r7
 1686 0074 80BD     		pop	{r7, pc}
 1687              		.cfi_endproc
 1688              	.LFE15:
 1690 0076 00BF     		.section	.text.sendUSBResponse,"ax",%progbits
 1691              		.align	2
 1692              		.global	sendUSBResponse
 1693              		.thumb
 1694              		.thumb_func
 1696              	sendUSBResponse:
 1697              	.LFB16:
1097:../Sources/USB.c **** 
1098:../Sources/USB.c **** //======================================================================
1099:../Sources/USB.c **** //! Set a command response over EP2
1100:../Sources/USB.c **** //!
1101:../Sources/USB.c **** //! @param size   = # of bytes to send
1102:../Sources/USB.c **** //! @param buffer = ptr to bytes to send
1103:../Sources/USB.c **** //!
1104:../Sources/USB.c **** //! @note : Returns before the command has been sent.
1105:../Sources/USB.c **** //!
1106:../Sources/USB.c **** //! @note : Format 
1107:../Sources/USB.c **** //!     - [0]    = response
1108:../Sources/USB.c **** //!     - [1..N] = parameters
1109:../Sources/USB.c **** //!
1110:../Sources/USB.c **** void sendUSBResponse( uint8_t size, const uint8_t *buffer) {
 1698              		.loc 1 1110 0
 1699              		.cfi_startproc
 1700              		@ args = 0, pretend = 0, frame = 8
 1701              		@ frame_needed = 1, uses_anonymous_args = 0
 1702 0000 80B5     		push	{r7, lr}
 1703              	.LCFI45:
 1704              		.cfi_def_cfa_offset 8
 1705              		.cfi_offset 7, -8
 1706              		.cfi_offset 14, -4
 1707 0002 82B0     		sub	sp, sp, #8
 1708              	.LCFI46:
 1709              		.cfi_def_cfa_offset 16
 1710 0004 00AF     		add	r7, sp, #0
 1711              	.LCFI47:
 1712              		.cfi_def_cfa_register 7
 1713 0006 0346     		mov	r3, r0
 1714 0008 3960     		str	r1, [r7, #0]
 1715 000a FB71     		strb	r3, [r7, #7]
1111:../Sources/USB.c **** //   disableUSBIrq();
1112:../Sources/USB.c **** //   commandBusyFlag = FALSE;
1113:../Sources/USB.c **** //   enableUSBIrq();
1114:../Sources/USB.c ****    while (epHardwareState[2].state != EPIdle) {
 1716              		.loc 1 1114 0
 1717 000c 00BF     		nop
 1718              	.L77:
 1719              		.loc 1 1114 0 is_stmt 0
 1720 000e 40F20003 		movw	r3, #:lower16:epHardwareState
 1721 0012 C0F20003 		movt	r3, #:upper16:epHardwareState
 1722 0016 9B78     		ldrb	r3, [r3, #2]
 1723 0018 DBB2     		uxtb	r3, r3
 1724 001a 23F00703 		bic	r3, r3, #7
 1725 001e DBB2     		uxtb	r3, r3
 1726 0020 002B     		cmp	r3, #0
 1727 0022 F4D1     		bne	.L77
1115:../Sources/USB.c ****    }
1116:../Sources/USB.c ****    ep2StartTxTransaction(size, buffer);
 1728              		.loc 1 1116 0 is_stmt 1
 1729 0024 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1730 0026 1846     		mov	r0, r3
 1731 0028 3968     		ldr	r1, [r7, #0]
 1732 002a FFF7FEFF 		bl	ep2StartTxTransaction
1117:../Sources/USB.c **** }
 1733              		.loc 1 1117 0
 1734 002e 07F10807 		add	r7, r7, #8
 1735 0032 BD46     		mov	sp, r7
 1736 0034 80BD     		pop	{r7, pc}
 1737              		.cfi_endproc
 1738              	.LFE16:
 1740 0036 00BF     		.section	.text.epStall,"ax",%progbits
 1741              		.align	2
 1742              		.thumb
 1743              		.thumb_func
 1745              	epStall:
 1746              	.LFB17:
1118:../Sources/USB.c **** 
1119:../Sources/USB.c **** //======================================================================
1120:../Sources/USB.c **** // Stall control for endpoints
1121:../Sources/USB.c **** //
1122:../Sources/USB.c **** 
1123:../Sources/USB.c **** //! Stall endpoint
1124:../Sources/USB.c **** //!
1125:../Sources/USB.c **** //! @param epNum - endpoint number
1126:../Sources/USB.c **** //!
1127:../Sources/USB.c **** static void epStall(uint8_t epNum) {
 1747              		.loc 1 1127 0
 1748              		.cfi_startproc
 1749              		@ args = 0, pretend = 0, frame = 8
 1750              		@ frame_needed = 1, uses_anonymous_args = 0
 1751              		@ link register save eliminated.
 1752 0000 80B4     		push	{r7}
 1753              	.LCFI48:
 1754              		.cfi_def_cfa_offset 4
 1755              		.cfi_offset 7, -4
 1756 0002 83B0     		sub	sp, sp, #12
 1757              	.LCFI49:
 1758              		.cfi_def_cfa_offset 16
 1759 0004 00AF     		add	r7, sp, #0
 1760              	.LCFI50:
 1761              		.cfi_def_cfa_register 7
 1762 0006 0346     		mov	r3, r0
 1763 0008 FB71     		strb	r3, [r7, #7]
1128:../Sources/USB.c **** //   bdts[epNum].rxEven.u.bits = BDTEntry_OWN_MASK|BDTEntry_STALL_MASK|BDTEntry_DTS_MASK;
1129:../Sources/USB.c **** //   bdts[epNum].rxOdd.u.bits  = BDTEntry_OWN_MASK|BDTEntry_STALL_MASK|BDTEntry_DTS_MASK;
1130:../Sources/USB.c **** //   bdts[epNum].txEven.u.bits = BDTEntry_OWN_MASK|BDTEntry_STALL_MASK|BDTEntry_DTS_MASK;
1131:../Sources/USB.c **** //   bdts[epNum].txOdd.u.bits  = BDTEntry_OWN_MASK|BDTEntry_STALL_MASK|BDTEntry_DTS_MASK;
1132:../Sources/USB.c ****    if (epNum == 0) {
 1764              		.loc 1 1132 0
 1765 000a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1766 000c 002B     		cmp	r3, #0
 1767 000e 0ED1     		bne	.L79
1133:../Sources/USB.c ****       // Stall Tx only
1134:../Sources/USB.c ****       endPointBdts[0].txEven.u.bits = BDTEntry_OWN_MASK|BDTEntry_STALL_MASK|BDTEntry_DTS_MASK;
 1768              		.loc 1 1134 0
 1769 0010 40F20003 		movw	r3, #:lower16:endPointBdts
 1770 0014 C0F20003 		movt	r3, #:upper16:endPointBdts
 1771 0018 4FF08C02 		mov	r2, #140
 1772 001c 1A74     		strb	r2, [r3, #16]
1135:../Sources/USB.c ****       endPointBdts[0].txOdd.u.bits  = BDTEntry_OWN_MASK|BDTEntry_STALL_MASK|BDTEntry_DTS_MASK;
 1773              		.loc 1 1135 0
 1774 001e 40F20003 		movw	r3, #:lower16:endPointBdts
 1775 0022 C0F20003 		movt	r3, #:upper16:endPointBdts
 1776 0026 4FF08C02 		mov	r2, #140
 1777 002a 1A76     		strb	r2, [r3, #24]
 1778 002c 29E0     		b	.L78
 1779              	.L79:
1136:../Sources/USB.c ****    }
1137:../Sources/USB.c ****    else {
1138:../Sources/USB.c ****       epHardwareState[epNum].state         = EPStall;
 1780              		.loc 1 1138 0
 1781 002e F979     		ldrb	r1, [r7, #7]	@ zero_extendqisi2
 1782 0030 40F20003 		movw	r3, #:lower16:epHardwareState
 1783 0034 C0F20003 		movt	r3, #:upper16:epHardwareState
 1784 0038 5A5C     		ldrb	r2, [r3, r1]
 1785 003a 4FF00700 		mov	r0, #7
 1786 003e 60F3C702 		bfi	r2, r0, #3, #5
 1787 0042 5A54     		strb	r2, [r3, r1]
1139:../Sources/USB.c ****       epHardwareState[epNum].data0_1       = DATA0;
 1788              		.loc 1 1139 0
 1789 0044 F979     		ldrb	r1, [r7, #7]	@ zero_extendqisi2
 1790 0046 40F20003 		movw	r3, #:lower16:epHardwareState
 1791 004a C0F20003 		movt	r3, #:upper16:epHardwareState
 1792 004e 5A5C     		ldrb	r2, [r3, r1]
 1793 0050 6FF30002 		bfc	r2, #0, #1
 1794 0054 5A54     		strb	r2, [r3, r1]
1140:../Sources/USB.c ****       USB0_ENDPT(epNum)                   |= USB_ENDPT_EPSTALL_MASK;
 1795              		.loc 1 1140 0
 1796 0056 4FF40053 		mov	r3, #8192
 1797 005a C4F20703 		movt	r3, 16391
 1798 005e F879     		ldrb	r0, [r7, #7]	@ zero_extendqisi2
 1799 0060 4FF40052 		mov	r2, #8192
 1800 0064 C4F20702 		movt	r2, 16391
 1801 0068 F979     		ldrb	r1, [r7, #7]	@ zero_extendqisi2
 1802 006a 01F13001 		add	r1, r1, #48
 1803 006e 12F82120 		ldrb	r2, [r2, r1, lsl #2]
 1804 0072 D2B2     		uxtb	r2, r2
 1805 0074 42F00202 		orr	r2, r2, #2
 1806 0078 D1B2     		uxtb	r1, r2
 1807 007a 00F13002 		add	r2, r0, #48
 1808 007e 03F82210 		strb	r1, [r3, r2, lsl #2]
 1809              	.L78:
1141:../Sources/USB.c ****    }
1142:../Sources/USB.c **** }
 1810              		.loc 1 1142 0
 1811 0082 07F10C07 		add	r7, r7, #12
 1812 0086 BD46     		mov	sp, r7
 1813 0088 80BC     		pop	{r7}
 1814 008a 7047     		bx	lr
 1815              		.cfi_endproc
 1816              	.LFE17:
 1818              		.section	.text.epClearStall,"ax",%progbits
 1819              		.align	2
 1820              		.thumb
 1821              		.thumb_func
 1823              	epClearStall:
 1824              	.LFB18:
1143:../Sources/USB.c **** 
1144:../Sources/USB.c **** //! Clear Stall on endpoint
1145:../Sources/USB.c **** //!
1146:../Sources/USB.c **** //! @param epNum - endpoint number
1147:../Sources/USB.c **** //!
1148:../Sources/USB.c **** static void epClearStall(uint8_t epNum) {
 1825              		.loc 1 1148 0
 1826              		.cfi_startproc
 1827              		@ args = 0, pretend = 0, frame = 8
 1828              		@ frame_needed = 1, uses_anonymous_args = 0
 1829              		@ link register save eliminated.
 1830 0000 80B4     		push	{r7}
 1831              	.LCFI51:
 1832              		.cfi_def_cfa_offset 4
 1833              		.cfi_offset 7, -4
 1834 0002 83B0     		sub	sp, sp, #12
 1835              	.LCFI52:
 1836              		.cfi_def_cfa_offset 16
 1837 0004 00AF     		add	r7, sp, #0
 1838              	.LCFI53:
 1839              		.cfi_def_cfa_register 7
 1840 0006 0346     		mov	r3, r0
 1841 0008 FB71     		strb	r3, [r7, #7]
1149:../Sources/USB.c ****    USB0_ENDPT(epNum)              &= ~USB_ENDPT_EPSTALL_MASK;
 1842              		.loc 1 1149 0
 1843 000a 4FF40053 		mov	r3, #8192
 1844 000e C4F20703 		movt	r3, 16391
 1845 0012 F879     		ldrb	r0, [r7, #7]	@ zero_extendqisi2
 1846 0014 4FF40052 		mov	r2, #8192
 1847 0018 C4F20702 		movt	r2, 16391
 1848 001c F979     		ldrb	r1, [r7, #7]	@ zero_extendqisi2
 1849 001e 01F13001 		add	r1, r1, #48
 1850 0022 12F82120 		ldrb	r2, [r2, r1, lsl #2]
 1851 0026 D2B2     		uxtb	r2, r2
 1852 0028 22F00202 		bic	r2, r2, #2
 1853 002c D1B2     		uxtb	r1, r2
 1854 002e 00F13002 		add	r2, r0, #48
 1855 0032 03F82210 		strb	r1, [r3, r2, lsl #2]
1150:../Sources/USB.c ****    epHardwareState[epNum].state    = EPIdle;
 1856              		.loc 1 1150 0
 1857 0036 F979     		ldrb	r1, [r7, #7]	@ zero_extendqisi2
 1858 0038 40F20003 		movw	r3, #:lower16:epHardwareState
 1859 003c C0F20003 		movt	r3, #:upper16:epHardwareState
 1860 0040 5A5C     		ldrb	r2, [r3, r1]
 1861 0042 6FF3C702 		bfc	r2, #3, #5
 1862 0046 5A54     		strb	r2, [r3, r1]
1151:../Sources/USB.c ****    epHardwareState[epNum].data0_1  = DATA0;
 1863              		.loc 1 1151 0
 1864 0048 F979     		ldrb	r1, [r7, #7]	@ zero_extendqisi2
 1865 004a 40F20003 		movw	r3, #:lower16:epHardwareState
 1866 004e C0F20003 		movt	r3, #:upper16:epHardwareState
 1867 0052 5A5C     		ldrb	r2, [r3, r1]
 1868 0054 6FF30002 		bfc	r2, #0, #1
 1869 0058 5A54     		strb	r2, [r3, r1]
1152:../Sources/USB.c **** }
 1870              		.loc 1 1152 0
 1871 005a 07F10C07 		add	r7, r7, #12
 1872 005e BD46     		mov	sp, r7
 1873 0060 80BC     		pop	{r7}
 1874 0062 7047     		bx	lr
 1875              		.cfi_endproc
 1876              	.LFE18:
 1878              		.section	.text.setUSBdefaultState,"ax",%progbits
 1879              		.align	2
 1880              		.thumb
 1881              		.thumb_func
 1883              	setUSBdefaultState:
 1884              	.LFB19:
1153:../Sources/USB.c **** 
1154:../Sources/USB.c **** //========================================================================================
1155:../Sources/USB.c **** //
1156:../Sources/USB.c **** static void setUSBdefaultState( void ) {
 1885              		.loc 1 1156 0
 1886              		.cfi_startproc
 1887              		@ args = 0, pretend = 0, frame = 0
 1888              		@ frame_needed = 1, uses_anonymous_args = 0
 1889              		@ link register save eliminated.
 1890 0000 80B4     		push	{r7}
 1891              	.LCFI54:
 1892              		.cfi_def_cfa_offset 4
 1893              		.cfi_offset 7, -4
 1894 0002 00AF     		add	r7, sp, #0
 1895              	.LCFI55:
 1896              		.cfi_def_cfa_register 7
1157:../Sources/USB.c **** //   greenLedOff();
1158:../Sources/USB.c ****    deviceState.state                = USBdefault;
 1897              		.loc 1 1158 0
 1898 0004 40F20003 		movw	r3, #:lower16:deviceState
 1899 0008 C0F20003 		movt	r3, #:upper16:deviceState
 1900 000c 1A78     		ldrb	r2, [r3, #0]
 1901 000e 4FF00201 		mov	r1, #2
 1902 0012 61F30702 		bfi	r2, r1, #0, #8
 1903 0016 1A70     		strb	r2, [r3, #0]
1159:../Sources/USB.c ****    USB0_ADDR                        = 0;
 1904              		.loc 1 1159 0
 1905 0018 4FF40053 		mov	r3, #8192
 1906 001c C4F20703 		movt	r3, 16391
 1907 0020 4FF00002 		mov	r2, #0
 1908 0024 83F89820 		strb	r2, [r3, #152]
1160:../Sources/USB.c ****    deviceState.configuration        = 0;
 1909              		.loc 1 1160 0
 1910 0028 40F20003 		movw	r3, #:lower16:deviceState
 1911 002c C0F20003 		movt	r3, #:upper16:deviceState
 1912 0030 4FF00002 		mov	r2, #0
 1913 0034 5A70     		strb	r2, [r3, #1]
1161:../Sources/USB.c ****    deviceState.interfaceAltSetting  = 0; 
 1914              		.loc 1 1161 0
 1915 0036 40F20003 		movw	r3, #:lower16:deviceState
 1916 003a C0F20003 		movt	r3, #:upper16:deviceState
 1917 003e 4FF00002 		mov	r2, #0
 1918 0042 9A70     		strb	r2, [r3, #2]
1162:../Sources/USB.c **** }
 1919              		.loc 1 1162 0
 1920 0044 BD46     		mov	sp, r7
 1921 0046 80BC     		pop	{r7}
 1922 0048 7047     		bx	lr
 1923              		.cfi_endproc
 1924              	.LFE19:
 1926              		.section	.text.setUSBaddressedState,"ax",%progbits
 1927              		.align	2
 1928              		.thumb
 1929              		.thumb_func
 1931              	setUSBaddressedState:
 1932              	.LFB20:
1163:../Sources/USB.c **** 
1164:../Sources/USB.c **** static void setUSBaddressedState( uint8_t address ) {
 1933              		.loc 1 1164 0
 1934              		.cfi_startproc
 1935              		@ args = 0, pretend = 0, frame = 8
 1936              		@ frame_needed = 1, uses_anonymous_args = 0
 1937 0000 80B5     		push	{r7, lr}
 1938              	.LCFI56:
 1939              		.cfi_def_cfa_offset 8
 1940              		.cfi_offset 7, -8
 1941              		.cfi_offset 14, -4
 1942 0002 82B0     		sub	sp, sp, #8
 1943              	.LCFI57:
 1944              		.cfi_def_cfa_offset 16
 1945 0004 00AF     		add	r7, sp, #0
 1946              	.LCFI58:
 1947              		.cfi_def_cfa_register 7
 1948 0006 0346     		mov	r3, r0
 1949 0008 FB71     		strb	r3, [r7, #7]
1165:../Sources/USB.c ****    if (address == 0) // Unaddress??
 1950              		.loc 1 1165 0
 1951 000a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1952 000c 002B     		cmp	r3, #0
 1953 000e 02D1     		bne	.L84
1166:../Sources/USB.c ****       setUSBdefaultState();
 1954              		.loc 1 1166 0
 1955 0010 FFF7FEFF 		bl	setUSBdefaultState
 1956 0014 1EE0     		b	.L83
 1957              	.L84:
1167:../Sources/USB.c ****    else {
1168:../Sources/USB.c **** //      greenLedOff();
1169:../Sources/USB.c ****       deviceState.state                = USBaddressed;
 1958              		.loc 1 1169 0
 1959 0016 40F20003 		movw	r3, #:lower16:deviceState
 1960 001a C0F20003 		movt	r3, #:upper16:deviceState
 1961 001e 1A78     		ldrb	r2, [r3, #0]
 1962 0020 4FF00301 		mov	r1, #3
 1963 0024 61F30702 		bfi	r2, r1, #0, #8
 1964 0028 1A70     		strb	r2, [r3, #0]
1170:../Sources/USB.c ****       USB0_ADDR                        = address;
 1965              		.loc 1 1170 0
 1966 002a 4FF40053 		mov	r3, #8192
 1967 002e C4F20703 		movt	r3, 16391
 1968 0032 FA79     		ldrb	r2, [r7, #7]
 1969 0034 83F89820 		strb	r2, [r3, #152]
1171:../Sources/USB.c ****       deviceState.configuration        = 0;
 1970              		.loc 1 1171 0
 1971 0038 40F20003 		movw	r3, #:lower16:deviceState
 1972 003c C0F20003 		movt	r3, #:upper16:deviceState
 1973 0040 4FF00002 		mov	r2, #0
 1974 0044 5A70     		strb	r2, [r3, #1]
1172:../Sources/USB.c ****       deviceState.interfaceAltSetting  = 0; 
 1975              		.loc 1 1172 0
 1976 0046 40F20003 		movw	r3, #:lower16:deviceState
 1977 004a C0F20003 		movt	r3, #:upper16:deviceState
 1978 004e 4FF00002 		mov	r2, #0
 1979 0052 9A70     		strb	r2, [r3, #2]
 1980              	.L83:
1173:../Sources/USB.c ****    }
1174:../Sources/USB.c **** }
 1981              		.loc 1 1174 0
 1982 0054 07F10807 		add	r7, r7, #8
 1983 0058 BD46     		mov	sp, r7
 1984 005a 80BD     		pop	{r7, pc}
 1985              		.cfi_endproc
 1986              	.LFE20:
 1988              		.section	.text.setUSBconfiguredState,"ax",%progbits
 1989              		.align	2
 1990              		.thumb
 1991              		.thumb_func
 1993              	setUSBconfiguredState:
 1994              	.LFB21:
1175:../Sources/USB.c **** 
1176:../Sources/USB.c **** static void setUSBconfiguredState( uint8_t config ){
 1995              		.loc 1 1176 0
 1996              		.cfi_startproc
 1997              		@ args = 0, pretend = 0, frame = 8
 1998              		@ frame_needed = 1, uses_anonymous_args = 0
 1999 0000 80B5     		push	{r7, lr}
 2000              	.LCFI59:
 2001              		.cfi_def_cfa_offset 8
 2002              		.cfi_offset 7, -8
 2003              		.cfi_offset 14, -4
 2004 0002 82B0     		sub	sp, sp, #8
 2005              	.LCFI60:
 2006              		.cfi_def_cfa_offset 16
 2007 0004 00AF     		add	r7, sp, #0
 2008              	.LCFI61:
 2009              		.cfi_def_cfa_register 7
 2010 0006 0346     		mov	r3, r0
 2011 0008 FB71     		strb	r3, [r7, #7]
1177:../Sources/USB.c ****    if (config == 0) // unconfigure
 2012              		.loc 1 1177 0
 2013 000a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2014 000c 002B     		cmp	r3, #0
 2015 000e 0AD1     		bne	.L87
1178:../Sources/USB.c ****       setUSBaddressedState(USB0_ADDR);
 2016              		.loc 1 1178 0
 2017 0010 4FF40053 		mov	r3, #8192
 2018 0014 C4F20703 		movt	r3, 16391
 2019 0018 93F89830 		ldrb	r3, [r3, #152]
 2020 001c DBB2     		uxtb	r3, r3
 2021 001e 1846     		mov	r0, r3
 2022 0020 FFF7FEFF 		bl	setUSBaddressedState
 2023 0024 19E0     		b	.L86
 2024              	.L87:
1179:../Sources/USB.c ****    else {
1180:../Sources/USB.c **** //      greenLedOn();
1181:../Sources/USB.c ****       deviceState.state                = USBconfigured;
 2025              		.loc 1 1181 0
 2026 0026 40F20003 		movw	r3, #:lower16:deviceState
 2027 002a C0F20003 		movt	r3, #:upper16:deviceState
 2028 002e 1A78     		ldrb	r2, [r3, #0]
 2029 0030 4FF00401 		mov	r1, #4
 2030 0034 61F30702 		bfi	r2, r1, #0, #8
 2031 0038 1A70     		strb	r2, [r3, #0]
1182:../Sources/USB.c ****       deviceState.configuration        = config;
 2032              		.loc 1 1182 0
 2033 003a 40F20003 		movw	r3, #:lower16:deviceState
 2034 003e C0F20003 		movt	r3, #:upper16:deviceState
 2035 0042 FA79     		ldrb	r2, [r7, #7]
 2036 0044 5A70     		strb	r2, [r3, #1]
1183:../Sources/USB.c ****       deviceState.interfaceAltSetting  = otherDescriptors.interfaceDescriptor0.bAlternateSetting; /
 2037              		.loc 1 1183 0
 2038 0046 40F20003 		movw	r3, #:lower16:otherDescriptors
 2039 004a C0F20003 		movt	r3, #:upper16:otherDescriptors
 2040 004e 1A7B     		ldrb	r2, [r3, #12]	@ zero_extendqisi2
 2041 0050 40F20003 		movw	r3, #:lower16:deviceState
 2042 0054 C0F20003 		movt	r3, #:upper16:deviceState
 2043 0058 9A70     		strb	r2, [r3, #2]
 2044              	.L86:
1184:../Sources/USB.c ****    }
1185:../Sources/USB.c **** }
 2045              		.loc 1 1185 0
 2046 005a 07F10807 		add	r7, r7, #8
 2047 005e BD46     		mov	sp, r7
 2048 0060 80BD     		pop	{r7, pc}
 2049              		.cfi_endproc
 2050              	.LFE21:
 2052 0062 00BF     		.section	.text.handleUSBReset,"ax",%progbits
 2053              		.align	2
 2054              		.thumb
 2055              		.thumb_func
 2057              	handleUSBReset:
 2058              	.LFB22:
1186:../Sources/USB.c **** 
1187:../Sources/USB.c **** //======================================================================
1188:../Sources/USB.c **** // (re)Initialises end-points other than EP0
1189:../Sources/USB.c **** //
1190:../Sources/USB.c **** //==================================================================
1191:../Sources/USB.c **** // Handler for USB Bus reset
1192:../Sources/USB.c **** // 
1193:../Sources/USB.c **** static void handleUSBReset(void) {
 2059              		.loc 1 1193 0
 2060              		.cfi_startproc
 2061              		@ args = 0, pretend = 0, frame = 0
 2062              		@ frame_needed = 1, uses_anonymous_args = 0
 2063 0000 80B5     		push	{r7, lr}
 2064              	.LCFI62:
 2065              		.cfi_def_cfa_offset 8
 2066              		.cfi_offset 7, -8
 2067              		.cfi_offset 14, -4
 2068 0002 00AF     		add	r7, sp, #0
 2069              	.LCFI63:
 2070              		.cfi_def_cfa_register 7
1194:../Sources/USB.c **** 
1195:../Sources/USB.c ****    USB0_ERRSTAT = 0xFF;                 // Clear USB error flags
 2071              		.loc 1 1195 0
 2072 0004 4FF40053 		mov	r3, #8192
 2073 0008 C4F20703 		movt	r3, 16391
 2074 000c 4FF0FF02 		mov	r2, #255
 2075 0010 83F88820 		strb	r2, [r3, #136]
1196:../Sources/USB.c **** 
1197:../Sources/USB.c ****    // Clear all USB interrupt flags
1198:../Sources/USB.c ****    USB0_ISTAT = USB_ISTAT_ATTACH_MASK|USB_ISTAT_ERROR_MASK|USB_ISTAT_RESUME_MASK|USB_ISTAT_SLEEP_MA
 2076              		.loc 1 1198 0
 2077 0014 4FF40053 		mov	r3, #8192
 2078 0018 C4F20703 		movt	r3, 16391
 2079 001c 4FF0FF02 		mov	r2, #255
 2080 0020 83F88020 		strb	r2, [r3, #128]
1199:../Sources/USB.c ****                 USB_ISTAT_SOFTOK_MASK|USB_ISTAT_STALL_MASK|USB_ISTAT_TOKDNE_MASK|USB_ISTAT_USBRST_M
1200:../Sources/USB.c **** 
1201:../Sources/USB.c ****    USB0_ERREN  = 0x00;                 // Disable all USB error interrupt sources
 2081              		.loc 1 1201 0
 2082 0024 4FF40053 		mov	r3, #8192
 2083 0028 C4F20703 		movt	r3, 16391
 2084 002c 4FF00002 		mov	r2, #0
 2085 0030 83F88C20 		strb	r2, [r3, #140]
1202:../Sources/USB.c **** 
1203:../Sources/USB.c ****    setUSBdefaultState();
 2086              		.loc 1 1203 0
 2087 0034 FFF7FEFF 		bl	setUSBdefaultState
1204:../Sources/USB.c **** 
1205:../Sources/USB.c ****    initialiseEndpoints();
 2088              		.loc 1 1205 0
 2089 0038 FFF7FEFF 		bl	initialiseEndpoints
1206:../Sources/USB.c ****    
1207:../Sources/USB.c ****    // Enable various interrupts
1208:../Sources/USB.c ****    USB0_INTEN  = USB_INTMASKS;
 2090              		.loc 1 1208 0
 2091 003c 4FF40053 		mov	r3, #8192
 2092 0040 C4F20703 		movt	r3, 16391
 2093 0044 4FF08D02 		mov	r2, #141
 2094 0048 83F88420 		strb	r2, [r3, #132]
1209:../Sources/USB.c **** }
 2095              		.loc 1 1209 0
 2096 004c 80BD     		pop	{r7, pc}
 2097              		.cfi_endproc
 2098              	.LFE22:
 2100 004e 00BF     		.section	.text.initUSB,"ax",%progbits
 2101              		.align	2
 2102              		.global	initUSB
 2103              		.thumb
 2104              		.thumb_func
 2106              	initUSB:
 2107              	.LFB23:
1210:../Sources/USB.c **** 
1211:../Sources/USB.c **** 
1212:../Sources/USB.c **** //======================================================================
1213:../Sources/USB.c **** //! Initialise the USB interface
1214:../Sources/USB.c **** //!
1215:../Sources/USB.c **** //! @note Assumes clock set up for USB operation (48MHz)
1216:../Sources/USB.c **** //!
1217:../Sources/USB.c **** void initUSB( void ) {
 2108              		.loc 1 1217 0
 2109              		.cfi_startproc
 2110              		@ args = 0, pretend = 0, frame = 0
 2111              		@ frame_needed = 1, uses_anonymous_args = 0
 2112 0000 80B5     		push	{r7, lr}
 2113              	.LCFI64:
 2114              		.cfi_def_cfa_offset 8
 2115              		.cfi_offset 7, -8
 2116              		.cfi_offset 14, -4
 2117 0002 00AF     		add	r7, sp, #0
 2118              	.LCFI65:
 2119              		.cfi_def_cfa_register 7
1218:../Sources/USB.c **** 
1219:../Sources/USB.c ****    // Clear USB RAM (includes BDTs)
1220:../Sources/USB.c ****    memset((uint8_t*)endPointBdts, 0, sizeof(endPointBdts));
 2120              		.loc 1 1220 0
 2121 0004 40F20000 		movw	r0, #:lower16:endPointBdts
 2122 0008 C0F20000 		movt	r0, #:upper16:endPointBdts
 2123 000c 4FF00001 		mov	r1, #0
 2124 0010 4FF40072 		mov	r2, #512
 2125 0014 FFF7FEFF 		bl	memset
1221:../Sources/USB.c **** 
1222:../Sources/USB.c ****    // Enable clock to USB Module
1223:../Sources/USB.c ****    SIM_SCGC4 |= SIM_SCGC4_USBOTG_MASK;
 2126              		.loc 1 1223 0
 2127 0018 4FF4E043 		mov	r3, #28672
 2128 001c C4F20403 		movt	r3, 16388
 2129 0020 4FF4E042 		mov	r2, #28672
 2130 0024 C4F20402 		movt	r2, 16388
 2131 0028 02F58152 		add	r2, r2, #4128
 2132 002c 02F11402 		add	r2, r2, #20
 2133 0030 1268     		ldr	r2, [r2, #0]
 2134 0032 42F48022 		orr	r2, r2, #262144
 2135 0036 03F58153 		add	r3, r3, #4128
 2136 003a 03F11403 		add	r3, r3, #20
 2137 003e 1A60     		str	r2, [r3, #0]
1224:../Sources/USB.c ****    
1225:../Sources/USB.c **** #ifdef MPU_CESR
1226:../Sources/USB.c ****    // Disable MPU
1227:../Sources/USB.c ****    MPU_CESR = 0;
1228:../Sources/USB.c **** #endif
1229:../Sources/USB.c ****    // Enable USB regulator
1230:../Sources/USB.c ****    SIM_SOPT1CFG = SIM_SOPT1CFG_URWE_MASK;
 2138              		.loc 1 1230 0
 2139 0040 4FF4E043 		mov	r3, #28672
 2140 0044 C4F20403 		movt	r3, 16388
 2141 0048 4FF08072 		mov	r2, #16777216
 2142 004c 5A60     		str	r2, [r3, #4]
1231:../Sources/USB.c ****    SIM_SOPT1 	= SIM_SOPT1_USBREGEN_MASK;
 2143              		.loc 1 1231 0
 2144 004e 4FF4E043 		mov	r3, #28672
 2145 0052 C4F20403 		movt	r3, 16388
 2146 0056 4FF00042 		mov	r2, #-2147483648
 2147 005a 1A60     		str	r2, [r3, #0]
1232:../Sources/USB.c ****     
1233:../Sources/USB.c ****    //   DEBUG_PIN_DDR = 1;
1234:../Sources/USB.c **** 
1235:../Sources/USB.c ****    // Reset USB H/W
1236:../Sources/USB.c ****    USB0_USBTRC0 = 0x40|USB_USBTRC0_USBRESET_MASK;
 2148              		.loc 1 1236 0
 2149 005c 4FF40053 		mov	r3, #8192
 2150 0060 C4F20703 		movt	r3, 16391
 2151 0064 4FF0C002 		mov	r2, #192
 2152 0068 83F80C21 		strb	r2, [r3, #268]
1237:../Sources/USB.c ****    while ((USB0_USBTRC0&USB_USBTRC0_USBRESET_MASK) != 0) {
 2153              		.loc 1 1237 0
 2154 006c 00BF     		nop
 2155              	.L91:
 2156              		.loc 1 1237 0 is_stmt 0
 2157 006e 4FF40053 		mov	r3, #8192
 2158 0072 C4F20703 		movt	r3, 16391
 2159 0076 93F80C31 		ldrb	r3, [r3, #268]
 2160 007a DBB2     		uxtb	r3, r3
 2161 007c DBB2     		uxtb	r3, r3
 2162 007e 5BB2     		sxtb	r3, r3
 2163 0080 002B     		cmp	r3, #0
 2164 0082 F4DB     		blt	.L91
1238:../Sources/USB.c ****    }
1239:../Sources/USB.c **** 
1240:../Sources/USB.c ****    USB0_USBTRC0 = 0x40;
 2165              		.loc 1 1240 0 is_stmt 1
 2166 0084 4FF40053 		mov	r3, #8192
 2167 0088 C4F20703 		movt	r3, 16391
 2168 008c 4FF04002 		mov	r2, #64
 2169 0090 83F80C21 		strb	r2, [r3, #268]
1241:../Sources/USB.c ****  
1242:../Sources/USB.c ****    // Set initial USB state
1243:../Sources/USB.c ****    setUSBdefaultState();
 2170              		.loc 1 1243 0
 2171 0094 FFF7FEFF 		bl	setUSBdefaultState
1244:../Sources/USB.c **** //   ep0State    = initialEPState;
1245:../Sources/USB.c **** 
1246:../Sources/USB.c ****    // Point USB at BDT array
1247:../Sources/USB.c ****    USB0_BDTPAGE3 = (uint8_t) (((unsigned)endPointBdts)>>24);
 2172              		.loc 1 1247 0
 2173 0098 4FF40053 		mov	r3, #8192
 2174 009c C4F20703 		movt	r3, 16391
 2175 00a0 40F20002 		movw	r2, #:lower16:endPointBdts
 2176 00a4 C0F20002 		movt	r2, #:upper16:endPointBdts
 2177 00a8 4FEA1262 		lsr	r2, r2, #24
 2178 00ac D2B2     		uxtb	r2, r2
 2179 00ae 83F8B420 		strb	r2, [r3, #180]
1248:../Sources/USB.c ****    USB0_BDTPAGE2 = (uint8_t) (((unsigned)endPointBdts)>>16);
 2180              		.loc 1 1248 0
 2181 00b2 4FF40053 		mov	r3, #8192
 2182 00b6 C4F20703 		movt	r3, 16391
 2183 00ba 40F20002 		movw	r2, #:lower16:endPointBdts
 2184 00be C0F20002 		movt	r2, #:upper16:endPointBdts
 2185 00c2 4FEA1242 		lsr	r2, r2, #16
 2186 00c6 D2B2     		uxtb	r2, r2
 2187 00c8 83F8B020 		strb	r2, [r3, #176]
1249:../Sources/USB.c ****    USB0_BDTPAGE1 = (uint8_t) (((unsigned)endPointBdts)>>8);
 2188              		.loc 1 1249 0
 2189 00cc 4FF40053 		mov	r3, #8192
 2190 00d0 C4F20703 		movt	r3, 16391
 2191 00d4 40F20002 		movw	r2, #:lower16:endPointBdts
 2192 00d8 C0F20002 		movt	r2, #:upper16:endPointBdts
 2193 00dc 4FEA1222 		lsr	r2, r2, #8
 2194 00e0 D2B2     		uxtb	r2, r2
 2195 00e2 83F89C20 		strb	r2, [r3, #156]
1250:../Sources/USB.c ****    
1251:../Sources/USB.c ****    // Weak pull downs
1252:../Sources/USB.c ****    USB0_USBCTRL = USB_USBCTRL_PDE_MASK;
 2196              		.loc 1 1252 0
 2197 00e6 4FF40053 		mov	r3, #8192
 2198 00ea C4F20703 		movt	r3, 16391
 2199 00ee 4FF04002 		mov	r2, #64
 2200 00f2 83F80021 		strb	r2, [r3, #256]
1253:../Sources/USB.c **** 
1254:../Sources/USB.c ****    // Enable Pull-up
1255:../Sources/USB.c ****    USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG_MASK;
 2201              		.loc 1 1255 0
 2202 00f6 4FF40053 		mov	r3, #8192
 2203 00fa C4F20703 		movt	r3, 16391
 2204 00fe 4FF01002 		mov	r2, #16
 2205 0102 83F80821 		strb	r2, [r3, #264]
1256:../Sources/USB.c ****    USB0_OTGCTL  = 0x00;//USB_OTGCTL_DPHIGH_MASK|USB_OTGCTL_OTGEN_MASK;
 2206              		.loc 1 1256 0
 2207 0106 4FF40053 		mov	r3, #8192
 2208 010a C4F20703 		movt	r3, 16391
 2209 010e 4FF00002 		mov	r2, #0
 2210 0112 1A77     		strb	r2, [r3, #28]
1257:../Sources/USB.c ****    
1258:../Sources/USB.c ****    USB0_OTGICR = 0x00;                  // Disable all ints
 2211              		.loc 1 1258 0
 2212 0114 4FF40053 		mov	r3, #8192
 2213 0118 C4F20703 		movt	r3, 16391
 2214 011c 4FF00002 		mov	r2, #0
 2215 0120 1A75     		strb	r2, [r3, #20]
1259:../Sources/USB.c ****    USB0_INTEN  = 0x00;                  // Disable all ints
 2216              		.loc 1 1259 0
 2217 0122 4FF40053 		mov	r3, #8192
 2218 0126 C4F20703 		movt	r3, 16391
 2219 012a 4FF00002 		mov	r2, #0
 2220 012e 83F88420 		strb	r2, [r3, #132]
1260:../Sources/USB.c ****    USB0_ERREN  = 0x00;                  // Disable all ints
 2221              		.loc 1 1260 0
 2222 0132 4FF40053 		mov	r3, #8192
 2223 0136 C4F20703 		movt	r3, 16391
 2224 013a 4FF00002 		mov	r2, #0
 2225 013e 83F88C20 		strb	r2, [r3, #140]
1261:../Sources/USB.c ****    
1262:../Sources/USB.c ****    // Clear all pending interrupts except reset.
1263:../Sources/USB.c ****    USB0_ISTAT = (USB_ISTAT_USBRST_MASK^0xFF);
 2226              		.loc 1 1263 0
 2227 0142 4FF40053 		mov	r3, #8192
 2228 0146 C4F20703 		movt	r3, 16391
 2229 014a 4FF0FE02 		mov	r2, #254
 2230 014e 83F88020 		strb	r2, [r3, #128]
1264:../Sources/USB.c ****    
1265:../Sources/USB.c ****    // Enable usb reset interrupt
1266:../Sources/USB.c ****    USB0_INTEN = USB_INTEN_USBRSTEN_MASK;
 2231              		.loc 1 1266 0
 2232 0152 4FF40053 		mov	r3, #8192
 2233 0156 C4F20703 		movt	r3, 16391
 2234 015a 4FF00102 		mov	r2, #1
 2235 015e 83F88420 		strb	r2, [r3, #132]
1267:../Sources/USB.c ****   
1268:../Sources/USB.c ****    enableUSBIrq();
 2236              		.loc 1 1268 0
 2237 0162 4FF46143 		mov	r3, #57600
 2238 0166 CEF20003 		movt	r3, 57344
 2239 016a 4FF00802 		mov	r2, #8
 2240 016e 5A60     		str	r2, [r3, #4]
1269:../Sources/USB.c **** }
 2241              		.loc 1 1269 0
 2242 0170 80BD     		pop	{r7, pc}
 2243              		.cfi_endproc
 2244              	.LFE23:
 2246 0172 00BF     		.section	.text.handleGetStatus,"ax",%progbits
 2247              		.align	2
 2248              		.thumb
 2249              		.thumb_func
 2251              	handleGetStatus:
 2252              	.LFB24:
1270:../Sources/USB.c **** 
1271:../Sources/USB.c **** //===============================================================================
1272:../Sources/USB.c **** // Get Status - Device Req 0x00
1273:../Sources/USB.c **** //       
1274:../Sources/USB.c **** static void handleGetStatus( void ) {
 2253              		.loc 1 1274 0
 2254              		.cfi_startproc
 2255              		@ args = 0, pretend = 0, frame = 8
 2256              		@ frame_needed = 1, uses_anonymous_args = 0
 2257 0000 80B5     		push	{r7, lr}
 2258              	.LCFI66:
 2259              		.cfi_def_cfa_offset 8
 2260              		.cfi_offset 7, -8
 2261              		.cfi_offset 14, -4
 2262 0002 82B0     		sub	sp, sp, #8
 2263              	.LCFI67:
 2264              		.cfi_def_cfa_offset 16
 2265 0004 00AF     		add	r7, sp, #0
 2266              	.LCFI68:
 2267              		.cfi_def_cfa_register 7
1275:../Sources/USB.c **** static const uint8_t zeroReturn[] = {0,0};
1276:../Sources/USB.c **** static const EPStatus epStatusStalled = {1,0,0};
1277:../Sources/USB.c **** static const EPStatus epStatusOK      = {0,0,0};
1278:../Sources/USB.c **** 
1279:../Sources/USB.c **** const uint8_t *dataPtr = NULL;
 2268              		.loc 1 1279 0
 2269 0006 4FF00003 		mov	r3, #0
 2270 000a 7B60     		str	r3, [r7, #4]
1280:../Sources/USB.c **** uint8_t size;
1281:../Sources/USB.c **** 
1282:../Sources/USB.c ****    //dprint("hGS()");
1283:../Sources/USB.c ****    switch(ep0SetupBuffer.bmRequestType) {
 2271              		.loc 1 1283 0
 2272 000c 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 2273 0010 C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 2274 0014 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2275 0016 812B     		cmp	r3, #129
 2276 0018 09D0     		beq	.L95
 2277 001a 822B     		cmp	r3, #130
 2278 001c 10D0     		beq	.L96
 2279 001e 802B     		cmp	r3, #128
 2280 0020 34D1     		bne	.L93
 2281              	.L94:
1284:../Sources/USB.c ****       case (EP_IN|RT_DEVICE) : // Device Status
1285:../Sources/USB.c ****          dataPtr = (uint8_t *) &deviceState.status;
 2282              		.loc 1 1285 0
 2283 0022 244B     		ldr	r3, .L103
 2284 0024 7B60     		str	r3, [r7, #4]
1286:../Sources/USB.c ****          size    = sizeof(deviceState.status);
 2285              		.loc 1 1286 0
 2286 0026 4FF00403 		mov	r3, #4
 2287 002a FB70     		strb	r3, [r7, #3]
1287:../Sources/USB.c ****          break;
 2288              		.loc 1 1287 0
 2289 002c 2EE0     		b	.L93
 2290              	.L95:
1288:../Sources/USB.c ****       case (EP_IN|RT_INTERFACE) : // Interface Status - reserved
1289:../Sources/USB.c ****          dataPtr = zeroReturn;
 2291              		.loc 1 1289 0
 2292 002e 40F20003 		movw	r3, #:lower16:zeroReturn.5478
 2293 0032 C0F20003 		movt	r3, #:upper16:zeroReturn.5478
 2294 0036 7B60     		str	r3, [r7, #4]
1290:../Sources/USB.c ****          size = sizeof(zeroReturn);
 2295              		.loc 1 1290 0
 2296 0038 4FF00203 		mov	r3, #2
 2297 003c FB70     		strb	r3, [r7, #3]
1291:../Sources/USB.c ****          break;
 2298              		.loc 1 1291 0
 2299 003e 25E0     		b	.L93
 2300              	.L96:
 2301              	.LBB2:
1292:../Sources/USB.c ****       case (EP_IN|RT_ENDPOINT) : { // Endpoint Status
1293:../Sources/USB.c ****          uint8_t epNum = ep0SetupBuffer.wIndex.word&0x07;
 2302              		.loc 1 1293 0
 2303 0040 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 2304 0044 C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 2305 0048 9B88     		ldrh	r3, [r3, #4]
 2306 004a DBB2     		uxtb	r3, r3
 2307 004c 03F00703 		and	r3, r3, #7
 2308 0050 BB70     		strb	r3, [r7, #2]
1294:../Sources/USB.c ****          if (epNum <= NUMBER_OF_EPS) {
 2309              		.loc 1 1294 0
 2310 0052 BB78     		ldrb	r3, [r7, #2]	@ zero_extendqisi2
 2311 0054 032B     		cmp	r3, #3
 2312 0056 18D8     		bhi	.L102
1295:../Sources/USB.c **** //            if (bdts[epNum].txEven.u.bits&BDTEntry_STALL_MASK)
1296:../Sources/USB.c ****               if (USB0_ENDPT(0)&USB_ENDPT_EPSTALL_MASK)
 2313              		.loc 1 1296 0
 2314 0058 4FF40053 		mov	r3, #8192
 2315 005c C4F20703 		movt	r3, 16391
 2316 0060 93F8C030 		ldrb	r3, [r3, #192]
 2317 0064 DBB2     		uxtb	r3, r3
 2318 0066 03F00203 		and	r3, r3, #2
 2319 006a 002B     		cmp	r3, #0
 2320 006c 05D0     		beq	.L98
1297:../Sources/USB.c ****                dataPtr = (uint8_t*)&epStatusStalled;
 2321              		.loc 1 1297 0
 2322 006e 40F20003 		movw	r3, #:lower16:epStatusStalled.5479
 2323 0072 C0F20003 		movt	r3, #:upper16:epStatusStalled.5479
 2324 0076 7B60     		str	r3, [r7, #4]
 2325 0078 04E0     		b	.L99
 2326              	.L98:
1298:../Sources/USB.c ****             else
1299:../Sources/USB.c ****                dataPtr = (uint8_t*)&epStatusOK;
 2327              		.loc 1 1299 0
 2328 007a 40F20003 		movw	r3, #:lower16:epStatusOK.5480
 2329 007e C0F20003 		movt	r3, #:upper16:epStatusOK.5480
 2330 0082 7B60     		str	r3, [r7, #4]
 2331              	.L99:
1300:../Sources/USB.c **** //            dataPtr = (uint8_t *) &epHardwareState[epNum].status;
1301:../Sources/USB.c ****             size = sizeof(EPStatus);
 2332              		.loc 1 1301 0
 2333 0084 4FF00403 		mov	r3, #4
 2334 0088 FB70     		strb	r3, [r7, #3]
 2335              	.L102:
 2336              	.LBE2:
1302:../Sources/USB.c ****             }
1303:../Sources/USB.c ****          }
1304:../Sources/USB.c ****          break;
 2337              		.loc 1 1304 0
 2338 008a 00BF     		nop
 2339              	.L93:
1305:../Sources/USB.c ****       }
1306:../Sources/USB.c ****    if (dataPtr != NULL)
 2340              		.loc 1 1306 0
 2341 008c 7B68     		ldr	r3, [r7, #4]
 2342 008e 002B     		cmp	r3, #0
 2343 0090 07D0     		beq	.L100
1307:../Sources/USB.c ****       ep0StartTxTransaction( size, dataPtr, DATA1 );
 2344              		.loc 1 1307 0
 2345 0092 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2346 0094 1846     		mov	r0, r3
 2347 0096 7968     		ldr	r1, [r7, #4]
 2348 0098 4FF00102 		mov	r2, #1
 2349 009c FFF7FEFF 		bl	ep0StartTxTransaction
 2350 00a0 03E0     		b	.L92
 2351              	.L100:
1308:../Sources/USB.c ****    else
1309:../Sources/USB.c ****       epStall(0);
 2352              		.loc 1 1309 0
 2353 00a2 4FF00000 		mov	r0, #0
 2354 00a6 FFF7FEFF 		bl	epStall
 2355              	.L92:
1310:../Sources/USB.c **** }    
 2356              		.loc 1 1310 0
 2357 00aa 07F10807 		add	r7, r7, #8
 2358 00ae BD46     		mov	sp, r7
 2359 00b0 80BD     		pop	{r7, pc}
 2360              	.L104:
 2361 00b2 00BF     		.align	2
 2362              	.L103:
 2363 00b4 04000000 		.word	deviceState+4
 2364              		.cfi_endproc
 2365              	.LFE24:
 2367              		.section	.text.handleClearFeature,"ax",%progbits
 2368              		.align	2
 2369              		.thumb
 2370              		.thumb_func
 2372              	handleClearFeature:
 2373              	.LFB25:
1311:../Sources/USB.c **** 
1312:../Sources/USB.c **** //===============================================================================
1313:../Sources/USB.c **** // Clear Feature - Device Req 0x01
1314:../Sources/USB.c **** //       
1315:../Sources/USB.c **** static void handleClearFeature( void ) {
 2374              		.loc 1 1315 0
 2375              		.cfi_startproc
 2376              		@ args = 0, pretend = 0, frame = 8
 2377              		@ frame_needed = 1, uses_anonymous_args = 0
 2378 0000 80B5     		push	{r7, lr}
 2379              	.LCFI69:
 2380              		.cfi_def_cfa_offset 8
 2381              		.cfi_offset 7, -8
 2382              		.cfi_offset 14, -4
 2383 0002 82B0     		sub	sp, sp, #8
 2384              	.LCFI70:
 2385              		.cfi_def_cfa_offset 16
 2386 0004 00AF     		add	r7, sp, #0
 2387              	.LCFI71:
 2388              		.cfi_def_cfa_register 7
1316:../Sources/USB.c **** int okStatus = 0;
 2389              		.loc 1 1316 0
 2390 0006 4FF00003 		mov	r3, #0
 2391 000a 7B60     		str	r3, [r7, #4]
1317:../Sources/USB.c **** 
1318:../Sources/USB.c ****    switch(ep0SetupBuffer.bmRequestType) {
 2392              		.loc 1 1318 0
 2393 000c 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 2394 0010 C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 2395 0014 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2396 0016 012B     		cmp	r3, #1
 2397 0018 39D0     		beq	.L114
 2398 001a 022B     		cmp	r3, #2
 2399 001c 1BD0     		beq	.L109
 2400 001e 002B     		cmp	r3, #0
 2401 0020 34D1     		bne	.L113
 2402              	.L107:
1319:../Sources/USB.c ****       case (RT_DEVICE) : // Device Feature
1320:../Sources/USB.c ****          if ((ep0SetupBuffer.wValue.word != DEVICE_REMOTE_WAKEUP) || // Device remote wakeup
 2403              		.loc 1 1320 0
 2404 0022 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 2405 0026 C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 2406 002a 5B88     		ldrh	r3, [r3, #2]
 2407 002c 012B     		cmp	r3, #1
 2408 002e 2FD1     		bne	.L110
1321:../Sources/USB.c ****              (ep0SetupBuffer.wIndex.word != 0))   {                  // Device index must be 0
 2409              		.loc 1 1321 0
 2410 0030 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 2411 0034 C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 2412 0038 9B88     		ldrh	r3, [r3, #4]
1320:../Sources/USB.c ****          if ((ep0SetupBuffer.wValue.word != DEVICE_REMOTE_WAKEUP) || // Device remote wakeup
 2413              		.loc 1 1320 0
 2414 003a 002B     		cmp	r3, #0
 2415 003c 28D1     		bne	.L110
1322:../Sources/USB.c ****             break;
1323:../Sources/USB.c ****             }
1324:../Sources/USB.c ****          deviceState.status.remoteWakeup = 0;
 2416              		.loc 1 1324 0
 2417 003e 40F20003 		movw	r3, #:lower16:deviceState
 2418 0042 C0F20003 		movt	r3, #:upper16:deviceState
 2419 0046 1A79     		ldrb	r2, [r3, #4]
 2420 0048 6FF34102 		bfc	r2, #1, #1
 2421 004c 1A71     		strb	r2, [r3, #4]
1325:../Sources/USB.c ****          okStatus                        = 1;
 2422              		.loc 1 1325 0
 2423 004e 4FF00103 		mov	r3, #1
 2424 0052 7B60     		str	r3, [r7, #4]
1326:../Sources/USB.c ****          break;
 2425              		.loc 1 1326 0
 2426 0054 1CE0     		b	.L110
 2427              	.L109:
 2428              	.LBB3:
1327:../Sources/USB.c **** 
1328:../Sources/USB.c ****       case (RT_INTERFACE) : // Interface Feature
1329:../Sources/USB.c ****          break;
1330:../Sources/USB.c **** 
1331:../Sources/USB.c ****       case (RT_ENDPOINT) : { // Endpoint Feature ( Out,Standard,Endpoint )
1332:../Sources/USB.c ****          uint8_t epNum = ep0SetupBuffer.wIndex.word&0x07;
 2429              		.loc 1 1332 0
 2430 0056 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 2431 005a C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 2432 005e 9B88     		ldrh	r3, [r3, #4]
 2433 0060 DBB2     		uxtb	r3, r3
 2434 0062 03F00703 		and	r3, r3, #7
 2435 0066 FB70     		strb	r3, [r7, #3]
1333:../Sources/USB.c ****          if ((ep0SetupBuffer.wValue.word != ENDPOINT_HALT) || // Not Endpoint Stall ?
 2436              		.loc 1 1333 0
 2437 0068 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 2438 006c C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 2439 0070 5B88     		ldrh	r3, [r3, #2]
 2440 0072 002B     		cmp	r3, #0
 2441 0074 0CD1     		bne	.L110
 2442              		.loc 1 1333 0 is_stmt 0
 2443 0076 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2444 0078 022B     		cmp	r3, #2
 2445 007a 09D8     		bhi	.L110
1334:../Sources/USB.c ****              (epNum >= NUMBER_OF_EPS))                        // or illegal EP# (ignores direction)
1335:../Sources/USB.c ****             break;
1336:../Sources/USB.c ****          epClearStall(epNum);
 2446              		.loc 1 1336 0 is_stmt 1
 2447 007c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2448 007e 1846     		mov	r0, r3
 2449 0080 FFF7FEFF 		bl	epClearStall
1337:../Sources/USB.c **** //         if (epNum == 1)
1338:../Sources/USB.c **** //             reInit = TRUE;
1339:../Sources/USB.c ****          okStatus = 1;
 2450              		.loc 1 1339 0
 2451 0084 4FF00103 		mov	r3, #1
 2452 0088 7B60     		str	r3, [r7, #4]
 2453              	.LBE3:
1340:../Sources/USB.c ****          }
1341:../Sources/USB.c ****          break;
 2454              		.loc 1 1341 0
 2455 008a 01E0     		b	.L110
 2456              	.L113:
1342:../Sources/USB.c **** 
1343:../Sources/USB.c ****       default : // Illegal
1344:../Sources/USB.c ****          break;
 2457              		.loc 1 1344 0
 2458 008c 00E0     		b	.L110
 2459              	.L114:
1329:../Sources/USB.c ****          break;
 2460              		.loc 1 1329 0
 2461 008e 00BF     		nop
 2462              	.L110:
1345:../Sources/USB.c ****       }
1346:../Sources/USB.c **** 
1347:../Sources/USB.c ****    if (okStatus)
 2463              		.loc 1 1347 0
 2464 0090 7B68     		ldr	r3, [r7, #4]
 2465 0092 002B     		cmp	r3, #0
 2466 0094 08D0     		beq	.L111
1348:../Sources/USB.c ****       ep0StartTxTransaction( 0, NULL, DATA1 ); // Tx empty Status packet
 2467              		.loc 1 1348 0
 2468 0096 4FF00000 		mov	r0, #0
 2469 009a 4FF00001 		mov	r1, #0
 2470 009e 4FF00102 		mov	r2, #1
 2471 00a2 FFF7FEFF 		bl	ep0StartTxTransaction
 2472 00a6 03E0     		b	.L105
 2473              	.L111:
1349:../Sources/USB.c ****    else
1350:../Sources/USB.c ****       epStall(0);
 2474              		.loc 1 1350 0
 2475 00a8 4FF00000 		mov	r0, #0
 2476 00ac FFF7FEFF 		bl	epStall
 2477              	.L105:
1351:../Sources/USB.c **** }
 2478              		.loc 1 1351 0
 2479 00b0 07F10807 		add	r7, r7, #8
 2480 00b4 BD46     		mov	sp, r7
 2481 00b6 80BD     		pop	{r7, pc}
 2482              		.cfi_endproc
 2483              	.LFE25:
 2485              		.section	.text.handleSetFeature,"ax",%progbits
 2486              		.align	2
 2487              		.thumb
 2488              		.thumb_func
 2490              	handleSetFeature:
 2491              	.LFB26:
1352:../Sources/USB.c **** 
1353:../Sources/USB.c **** //===============================================================================
1354:../Sources/USB.c **** // Set Feature - Device Req 0x03
1355:../Sources/USB.c **** //       
1356:../Sources/USB.c **** static void handleSetFeature( void ) {
 2492              		.loc 1 1356 0
 2493              		.cfi_startproc
 2494              		@ args = 0, pretend = 0, frame = 8
 2495              		@ frame_needed = 1, uses_anonymous_args = 0
 2496 0000 80B5     		push	{r7, lr}
 2497              	.LCFI72:
 2498              		.cfi_def_cfa_offset 8
 2499              		.cfi_offset 7, -8
 2500              		.cfi_offset 14, -4
 2501 0002 82B0     		sub	sp, sp, #8
 2502              	.LCFI73:
 2503              		.cfi_def_cfa_offset 16
 2504 0004 00AF     		add	r7, sp, #0
 2505              	.LCFI74:
 2506              		.cfi_def_cfa_register 7
1357:../Sources/USB.c **** int okStatus = 0;
 2507              		.loc 1 1357 0
 2508 0006 4FF00003 		mov	r3, #0
 2509 000a 7B60     		str	r3, [r7, #4]
1358:../Sources/USB.c **** 
1359:../Sources/USB.c ****    switch(ep0SetupBuffer.bmRequestType) {
 2510              		.loc 1 1359 0
 2511 000c 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 2512 0010 C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 2513 0014 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2514 0016 012B     		cmp	r3, #1
 2515 0018 39D0     		beq	.L124
 2516 001a 022B     		cmp	r3, #2
 2517 001c 1BD0     		beq	.L119
 2518 001e 002B     		cmp	r3, #0
 2519 0020 34D1     		bne	.L123
 2520              	.L117:
1360:../Sources/USB.c ****       case (RT_DEVICE) : // Device Feature
1361:../Sources/USB.c ****          if ((ep0SetupBuffer.wValue.word != DEVICE_REMOTE_WAKEUP) || // Device remote wakeup
 2521              		.loc 1 1361 0
 2522 0022 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 2523 0026 C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 2524 002a 5B88     		ldrh	r3, [r3, #2]
 2525 002c 012B     		cmp	r3, #1
 2526 002e 2FD1     		bne	.L120
1362:../Sources/USB.c ****              (ep0SetupBuffer.wIndex.word != 0)) {                    // device wIndex must be 0
 2527              		.loc 1 1362 0
 2528 0030 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 2529 0034 C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 2530 0038 9B88     		ldrh	r3, [r3, #4]
1361:../Sources/USB.c ****          if ((ep0SetupBuffer.wValue.word != DEVICE_REMOTE_WAKEUP) || // Device remote wakeup
 2531              		.loc 1 1361 0
 2532 003a 002B     		cmp	r3, #0
 2533 003c 28D1     		bne	.L120
1363:../Sources/USB.c ****             break;
1364:../Sources/USB.c ****             }
1365:../Sources/USB.c ****          deviceState.status.remoteWakeup = 1;
 2534              		.loc 1 1365 0
 2535 003e 40F20003 		movw	r3, #:lower16:deviceState
 2536 0042 C0F20003 		movt	r3, #:upper16:deviceState
 2537 0046 1A79     		ldrb	r2, [r3, #4]
 2538 0048 42F00202 		orr	r2, r2, #2
 2539 004c 1A71     		strb	r2, [r3, #4]
1366:../Sources/USB.c ****          okStatus                        = 1;
 2540              		.loc 1 1366 0
 2541 004e 4FF00103 		mov	r3, #1
 2542 0052 7B60     		str	r3, [r7, #4]
1367:../Sources/USB.c ****          break;
 2543              		.loc 1 1367 0
 2544 0054 1CE0     		b	.L120
 2545              	.L119:
 2546              	.LBB4:
1368:../Sources/USB.c **** 
1369:../Sources/USB.c ****       case (RT_INTERFACE) : // Interface Feature
1370:../Sources/USB.c ****          break;
1371:../Sources/USB.c **** 
1372:../Sources/USB.c ****       case (RT_ENDPOINT) : { // Endpoint Feature ( Out,Standard,Endpoint )
1373:../Sources/USB.c ****          uint8_t epNum = ep0SetupBuffer.wIndex.word&0x07;
 2547              		.loc 1 1373 0
 2548 0056 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 2549 005a C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 2550 005e 9B88     		ldrh	r3, [r3, #4]
 2551 0060 DBB2     		uxtb	r3, r3
 2552 0062 03F00703 		and	r3, r3, #7
 2553 0066 FB70     		strb	r3, [r7, #3]
1374:../Sources/USB.c ****          if ((ep0SetupBuffer.wValue.word != ENDPOINT_HALT) || // Not Endpoint Stall ?
 2554              		.loc 1 1374 0
 2555 0068 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 2556 006c C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 2557 0070 5B88     		ldrh	r3, [r3, #2]
 2558 0072 002B     		cmp	r3, #0
 2559 0074 0CD1     		bne	.L120
 2560              		.loc 1 1374 0 is_stmt 0
 2561 0076 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2562 0078 022B     		cmp	r3, #2
 2563 007a 09D8     		bhi	.L120
1375:../Sources/USB.c ****              (epNum >= NUMBER_OF_EPS))                        // or illegal EP# (ignores direction)
1376:../Sources/USB.c ****             break;
1377:../Sources/USB.c ****          epStall(epNum);
 2564              		.loc 1 1377 0 is_stmt 1
 2565 007c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2566 007e 1846     		mov	r0, r3
 2567 0080 FFF7FEFF 		bl	epStall
1378:../Sources/USB.c ****          okStatus = 1;
 2568              		.loc 1 1378 0
 2569 0084 4FF00103 		mov	r3, #1
 2570 0088 7B60     		str	r3, [r7, #4]
 2571              	.LBE4:
1379:../Sources/USB.c ****          }
1380:../Sources/USB.c ****          break;
 2572              		.loc 1 1380 0
 2573 008a 01E0     		b	.L120
 2574              	.L123:
1381:../Sources/USB.c **** 
1382:../Sources/USB.c ****       default : // Illegal
1383:../Sources/USB.c ****          break;
 2575              		.loc 1 1383 0
 2576 008c 00E0     		b	.L120
 2577              	.L124:
1370:../Sources/USB.c ****          break;
 2578              		.loc 1 1370 0
 2579 008e 00BF     		nop
 2580              	.L120:
1384:../Sources/USB.c ****       }
1385:../Sources/USB.c ****       
1386:../Sources/USB.c ****    if (okStatus)
 2581              		.loc 1 1386 0
 2582 0090 7B68     		ldr	r3, [r7, #4]
 2583 0092 002B     		cmp	r3, #0
 2584 0094 08D0     		beq	.L121
1387:../Sources/USB.c ****       ep0StartTxTransaction( 0, NULL, DATA1 ); // Tx empty Status packet
 2585              		.loc 1 1387 0
 2586 0096 4FF00000 		mov	r0, #0
 2587 009a 4FF00001 		mov	r1, #0
 2588 009e 4FF00102 		mov	r2, #1
 2589 00a2 FFF7FEFF 		bl	ep0StartTxTransaction
 2590 00a6 03E0     		b	.L115
 2591              	.L121:
1388:../Sources/USB.c ****    else
1389:../Sources/USB.c ****       epStall(0);
 2592              		.loc 1 1389 0
 2593 00a8 4FF00000 		mov	r0, #0
 2594 00ac FFF7FEFF 		bl	epStall
 2595              	.L115:
1390:../Sources/USB.c **** }
 2596              		.loc 1 1390 0
 2597 00b0 07F10807 		add	r7, r7, #8
 2598 00b4 BD46     		mov	sp, r7
 2599 00b6 80BD     		pop	{r7, pc}
 2600              		.cfi_endproc
 2601              	.LFE26:
 2603              		.section	.text.utf8ToStringDescriptor,"ax",%progbits
 2604              		.align	2
 2605              		.thumb
 2606              		.thumb_func
 2608              	utf8ToStringDescriptor:
 2609              	.LFB27:
1391:../Sources/USB.c **** 
1392:../Sources/USB.c **** //===============================================================================
1393:../Sources/USB.c **** //! Creates a valid string descriptor in UTF-16-LE from a limited UTF-8 string
1394:../Sources/USB.c **** //!
1395:../Sources/USB.c **** //! @param source - Zero terminated UTF-8 C string
1396:../Sources/USB.c **** //!
1397:../Sources/USB.c **** //! @param dest   - Where to place descriptor
1398:../Sources/USB.c **** //!
1399:../Sources/USB.c **** //! @note Only handles UTF-16 characters that fit in a single UTF-16 'character'.
1400:../Sources/USB.c **** //!
1401:../Sources/USB.c **** static void utf8ToStringDescriptor(const uint8_t *source, uint8_t *dest) {
 2610              		.loc 1 1401 0
 2611              		.cfi_startproc
 2612              		@ args = 0, pretend = 0, frame = 16
 2613              		@ frame_needed = 1, uses_anonymous_args = 0
 2614              		@ link register save eliminated.
 2615 0000 80B4     		push	{r7}
 2616              	.LCFI75:
 2617              		.cfi_def_cfa_offset 4
 2618              		.cfi_offset 7, -4
 2619 0002 85B0     		sub	sp, sp, #20
 2620              	.LCFI76:
 2621              		.cfi_def_cfa_offset 24
 2622 0004 00AF     		add	r7, sp, #0
 2623              	.LCFI77:
 2624              		.cfi_def_cfa_register 7
 2625 0006 7860     		str	r0, [r7, #4]
 2626 0008 3960     		str	r1, [r7, #0]
1402:../Sources/USB.c **** uint8_t *size = dest; // 1st byte is where to place descriptor size
 2627              		.loc 1 1402 0
 2628 000a 3B68     		ldr	r3, [r7, #0]
 2629 000c BB60     		str	r3, [r7, #8]
1403:../Sources/USB.c **** 
1404:../Sources/USB.c ****     *dest++ = 2;         // 1st byte = descriptor size (2 bytes so far)
 2630              		.loc 1 1404 0
 2631 000e 3B68     		ldr	r3, [r7, #0]
 2632 0010 4FF00202 		mov	r2, #2
 2633 0014 1A70     		strb	r2, [r3, #0]
 2634 0016 3B68     		ldr	r3, [r7, #0]
 2635 0018 03F10103 		add	r3, r3, #1
 2636 001c 3B60     		str	r3, [r7, #0]
1405:../Sources/USB.c ****     *dest++ = DT_STRING; // 2nd byte = DT_STRING;
 2637              		.loc 1 1405 0
 2638 001e 3B68     		ldr	r3, [r7, #0]
 2639 0020 4FF00302 		mov	r2, #3
 2640 0024 1A70     		strb	r2, [r3, #0]
 2641 0026 3B68     		ldr	r3, [r7, #0]
 2642 0028 03F10103 		add	r3, r3, #1
 2643 002c 3B60     		str	r3, [r7, #0]
1406:../Sources/USB.c ****     
1407:../Sources/USB.c ****     while (*source != '\0') {
 2644              		.loc 1 1407 0
 2645 002e 73E0     		b	.L126
 2646              	.L130:
 2647              	.LBB5:
1408:../Sources/USB.c ****        U16 utf16Char=0;
 2648              		.loc 1 1408 0
 2649 0030 4FF00003 		mov	r3, #0
 2650 0034 FB81     		strh	r3, [r7, #14]	@ movhi
1409:../Sources/USB.c ****        *size  += 2;         // Update size
 2651              		.loc 1 1409 0
 2652 0036 BB68     		ldr	r3, [r7, #8]
 2653 0038 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2654 003a 03F10203 		add	r3, r3, #2
 2655 003e DAB2     		uxtb	r2, r3
 2656 0040 BB68     		ldr	r3, [r7, #8]
 2657 0042 1A70     		strb	r2, [r3, #0]
1410:../Sources/USB.c ****        if (*source < 0x80) {  // 1-byte
 2658              		.loc 1 1410 0
 2659 0044 7B68     		ldr	r3, [r7, #4]
 2660 0046 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2661 0048 DBB2     		uxtb	r3, r3
 2662 004a 5BB2     		sxtb	r3, r3
 2663 004c 002B     		cmp	r3, #0
 2664 004e 07DB     		blt	.L127
1411:../Sources/USB.c ****           utf16Char = *source++;
 2665              		.loc 1 1411 0
 2666 0050 7B68     		ldr	r3, [r7, #4]
 2667 0052 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2668 0054 FB81     		strh	r3, [r7, #14]	@ movhi
 2669 0056 7B68     		ldr	r3, [r7, #4]
 2670 0058 03F10103 		add	r3, r3, #1
 2671 005c 7B60     		str	r3, [r7, #4]
 2672 005e 48E0     		b	.L128
 2673              	.L127:
1412:../Sources/USB.c ****        }
1413:../Sources/USB.c ****        else if ((*source &0xE0) == 0xC0){   // 2-byte
 2674              		.loc 1 1413 0
 2675 0060 7B68     		ldr	r3, [r7, #4]
 2676 0062 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2677 0064 03F0E003 		and	r3, r3, #224
 2678 0068 C02B     		cmp	r3, #192
 2679 006a 18D1     		bne	.L129
1414:../Sources/USB.c ****           utf16Char  = (0x1F&*source++)<<6; 
 2680              		.loc 1 1414 0
 2681 006c 7B68     		ldr	r3, [r7, #4]
 2682 006e 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2683 0070 03F01F03 		and	r3, r3, #31
 2684 0074 9BB2     		uxth	r3, r3
 2685 0076 4FEA8313 		lsl	r3, r3, #6
 2686 007a FB81     		strh	r3, [r7, #14]	@ movhi
 2687 007c 7B68     		ldr	r3, [r7, #4]
 2688 007e 03F10103 		add	r3, r3, #1
 2689 0082 7B60     		str	r3, [r7, #4]
1415:../Sources/USB.c ****           utf16Char += (0x3F&*source++);
 2690              		.loc 1 1415 0
 2691 0084 7B68     		ldr	r3, [r7, #4]
 2692 0086 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2693 0088 03F03F03 		and	r3, r3, #63
 2694 008c 9AB2     		uxth	r2, r3
 2695 008e FB89     		ldrh	r3, [r7, #14]	@ movhi
 2696 0090 D318     		adds	r3, r2, r3
 2697 0092 FB81     		strh	r3, [r7, #14]	@ movhi
 2698 0094 7B68     		ldr	r3, [r7, #4]
 2699 0096 03F10103 		add	r3, r3, #1
 2700 009a 7B60     		str	r3, [r7, #4]
 2701 009c 29E0     		b	.L128
 2702              	.L129:
1416:../Sources/USB.c ****        } 
1417:../Sources/USB.c ****        else if ((*source &0xF0) == 0xE0){   // 3-byte
 2703              		.loc 1 1417 0
 2704 009e 7B68     		ldr	r3, [r7, #4]
 2705 00a0 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2706 00a2 03F0F003 		and	r3, r3, #240
 2707 00a6 E02B     		cmp	r3, #224
 2708 00a8 23D1     		bne	.L128
1418:../Sources/USB.c ****           utf16Char  = (0x0F&*source++)<<12; 
 2709              		.loc 1 1418 0
 2710 00aa 7B68     		ldr	r3, [r7, #4]
 2711 00ac 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2712 00ae 4FEA0333 		lsl	r3, r3, #12
 2713 00b2 FB81     		strh	r3, [r7, #14]	@ movhi
 2714 00b4 7B68     		ldr	r3, [r7, #4]
 2715 00b6 03F10103 		add	r3, r3, #1
 2716 00ba 7B60     		str	r3, [r7, #4]
1419:../Sources/USB.c ****           utf16Char += (0x3F&*source++)<<6; 
 2717              		.loc 1 1419 0
 2718 00bc 7B68     		ldr	r3, [r7, #4]
 2719 00be 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2720 00c0 03F03F03 		and	r3, r3, #63
 2721 00c4 9BB2     		uxth	r3, r3
 2722 00c6 4FEA8313 		lsl	r3, r3, #6
 2723 00ca 9AB2     		uxth	r2, r3
 2724 00cc FB89     		ldrh	r3, [r7, #14]	@ movhi
 2725 00ce D318     		adds	r3, r2, r3
 2726 00d0 FB81     		strh	r3, [r7, #14]	@ movhi
 2727 00d2 7B68     		ldr	r3, [r7, #4]
 2728 00d4 03F10103 		add	r3, r3, #1
 2729 00d8 7B60     		str	r3, [r7, #4]
1420:../Sources/USB.c ****           utf16Char += (0x3F&*source++);
 2730              		.loc 1 1420 0
 2731 00da 7B68     		ldr	r3, [r7, #4]
 2732 00dc 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2733 00de 03F03F03 		and	r3, r3, #63
 2734 00e2 9AB2     		uxth	r2, r3
 2735 00e4 FB89     		ldrh	r3, [r7, #14]	@ movhi
 2736 00e6 D318     		adds	r3, r2, r3
 2737 00e8 FB81     		strh	r3, [r7, #14]	@ movhi
 2738 00ea 7B68     		ldr	r3, [r7, #4]
 2739 00ec 03F10103 		add	r3, r3, #1
 2740 00f0 7B60     		str	r3, [r7, #4]
 2741              	.L128:
1421:../Sources/USB.c ****        } 
1422:../Sources/USB.c ****        *dest++ = (char)utf16Char;       // Copy 16-bit UTF-16 value
 2742              		.loc 1 1422 0
 2743 00f2 FB89     		ldrh	r3, [r7, #14]	@ movhi
 2744 00f4 DAB2     		uxtb	r2, r3
 2745 00f6 3B68     		ldr	r3, [r7, #0]
 2746 00f8 1A70     		strb	r2, [r3, #0]
 2747 00fa 3B68     		ldr	r3, [r7, #0]
 2748 00fc 03F10103 		add	r3, r3, #1
 2749 0100 3B60     		str	r3, [r7, #0]
1423:../Sources/USB.c ****        *dest++ = (char)(utf16Char>>8);  // in little-endian order
 2750              		.loc 1 1423 0
 2751 0102 FB89     		ldrh	r3, [r7, #14]
 2752 0104 4FEA1323 		lsr	r3, r3, #8
 2753 0108 9BB2     		uxth	r3, r3
 2754 010a DAB2     		uxtb	r2, r3
 2755 010c 3B68     		ldr	r3, [r7, #0]
 2756 010e 1A70     		strb	r2, [r3, #0]
 2757 0110 3B68     		ldr	r3, [r7, #0]
 2758 0112 03F10103 		add	r3, r3, #1
 2759 0116 3B60     		str	r3, [r7, #0]
 2760              	.L126:
 2761              	.LBE5:
1407:../Sources/USB.c ****     while (*source != '\0') {
 2762              		.loc 1 1407 0
 2763 0118 7B68     		ldr	r3, [r7, #4]
 2764 011a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2765 011c 002B     		cmp	r3, #0
 2766 011e 87D1     		bne	.L130
1424:../Sources/USB.c ****     }
1425:../Sources/USB.c **** }
 2767              		.loc 1 1425 0
 2768 0120 07F11407 		add	r7, r7, #20
 2769 0124 BD46     		mov	sp, r7
 2770 0126 80BC     		pop	{r7}
 2771 0128 7047     		bx	lr
 2772              		.cfi_endproc
 2773              	.LFE27:
 2775 012a 00BF     		.section	.text.handleGetDescriptor,"ax",%progbits
 2776              		.align	2
 2777              		.thumb
 2778              		.thumb_func
 2780              	handleGetDescriptor:
 2781              	.LFB28:
1426:../Sources/USB.c **** 
1427:../Sources/USB.c **** //===============================================================================
1428:../Sources/USB.c **** // Get Descriptor - Device Req 0x06
1429:../Sources/USB.c **** //       
1430:../Sources/USB.c **** static void handleGetDescriptor( void ) {
 2782              		.loc 1 1430 0
 2783              		.cfi_startproc
 2784              		@ args = 0, pretend = 0, frame = 16
 2785              		@ frame_needed = 1, uses_anonymous_args = 0
 2786 0000 80B5     		push	{r7, lr}
 2787              	.LCFI78:
 2788              		.cfi_def_cfa_offset 8
 2789              		.cfi_offset 7, -8
 2790              		.cfi_offset 14, -4
 2791 0002 84B0     		sub	sp, sp, #16
 2792              	.LCFI79:
 2793              		.cfi_def_cfa_offset 24
 2794 0004 00AF     		add	r7, sp, #0
 2795              	.LCFI80:
 2796              		.cfi_def_cfa_register 7
1431:../Sources/USB.c **** int             descriptorIndex = ep0SetupBuffer.wValue.le.lo;
 2797              		.loc 1 1431 0
 2798 0006 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 2799 000a C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 2800 000e 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 2801 0010 7B60     		str	r3, [r7, #4]
1432:../Sources/USB.c **** int             dataSize = 0;
 2802              		.loc 1 1432 0
 2803 0012 4FF00003 		mov	r3, #0
 2804 0016 FB60     		str	r3, [r7, #12]
1433:../Sources/USB.c **** const uint8_t  *dataPtr = NULL;
 2805              		.loc 1 1433 0
 2806 0018 4FF00003 		mov	r3, #0
 2807 001c BB60     		str	r3, [r7, #8]
1434:../Sources/USB.c **** 
1435:../Sources/USB.c ****    if (ep0SetupBuffer.bmRequestType != (EP_IN|RT_DEVICE)) {// In,Standard,Device
 2808              		.loc 1 1435 0
 2809 001e 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 2810 0022 C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 2811 0026 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2812 0028 802B     		cmp	r3, #128
 2813 002a 04D0     		beq	.L132
1436:../Sources/USB.c ****       epStall(0);
 2814              		.loc 1 1436 0
 2815 002c 4FF00000 		mov	r0, #0
 2816 0030 FFF7FEFF 		bl	epStall
1437:../Sources/USB.c ****       return;
 2817              		.loc 1 1437 0
 2818 0034 71E0     		b	.L131
 2819              	.L132:
1438:../Sources/USB.c ****    }
1439:../Sources/USB.c ****    switch (ep0SetupBuffer.wValue.le.hi) {
 2820              		.loc 1 1439 0
 2821 0036 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 2822 003a C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 2823 003e DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 2824 0040 03F1FF33 		add	r3, r3, #-1
 2825 0044 052B     		cmp	r3, #5
 2826 0046 5BD8     		bhi	.L134
 2827 0048 01A2     		adr	r2, .L139
 2828 004a 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 2829 004e 00BF     		.align	2
 2830              	.L139:
 2831 0050 69000000 		.word	.L135+1
 2832 0054 7B000000 		.word	.L136+1
 2833 0058 AF000000 		.word	.L137+1
 2834 005c 01010000 		.word	.L134+1
 2835 0060 01010000 		.word	.L134+1
 2836 0064 A5000000 		.word	.L138+1
 2837              	.L135:
1440:../Sources/USB.c **** 
1441:../Sources/USB.c ****       case DT_DEVICE: // Get Device Desc. - 1
1442:../Sources/USB.c ****          dataPtr  = (uint8_t *) &deviceDescriptor;
 2838              		.loc 1 1442 0
 2839 0068 40F20003 		movw	r3, #:lower16:deviceDescriptor
 2840 006c C0F20003 		movt	r3, #:upper16:deviceDescriptor
 2841 0070 BB60     		str	r3, [r7, #8]
1443:../Sources/USB.c ****          dataSize = sizeof(DeviceDescriptor);
 2842              		.loc 1 1443 0
 2843 0072 4FF01203 		mov	r3, #18
 2844 0076 FB60     		str	r3, [r7, #12]
1444:../Sources/USB.c ****          break;
 2845              		.loc 1 1444 0
 2846 0078 47E0     		b	.L140
 2847              	.L136:
1445:../Sources/USB.c ****       case DT_CONFIGURATION: // Get Configuration Desc. - 2
1446:../Sources/USB.c ****          //dprint("hGDconf()\r\n");
1447:../Sources/USB.c ****          if (ep0SetupBuffer.wValue.le.lo != 0) {
 2848              		.loc 1 1447 0
 2849 007a 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 2850 007e C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 2851 0082 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 2852 0084 002B     		cmp	r3, #0
 2853 0086 04D0     		beq	.L141
1448:../Sources/USB.c ****             epStall(0);
 2854              		.loc 1 1448 0
 2855 0088 4FF00000 		mov	r0, #0
 2856 008c FFF7FEFF 		bl	epStall
1449:../Sources/USB.c ****             return;
 2857              		.loc 1 1449 0
 2858 0090 43E0     		b	.L131
 2859              	.L141:
1450:../Sources/USB.c ****          }
1451:../Sources/USB.c ****          dataPtr  = (uint8_t *) &otherDescriptors;
 2860              		.loc 1 1451 0
 2861 0092 40F20003 		movw	r3, #:lower16:otherDescriptors
 2862 0096 C0F20003 		movt	r3, #:upper16:otherDescriptors
 2863 009a BB60     		str	r3, [r7, #8]
1452:../Sources/USB.c ****          dataSize = sizeof(otherDescriptors);
 2864              		.loc 1 1452 0
 2865 009c 4FF02003 		mov	r3, #32
 2866 00a0 FB60     		str	r3, [r7, #12]
1453:../Sources/USB.c ****          break;
 2867              		.loc 1 1453 0
 2868 00a2 32E0     		b	.L140
 2869              	.L138:
1454:../Sources/USB.c ****       case DT_DEVICEQUALIFIER: // Get Device Qualifier Descr.
1455:../Sources/USB.c ****          epStall(0);
 2870              		.loc 1 1455 0
 2871 00a4 4FF00000 		mov	r0, #0
 2872 00a8 FFF7FEFF 		bl	epStall
1456:../Sources/USB.c ****          return;
 2873              		.loc 1 1456 0
 2874 00ac 35E0     		b	.L131
 2875              	.L137:
1457:../Sources/USB.c ****       case DT_STRING: // Get String Desc.- 3
1458:../Sources/USB.c **** #ifdef MS_COMPATIBLE_ID_FEATURE          
1459:../Sources/USB.c ****          if (descriptorIndex == 0xEE) {
1460:../Sources/USB.c ****              dataPtr  = OS_StringDescriptor;
1461:../Sources/USB.c ****          }
1462:../Sources/USB.c ****          else
1463:../Sources/USB.c **** #endif             
1464:../Sources/USB.c ****          if (descriptorIndex >= sizeof(stringDescriptors)/sizeof(stringDescriptors[0])) {
 2876              		.loc 1 1464 0
 2877 00ae 7B68     		ldr	r3, [r7, #4]
 2878 00b0 082B     		cmp	r3, #8
 2879 00b2 04D9     		bls	.L142
1465:../Sources/USB.c ****             epStall(0); // Illegal string index - stall
 2880              		.loc 1 1465 0
 2881 00b4 4FF00000 		mov	r0, #0
 2882 00b8 FFF7FEFF 		bl	epStall
1466:../Sources/USB.c ****             return;
 2883              		.loc 1 1466 0
 2884 00bc 2DE0     		b	.L131
 2885              	.L142:
1467:../Sources/USB.c ****          }
1468:../Sources/USB.c ****          if (descriptorIndex == 0) { // Language bytes
 2886              		.loc 1 1468 0
 2887 00be 7B68     		ldr	r3, [r7, #4]
 2888 00c0 002B     		cmp	r3, #0
 2889 00c2 06D1     		bne	.L143
1469:../Sources/USB.c ****             dataPtr  = stringDescriptors[0];
 2890              		.loc 1 1469 0
 2891 00c4 40F20003 		movw	r3, #:lower16:stringDescriptors
 2892 00c8 C0F20003 		movt	r3, #:upper16:stringDescriptors
 2893 00cc 1B68     		ldr	r3, [r3, #0]
 2894 00ce BB60     		str	r3, [r7, #8]
 2895 00d0 12E0     		b	.L144
 2896              	.L143:
1470:../Sources/USB.c ****          } 
1471:../Sources/USB.c ****          else { // Strings are stored in limited UTF-8 and need conversion
1472:../Sources/USB.c ****             dataPtr = commandBuffer;
 2897              		.loc 1 1472 0
 2898 00d2 40F20003 		movw	r3, #:lower16:commandBuffer
 2899 00d6 C0F20003 		movt	r3, #:upper16:commandBuffer
 2900 00da BB60     		str	r3, [r7, #8]
1473:../Sources/USB.c ****             utf8ToStringDescriptor(stringDescriptors[descriptorIndex], commandBuffer);
 2901              		.loc 1 1473 0
 2902 00dc 40F20003 		movw	r3, #:lower16:stringDescriptors
 2903 00e0 C0F20003 		movt	r3, #:upper16:stringDescriptors
 2904 00e4 7A68     		ldr	r2, [r7, #4]
 2905 00e6 53F82230 		ldr	r3, [r3, r2, lsl #2]
 2906 00ea 1846     		mov	r0, r3
 2907 00ec 40F20001 		movw	r1, #:lower16:commandBuffer
 2908 00f0 C0F20001 		movt	r1, #:upper16:commandBuffer
 2909 00f4 FFF7FEFF 		bl	utf8ToStringDescriptor
 2910              	.L144:
1474:../Sources/USB.c ****          }
1475:../Sources/USB.c ****          dataSize = *dataPtr;
 2911              		.loc 1 1475 0
 2912 00f8 BB68     		ldr	r3, [r7, #8]
 2913 00fa 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2914 00fc FB60     		str	r3, [r7, #12]
1476:../Sources/USB.c ****          break;
 2915              		.loc 1 1476 0
 2916 00fe 04E0     		b	.L140
 2917              	.L134:
1477:../Sources/USB.c ****       default: // shouldn't happen
1478:../Sources/USB.c ****          epStall(0);
 2918              		.loc 1 1478 0
 2919 0100 4FF00000 		mov	r0, #0
 2920 0104 FFF7FEFF 		bl	epStall
1479:../Sources/USB.c ****          return;
 2921              		.loc 1 1479 0
 2922 0108 07E0     		b	.L131
 2923              	.L140:
1480:../Sources/USB.c ****       } // switch
1481:../Sources/USB.c ****    ep0StartTxTransaction( (uint8_t)dataSize, dataPtr, DATA1 ); // Set up Tx
 2924              		.loc 1 1481 0
 2925 010a FB68     		ldr	r3, [r7, #12]
 2926 010c DBB2     		uxtb	r3, r3
 2927 010e 1846     		mov	r0, r3
 2928 0110 B968     		ldr	r1, [r7, #8]
 2929 0112 4FF00102 		mov	r2, #1
 2930 0116 FFF7FEFF 		bl	ep0StartTxTransaction
 2931              	.L131:
1482:../Sources/USB.c **** }
 2932              		.loc 1 1482 0
 2933 011a 07F11007 		add	r7, r7, #16
 2934 011e BD46     		mov	sp, r7
 2935 0120 80BD     		pop	{r7, pc}
 2936              		.cfi_endproc
 2937              	.LFE28:
 2939 0122 00BF     		.section	.text.resetDeviceCallback,"ax",%progbits
 2940              		.align	2
 2941              		.thumb
 2942              		.thumb_func
 2944              	resetDeviceCallback:
 2945              	.LFB29:
1483:../Sources/USB.c **** 
1484:../Sources/USB.c **** //===============================================================================
1485:../Sources/USB.c **** // resetDevice Callback to execute after status transaction
1486:../Sources/USB.c **** //       
1487:../Sources/USB.c **** static void resetDeviceCallback( void ) {
 2946              		.loc 1 1487 0
 2947              		.cfi_startproc
 2948              		@ args = 0, pretend = 0, frame = 0
 2949              		@ frame_needed = 1, uses_anonymous_args = 0
 2950              		@ link register save eliminated.
 2951 0000 80B4     		push	{r7}
 2952              	.LCFI81:
 2953              		.cfi_def_cfa_offset 4
 2954              		.cfi_offset 7, -4
 2955 0002 00AF     		add	r7, sp, #0
 2956              	.LCFI82:
 2957              		.cfi_def_cfa_register 7
1488:../Sources/USB.c **** //   forceICPReset();
1489:../Sources/USB.c **** }
 2958              		.loc 1 1489 0
 2959 0004 BD46     		mov	sp, r7
 2960 0006 80BC     		pop	{r7}
 2961 0008 7047     		bx	lr
 2962              		.cfi_endproc
 2963              	.LFE29:
 2965 000a 00BF     		.section	.text.setAddressCallback,"ax",%progbits
 2966              		.align	2
 2967              		.thumb
 2968              		.thumb_func
 2970              	setAddressCallback:
 2971              	.LFB30:
1490:../Sources/USB.c **** 
1491:../Sources/USB.c **** //===============================================================================
1492:../Sources/USB.c **** // SetDeviceAddress Callback to execute after status transaction
1493:../Sources/USB.c **** //       
1494:../Sources/USB.c **** static void setAddressCallback( void ) {
 2972              		.loc 1 1494 0
 2973              		.cfi_startproc
 2974              		@ args = 0, pretend = 0, frame = 0
 2975              		@ frame_needed = 1, uses_anonymous_args = 0
 2976 0000 80B5     		push	{r7, lr}
 2977              	.LCFI83:
 2978              		.cfi_def_cfa_offset 8
 2979              		.cfi_offset 7, -8
 2980              		.cfi_offset 14, -4
 2981 0002 00AF     		add	r7, sp, #0
 2982              	.LCFI84:
 2983              		.cfi_def_cfa_register 7
1495:../Sources/USB.c ****    //dprint("setACB()");
1496:../Sources/USB.c ****    if ((deviceState.state == USBdefault) && (deviceState.newUSBAddress != 0)) {
 2984              		.loc 1 1496 0
 2985 0004 40F20003 		movw	r3, #:lower16:deviceState
 2986 0008 C0F20003 		movt	r3, #:upper16:deviceState
 2987 000c 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2988 000e 022B     		cmp	r3, #2
 2989 0010 0FD1     		bne	.L147
 2990              		.loc 1 1496 0 is_stmt 0
 2991 0012 40F20003 		movw	r3, #:lower16:deviceState
 2992 0016 C0F20003 		movt	r3, #:upper16:deviceState
 2993 001a 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 2994 001c 002B     		cmp	r3, #0
 2995 001e 08D0     		beq	.L147
1497:../Sources/USB.c ****       setUSBaddressedState(deviceState.newUSBAddress);
 2996              		.loc 1 1497 0 is_stmt 1
 2997 0020 40F20003 		movw	r3, #:lower16:deviceState
 2998 0024 C0F20003 		movt	r3, #:upper16:deviceState
 2999 0028 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3000 002a 1846     		mov	r0, r3
 3001 002c FFF7FEFF 		bl	setUSBaddressedState
 3002 0030 0FE0     		b	.L146
 3003              	.L147:
1498:../Sources/USB.c ****    }
1499:../Sources/USB.c ****    else if ((deviceState.state == USBaddressed) && (deviceState.newUSBAddress == 0)) {
 3004              		.loc 1 1499 0
 3005 0032 40F20003 		movw	r3, #:lower16:deviceState
 3006 0036 C0F20003 		movt	r3, #:upper16:deviceState
 3007 003a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 3008 003c 032B     		cmp	r3, #3
 3009 003e 08D1     		bne	.L146
 3010              		.loc 1 1499 0 is_stmt 0
 3011 0040 40F20003 		movw	r3, #:lower16:deviceState
 3012 0044 C0F20003 		movt	r3, #:upper16:deviceState
 3013 0048 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 3014 004a 002B     		cmp	r3, #0
 3015 004c 01D1     		bne	.L146
1500:../Sources/USB.c ****       setUSBdefaultState();
 3016              		.loc 1 1500 0 is_stmt 1
 3017 004e FFF7FEFF 		bl	setUSBdefaultState
 3018              	.L146:
1501:../Sources/USB.c ****    }
1502:../Sources/USB.c **** }
 3019              		.loc 1 1502 0
 3020 0052 80BD     		pop	{r7, pc}
 3021              		.cfi_endproc
 3022              	.LFE30:
 3024              		.section	.text.handleSetAddress,"ax",%progbits
 3025              		.align	2
 3026              		.thumb
 3027              		.thumb_func
 3029              	handleSetAddress:
 3030              	.LFB31:
1503:../Sources/USB.c **** 
1504:../Sources/USB.c **** //===============================================================================
1505:../Sources/USB.c **** // Set device Address - Device Req 0x05
1506:../Sources/USB.c **** //       
1507:../Sources/USB.c **** static void handleSetAddress( void ) {
 3031              		.loc 1 1507 0
 3032              		.cfi_startproc
 3033              		@ args = 0, pretend = 0, frame = 0
 3034              		@ frame_needed = 1, uses_anonymous_args = 0
 3035 0000 80B5     		push	{r7, lr}
 3036              	.LCFI85:
 3037              		.cfi_def_cfa_offset 8
 3038              		.cfi_offset 7, -8
 3039              		.cfi_offset 14, -4
 3040 0002 00AF     		add	r7, sp, #0
 3041              	.LCFI86:
 3042              		.cfi_def_cfa_register 7
1508:../Sources/USB.c **** 
1509:../Sources/USB.c ****    if (ep0SetupBuffer.bmRequestType != (EP_OUT|RT_DEVICE)) {// Out,Standard,Device
 3043              		.loc 1 1509 0
 3044 0004 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 3045 0008 C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 3046 000c 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 3047 000e 002B     		cmp	r3, #0
 3048 0010 04D0     		beq	.L150
1510:../Sources/USB.c ****       //dprint("hSA():inv. bmR");
1511:../Sources/USB.c ****       epStall(0); // Illegal format - stall ep0
 3049              		.loc 1 1511 0
 3050 0012 4FF00000 		mov	r0, #0
 3051 0016 FFF7FEFF 		bl	epStall
1512:../Sources/USB.c ****       return;
 3052              		.loc 1 1512 0
 3053 001a 1AE0     		b	.L149
 3054              	.L150:
1513:../Sources/USB.c ****    }
1514:../Sources/USB.c ****    // Save address for change after status transaction
1515:../Sources/USB.c ****    deviceState.newUSBAddress  = ep0SetupBuffer.wValue.le.lo; 
 3055              		.loc 1 1515 0
 3056 001c 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 3057 0020 C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 3058 0024 9A78     		ldrb	r2, [r3, #2]	@ zero_extendqisi2
 3059 0026 40F20003 		movw	r3, #:lower16:deviceState
 3060 002a C0F20003 		movt	r3, #:upper16:deviceState
 3061 002e 1A72     		strb	r2, [r3, #8]
1516:../Sources/USB.c ****    ep0State.callback          = setAddressCallback;
 3062              		.loc 1 1516 0
 3063 0030 40F20003 		movw	r3, #:lower16:ep0State
 3064 0034 C0F20003 		movt	r3, #:upper16:ep0State
 3065 0038 40F20002 		movw	r2, #:lower16:setAddressCallback
 3066 003c C0F20002 		movt	r2, #:upper16:setAddressCallback
 3067 0040 9A60     		str	r2, [r3, #8]
1517:../Sources/USB.c ****    
1518:../Sources/USB.c ****    ep0StartTxTransaction( 0, NULL, DATA1 ); // Tx empty Status packet
 3068              		.loc 1 1518 0
 3069 0042 4FF00000 		mov	r0, #0
 3070 0046 4FF00001 		mov	r1, #0
 3071 004a 4FF00102 		mov	r2, #1
 3072 004e FFF7FEFF 		bl	ep0StartTxTransaction
 3073              	.L149:
1519:../Sources/USB.c **** }
 3074              		.loc 1 1519 0
 3075 0052 80BD     		pop	{r7, pc}
 3076              		.cfi_endproc
 3077              	.LFE31:
 3079              		.section	.text.handleGetConfiguration,"ax",%progbits
 3080              		.align	2
 3081              		.thumb
 3082              		.thumb_func
 3084              	handleGetConfiguration:
 3085              	.LFB32:
1520:../Sources/USB.c **** 
1521:../Sources/USB.c **** //===============================================================================
1522:../Sources/USB.c **** // Get Configuration - Device Req 0x08
1523:../Sources/USB.c **** //       
1524:../Sources/USB.c **** static void handleGetConfiguration( void ) {
 3086              		.loc 1 1524 0
 3087              		.cfi_startproc
 3088              		@ args = 0, pretend = 0, frame = 0
 3089              		@ frame_needed = 1, uses_anonymous_args = 0
 3090 0000 80B5     		push	{r7, lr}
 3091              	.LCFI87:
 3092              		.cfi_def_cfa_offset 8
 3093              		.cfi_offset 7, -8
 3094              		.cfi_offset 14, -4
 3095 0002 00AF     		add	r7, sp, #0
 3096              	.LCFI88:
 3097              		.cfi_def_cfa_register 7
1525:../Sources/USB.c **** 
1526:../Sources/USB.c ****    ep0StartTxTransaction( 1, (uint8_t *) &deviceState.configuration, DATA1 );
 3098              		.loc 1 1526 0
 3099 0004 4FF00100 		mov	r0, #1
 3100 0008 0249     		ldr	r1, .L153
 3101 000a 4FF00102 		mov	r2, #1
 3102 000e FFF7FEFF 		bl	ep0StartTxTransaction
1527:../Sources/USB.c **** }
 3103              		.loc 1 1527 0
 3104 0012 80BD     		pop	{r7, pc}
 3105              	.L154:
 3106              		.align	2
 3107              	.L153:
 3108 0014 01000000 		.word	deviceState+1
 3109              		.cfi_endproc
 3110              	.LFE32:
 3112              		.section	.text.handleSetConfiguration,"ax",%progbits
 3113              		.align	2
 3114              		.thumb
 3115              		.thumb_func
 3117              	handleSetConfiguration:
 3118              	.LFB33:
1528:../Sources/USB.c **** 
1529:../Sources/USB.c **** //===============================================================================
1530:../Sources/USB.c **** // Set Configuration - Device Req 0x09
1531:../Sources/USB.c **** //       
1532:../Sources/USB.c **** static void handleSetConfiguration( void ) {
 3119              		.loc 1 1532 0
 3120              		.cfi_startproc
 3121              		@ args = 0, pretend = 0, frame = 0
 3122              		@ frame_needed = 1, uses_anonymous_args = 0
 3123 0000 80B5     		push	{r7, lr}
 3124              	.LCFI89:
 3125              		.cfi_def_cfa_offset 8
 3126              		.cfi_offset 7, -8
 3127              		.cfi_offset 14, -4
 3128 0002 00AF     		add	r7, sp, #0
 3129              	.LCFI90:
 3130              		.cfi_def_cfa_register 7
1533:../Sources/USB.c **** 
1534:../Sources/USB.c ****    //dprint("hSC()\r\n");
1535:../Sources/USB.c ****    if ((ep0SetupBuffer.bmRequestType != (EP_OUT|RT_DEVICE)) || // Out,Standard,Device
 3131              		.loc 1 1535 0
 3132 0004 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 3133 0008 C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 3134 000c 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 3135 000e 002B     		cmp	r3, #0
 3136 0010 12D1     		bne	.L156
1536:../Sources/USB.c ****        ((ep0SetupBuffer.wValue.le.lo != 0) &&       // Only supports 0=> unconfigure, 1=> only vali
 3137              		.loc 1 1536 0
 3138 0012 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 3139 0016 C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 3140 001a 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
1535:../Sources/USB.c ****    if ((ep0SetupBuffer.bmRequestType != (EP_OUT|RT_DEVICE)) || // Out,Standard,Device
 3141              		.loc 1 1535 0
 3142 001c 002B     		cmp	r3, #0
 3143 001e 10D0     		beq	.L157
1537:../Sources/USB.c ****         (ep0SetupBuffer.wValue.le.lo != otherDescriptors.configDescriptor.bConfigurationValue))) { 
 3144              		.loc 1 1537 0
 3145 0020 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 3146 0024 C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 3147 0028 9A78     		ldrb	r2, [r3, #2]	@ zero_extendqisi2
 3148 002a 40F20003 		movw	r3, #:lower16:otherDescriptors
 3149 002e C0F20003 		movt	r3, #:upper16:otherDescriptors
 3150 0032 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
1536:../Sources/USB.c ****        ((ep0SetupBuffer.wValue.le.lo != 0) &&       // Only supports 0=> unconfigure, 1=> only vali
 3151              		.loc 1 1536 0
 3152 0034 9A42     		cmp	r2, r3
 3153 0036 04D0     		beq	.L157
 3154              	.L156:
1538:../Sources/USB.c ****       epStall(0);
 3155              		.loc 1 1538 0
 3156 0038 4FF00000 		mov	r0, #0
 3157 003c FFF7FEFF 		bl	epStall
1539:../Sources/USB.c ****       return;
 3158              		.loc 1 1539 0
 3159 0040 11E0     		b	.L155
 3160              	.L157:
1540:../Sources/USB.c ****    }
1541:../Sources/USB.c ****    setUSBconfiguredState(ep0SetupBuffer.wValue.le.lo);
 3161              		.loc 1 1541 0
 3162 0042 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 3163 0046 C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 3164 004a 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 3165 004c 1846     		mov	r0, r3
 3166 004e FFF7FEFF 		bl	setUSBconfiguredState
1542:../Sources/USB.c **** 
1543:../Sources/USB.c ****    ep1InitialiseBdtRx();
 3167              		.loc 1 1543 0
 3168 0052 FFF7FEFF 		bl	ep1InitialiseBdtRx
1544:../Sources/USB.c **** //   initialiseEndpoints();
1545:../Sources/USB.c **** 
1546:../Sources/USB.c ****    ep0StartTxTransaction( 0, NULL, DATA1 ); // Tx empty Status packet
 3169              		.loc 1 1546 0
 3170 0056 4FF00000 		mov	r0, #0
 3171 005a 4FF00001 		mov	r1, #0
 3172 005e 4FF00102 		mov	r2, #1
 3173 0062 FFF7FEFF 		bl	ep0StartTxTransaction
 3174              	.L155:
1547:../Sources/USB.c **** }
 3175              		.loc 1 1547 0
 3176 0066 80BD     		pop	{r7, pc}
 3177              		.cfi_endproc
 3178              	.LFE33:
 3180              		.section	.text.handleGetInterface,"ax",%progbits
 3181              		.align	2
 3182              		.thumb
 3183              		.thumb_func
 3185              	handleGetInterface:
 3186              	.LFB34:
1548:../Sources/USB.c **** 
1549:../Sources/USB.c **** //===============================================================================
1550:../Sources/USB.c **** // Get interface - Device Req 0x0A
1551:../Sources/USB.c **** //       
1552:../Sources/USB.c **** static void handleGetInterface( void ) {
 3187              		.loc 1 1552 0
 3188              		.cfi_startproc
 3189              		@ args = 0, pretend = 0, frame = 8
 3190              		@ frame_needed = 1, uses_anonymous_args = 0
 3191 0000 80B5     		push	{r7, lr}
 3192              	.LCFI91:
 3193              		.cfi_def_cfa_offset 8
 3194              		.cfi_offset 7, -8
 3195              		.cfi_offset 14, -4
 3196 0002 82B0     		sub	sp, sp, #8
 3197              	.LCFI92:
 3198              		.cfi_def_cfa_offset 16
 3199 0004 00AF     		add	r7, sp, #0
 3200              	.LCFI93:
 3201              		.cfi_def_cfa_register 7
1553:../Sources/USB.c **** uint8_t interfaceBuffer;
1554:../Sources/USB.c **** 
1555:../Sources/USB.c ****    if ((ep0SetupBuffer.bmRequestType != (EP_IN|RT_INTERFACE)) || // NOT In,Standard,Interface
 3202              		.loc 1 1555 0
 3203 0006 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 3204 000a C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 3205 000e 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 3206 0010 812B     		cmp	r3, #129
 3207 0012 0DD1     		bne	.L160
1556:../Sources/USB.c ****        (ep0SetupBuffer.wLength.word != 1) ||                     // NOT correct length
 3208              		.loc 1 1556 0
 3209 0014 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 3210 0018 C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 3211 001c DB88     		ldrh	r3, [r3, #6]
1555:../Sources/USB.c ****    if ((ep0SetupBuffer.bmRequestType != (EP_IN|RT_INTERFACE)) || // NOT In,Standard,Interface
 3212              		.loc 1 1555 0
 3213 001e 012B     		cmp	r3, #1
 3214 0020 06D1     		bne	.L160
1557:../Sources/USB.c ****        (deviceState.state != USBaddressed)) {                    // NOT in addressed state
 3215              		.loc 1 1557 0
 3216 0022 40F20003 		movw	r3, #:lower16:deviceState
 3217 0026 C0F20003 		movt	r3, #:upper16:deviceState
 3218 002a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
1556:../Sources/USB.c ****        (ep0SetupBuffer.wLength.word != 1) ||                     // NOT correct length
 3219              		.loc 1 1556 0
 3220 002c 032B     		cmp	r3, #3
 3221 002e 04D0     		beq	.L161
 3222              	.L160:
1558:../Sources/USB.c ****       epStall(0); // Error
 3223              		.loc 1 1558 0
 3224 0030 4FF00000 		mov	r0, #0
 3225 0034 FFF7FEFF 		bl	epStall
 3226 0038 1FE0     		b	.L159
 3227              	.L161:
1559:../Sources/USB.c ****       return;
1560:../Sources/USB.c ****    }
1561:../Sources/USB.c ****    // Only support one interface
1562:../Sources/USB.c ****    if (ep0SetupBuffer.wValue.word != otherDescriptors.interfaceDescriptor0.bInterfaceNumber) {
 3228              		.loc 1 1562 0
 3229 003a 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 3230 003e C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 3231 0042 5A88     		ldrh	r2, [r3, #2]
 3232 0044 40F20003 		movw	r3, #:lower16:otherDescriptors
 3233 0048 C0F20003 		movt	r3, #:upper16:otherDescriptors
 3234 004c DB7A     		ldrb	r3, [r3, #11]	@ zero_extendqisi2
 3235 004e 9A42     		cmp	r2, r3
 3236 0050 04D0     		beq	.L163
1563:../Sources/USB.c ****       epStall(0); // Error
 3237              		.loc 1 1563 0
 3238 0052 4FF00000 		mov	r0, #0
 3239 0056 FFF7FEFF 		bl	epStall
 3240 005a 0EE0     		b	.L159
 3241              	.L163:
1564:../Sources/USB.c ****       return;
1565:../Sources/USB.c ****    }
1566:../Sources/USB.c ****    interfaceBuffer = (uint8_t)deviceState.interfaceAltSetting;  // set up buffer for transfer
 3242              		.loc 1 1566 0
 3243 005c 40F20003 		movw	r3, #:lower16:deviceState
 3244 0060 C0F20003 		movt	r3, #:upper16:deviceState
 3245 0064 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 3246 0066 FB71     		strb	r3, [r7, #7]
1567:../Sources/USB.c ****    ep0StartTxTransaction( sizeof(interfaceBuffer), (uint8_t *) &interfaceBuffer, DATA1 ); // Send p
 3247              		.loc 1 1567 0
 3248 0068 07F10703 		add	r3, r7, #7
 3249 006c 4FF00100 		mov	r0, #1
 3250 0070 1946     		mov	r1, r3
 3251 0072 4FF00102 		mov	r2, #1
 3252 0076 FFF7FEFF 		bl	ep0StartTxTransaction
 3253              	.L159:
1568:../Sources/USB.c **** }
 3254              		.loc 1 1568 0
 3255 007a 07F10807 		add	r7, r7, #8
 3256 007e BD46     		mov	sp, r7
 3257 0080 80BD     		pop	{r7, pc}
 3258              		.cfi_endproc
 3259              	.LFE34:
 3261 0082 00BF     		.section	.text.handleUnexpected,"ax",%progbits
 3262              		.align	2
 3263              		.thumb
 3264              		.thumb_func
 3266              	handleUnexpected:
 3267              	.LFB35:
1569:../Sources/USB.c **** 
1570:../Sources/USB.c **** #if (HW_CAPABILITY&CAP_CDC)
1571:../Sources/USB.c **** //static void handleGetEncapsulatedCommand() {
1572:../Sources/USB.c **** //   static const char dummy[] = "Hello there";
1573:../Sources/USB.c **** //   
1574:../Sources/USB.c **** //   ep0StartInTransaction( sizeof(dummy), dummy, DATA1 ); // Send packet
1575:../Sources/USB.c **** //}
1576:../Sources/USB.c **** //
1577:../Sources/USB.c **** //static void handleSendEncapsulatedCommand() {
1578:../Sources/USB.c **** //
1579:../Sources/USB.c **** //   ep0StartInTransaction( 0, NULL, DATA1 ); // Tx empty Status packet
1580:../Sources/USB.c **** //}
1581:../Sources/USB.c **** 
1582:../Sources/USB.c **** static void handleGetLineCoding() {
1583:../Sources/USB.c **** 
1584:../Sources/USB.c ****    ep0StartTxTransaction( sizeof(LineCodingStructure), (const uint8_t*)cdc_getLineCoding(), DATA1 )
1585:../Sources/USB.c **** }
1586:../Sources/USB.c **** 
1587:../Sources/USB.c **** static void setLineCodingCallback( void ) {
1588:../Sources/USB.c ****    cdc_setLineCoding((LineCodingStructure * const)&ep0OutDataBuffer);
1589:../Sources/USB.c **** }
1590:../Sources/USB.c **** 
1591:../Sources/USB.c **** static void handleSetLineCoding() {
1592:../Sources/USB.c **** 
1593:../Sources/USB.c ****    ep0State.callback          = setLineCodingCallback;
1594:../Sources/USB.c ****    // Don't use buffer - this requires sizeof(LineCodingStructure) < ENDPT0MAXSIZE
1595:../Sources/USB.c ****    ep0StartRxTransaction(sizeof(LineCodingStructure), NULL, DATA1); 
1596:../Sources/USB.c **** }
1597:../Sources/USB.c **** 
1598:../Sources/USB.c **** static void handleSetControlLineState() {
1599:../Sources/USB.c **** 
1600:../Sources/USB.c ****    cdc_setControlLineState(ep0SetupBuffer.wValue.le.lo);
1601:../Sources/USB.c ****    ep0StartTxTransaction( 0, NULL, DATA1 ); // Tx empty Status packet
1602:../Sources/USB.c **** }
1603:../Sources/USB.c **** 
1604:../Sources/USB.c **** static void handleSendBreak() {
1605:../Sources/USB.c **** 
1606:../Sources/USB.c ****    cdc_sendBreak(ep0SetupBuffer.wValue.word);  // time in milliseconds, 0xFFFF => continuous
1607:../Sources/USB.c ****    ep0StartTxTransaction( 0, NULL, DATA1 );   // Tx empty Status packet
1608:../Sources/USB.c **** }
1609:../Sources/USB.c **** #endif
1610:../Sources/USB.c **** 
1611:../Sources/USB.c **** //=================================================
1612:../Sources/USB.c **** // Illegal request in SETUP pkt
1613:../Sources/USB.c **** //
1614:../Sources/USB.c **** static void handleUnexpected( void ) {
 3268              		.loc 1 1614 0
 3269              		.cfi_startproc
 3270              		@ args = 0, pretend = 0, frame = 0
 3271              		@ frame_needed = 1, uses_anonymous_args = 0
 3272 0000 80B5     		push	{r7, lr}
 3273              	.LCFI94:
 3274              		.cfi_def_cfa_offset 8
 3275              		.cfi_offset 7, -8
 3276              		.cfi_offset 14, -4
 3277 0002 00AF     		add	r7, sp, #0
 3278              	.LCFI95:
 3279              		.cfi_def_cfa_register 7
1615:../Sources/USB.c ****    epStall(0);
 3280              		.loc 1 1615 0
 3281 0004 4FF00000 		mov	r0, #0
 3282 0008 FFF7FEFF 		bl	epStall
1616:../Sources/USB.c **** }
 3283              		.loc 1 1616 0
 3284 000c 80BD     		pop	{r7, pc}
 3285              		.cfi_endproc
 3286              	.LFE35:
 3288 000e 00BF     		.section	.text.handleSetupToken,"ax",%progbits
 3289              		.align	2
 3290              		.thumb
 3291              		.thumb_func
 3293              	handleSetupToken:
 3294              	.LFB36:
1617:../Sources/USB.c ****   
1618:../Sources/USB.c **** //===============================================================================
1619:../Sources/USB.c **** // Handles SETUP Packet
1620:../Sources/USB.c **** //       
1621:../Sources/USB.c **** static void handleSetupToken( void ) {
 3295              		.loc 1 1621 0
 3296              		.cfi_startproc
 3297              		@ args = 0, pretend = 0, frame = 0
 3298              		@ frame_needed = 1, uses_anonymous_args = 0
 3299 0000 80B5     		push	{r7, lr}
 3300              	.LCFI96:
 3301              		.cfi_def_cfa_offset 8
 3302              		.cfi_offset 7, -8
 3303              		.cfi_offset 14, -4
 3304 0002 00AF     		add	r7, sp, #0
 3305              	.LCFI97:
 3306              		.cfi_def_cfa_register 7
1622:../Sources/USB.c ****    // Save data from SETUP pkt
1623:../Sources/USB.c ****    (void)memcpy(&ep0SetupBuffer, ep0OutDataBuffer, sizeof(ep0SetupBuffer));
 3307              		.loc 1 1623 0
 3308 0004 40F20002 		movw	r2, #:lower16:ep0SetupBuffer
 3309 0008 C0F20002 		movt	r2, #:upper16:ep0SetupBuffer
 3310 000c 40F20003 		movw	r3, #:lower16:ep0OutDataBuffer
 3311 0010 C0F20003 		movt	r3, #:upper16:ep0OutDataBuffer
 3312 0014 93E80300 		ldmia	r3, {r0, r1}
 3313 0018 82E80300 		stmia	r2, {r0, r1}
1624:../Sources/USB.c **** //   ep0SetupBuffer = *(SetupPacket *)ep0OutDataBuffer;
1625:../Sources/USB.c **** 
1626:../Sources/USB.c ****    epHardwareState[0].state    = EPIdle;
 3314              		.loc 1 1626 0
 3315 001c 40F20003 		movw	r3, #:lower16:epHardwareState
 3316 0020 C0F20003 		movt	r3, #:upper16:epHardwareState
 3317 0024 1A78     		ldrb	r2, [r3, #0]
 3318 0026 6FF3C702 		bfc	r2, #3, #5
 3319 002a 1A70     		strb	r2, [r3, #0]
1627:../Sources/USB.c ****    ep0State.callback           = NULL;
 3320              		.loc 1 1627 0
 3321 002c 40F20003 		movw	r3, #:lower16:ep0State
 3322 0030 C0F20003 		movt	r3, #:upper16:ep0State
 3323 0034 4FF00002 		mov	r2, #0
 3324 0038 9A60     		str	r2, [r3, #8]
1628:../Sources/USB.c **** 
1629:../Sources/USB.c ****    switch(REQ_TYPE(ep0SetupBuffer.bmRequestType)) {
 3325              		.loc 1 1629 0
 3326 003a 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 3327 003e C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 3328 0042 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 3329 0044 03F06003 		and	r3, r3, #96
 3330 0048 202B     		cmp	r3, #32
 3331 004a 6DD0     		beq	.L169
 3332 004c 602B     		cmp	r3, #96
 3333 004e 6FD0     		beq	.L170
 3334 0050 002B     		cmp	r3, #0
 3335 0052 70D1     		bne	.L167
 3336              	.L168:
1630:../Sources/USB.c ****    case REQ_TYPE_STANDARD :
1631:../Sources/USB.c ****       // Standard device requests
1632:../Sources/USB.c ****       // Convert SETUP values to big-endian
1633:../Sources/USB.c ****       ep0SetupBuffer.wLength.word = leToNative16(ep0SetupBuffer.wLength.word);
 3337              		.loc 1 1633 0
 3338 0054 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 3339 0058 C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 3340 005c DB88     		ldrh	r3, [r3, #6]
 3341 005e 1846     		mov	r0, r3
 3342 0060 FFF7FEFF 		bl	noChange16
 3343 0064 0346     		mov	r3, r0
 3344 0066 1A46     		mov	r2, r3
 3345 0068 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 3346 006c C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 3347 0070 DA80     		strh	r2, [r3, #6]	@ movhi
1634:../Sources/USB.c ****       ep0SetupBuffer.wValue.word  = leToNative16(ep0SetupBuffer.wValue.word);
 3348              		.loc 1 1634 0
 3349 0072 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 3350 0076 C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 3351 007a 5B88     		ldrh	r3, [r3, #2]
 3352 007c 1846     		mov	r0, r3
 3353 007e FFF7FEFF 		bl	noChange16
 3354 0082 0346     		mov	r3, r0
 3355 0084 1A46     		mov	r2, r3
 3356 0086 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 3357 008a C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 3358 008e 5A80     		strh	r2, [r3, #2]	@ movhi
1635:../Sources/USB.c ****       ep0SetupBuffer.wIndex.word  = leToNative16(ep0SetupBuffer.wIndex.word);
 3359              		.loc 1 1635 0
 3360 0090 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 3361 0094 C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 3362 0098 9B88     		ldrh	r3, [r3, #4]
 3363 009a 1846     		mov	r0, r3
 3364 009c FFF7FEFF 		bl	noChange16
 3365 00a0 0346     		mov	r3, r0
 3366 00a2 1A46     		mov	r2, r3
 3367 00a4 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 3368 00a8 C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 3369 00ac 9A80     		strh	r2, [r3, #4]	@ movhi
1636:../Sources/USB.c ****       switch (ep0SetupBuffer.bRequest) {
 3370              		.loc 1 1636 0
 3371 00ae 40F20003 		movw	r3, #:lower16:ep0SetupBuffer
 3372 00b2 C0F20003 		movt	r3, #:upper16:ep0SetupBuffer
 3373 00b6 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 3374 00b8 0A2B     		cmp	r3, #10
 3375 00ba 31D8     		bhi	.L171
 3376 00bc 01A2     		adr	r2, .L180
 3377 00be 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 3378 00c2 00BF     		.align	2
 3379              	.L180:
 3380 00c4 F1000000 		.word	.L172+1
 3381 00c8 F7000000 		.word	.L173+1
 3382 00cc 21010000 		.word	.L171+1
 3383 00d0 FD000000 		.word	.L174+1
 3384 00d4 21010000 		.word	.L171+1
 3385 00d8 03010000 		.word	.L175+1
 3386 00dc 09010000 		.word	.L176+1
 3387 00e0 21010000 		.word	.L171+1
 3388 00e4 0F010000 		.word	.L177+1
 3389 00e8 15010000 		.word	.L178+1
 3390 00ec 1B010000 		.word	.L179+1
 3391              	.L172:
1637:../Sources/USB.c ****       case GET_STATUS :          handleGetStatus();            break;
 3392              		.loc 1 1637 0
 3393 00f0 FFF7FEFF 		bl	handleGetStatus
 3394 00f4 17E0     		b	.L181
 3395              	.L173:
1638:../Sources/USB.c ****       case CLEAR_FEATURE :       handleClearFeature();         break;
 3396              		.loc 1 1638 0
 3397 00f6 FFF7FEFF 		bl	handleClearFeature
 3398 00fa 14E0     		b	.L181
 3399              	.L174:
1639:../Sources/USB.c ****       case SET_FEATURE :         handleSetFeature();           break;
 3400              		.loc 1 1639 0
 3401 00fc FFF7FEFF 		bl	handleSetFeature
 3402 0100 11E0     		b	.L181
 3403              	.L175:
1640:../Sources/USB.c ****       case SET_ADDRESS :         handleSetAddress();           break;
 3404              		.loc 1 1640 0
 3405 0102 FFF7FEFF 		bl	handleSetAddress
 3406 0106 0EE0     		b	.L181
 3407              	.L176:
1641:../Sources/USB.c ****       case GET_DESCRIPTOR :      handleGetDescriptor();        break;
 3408              		.loc 1 1641 0
 3409 0108 FFF7FEFF 		bl	handleGetDescriptor
 3410 010c 0BE0     		b	.L181
 3411              	.L177:
1642:../Sources/USB.c ****       case GET_CONFIGURATION :   handleGetConfiguration();     break;
 3412              		.loc 1 1642 0
 3413 010e FFF7FEFF 		bl	handleGetConfiguration
 3414 0112 08E0     		b	.L181
 3415              	.L178:
1643:../Sources/USB.c ****       case SET_CONFIGURATION :   handleSetConfiguration();     break;
 3416              		.loc 1 1643 0
 3417 0114 FFF7FEFF 		bl	handleSetConfiguration
 3418 0118 05E0     		b	.L181
 3419              	.L179:
1644:../Sources/USB.c ****       case GET_INTERFACE :       handleGetInterface();         break;
 3420              		.loc 1 1644 0
 3421 011a FFF7FEFF 		bl	handleGetInterface
 3422 011e 02E0     		b	.L181
 3423              	.L171:
1645:../Sources/USB.c ****       case SET_DESCRIPTOR :
1646:../Sources/USB.c ****       case SET_INTERFACE :
1647:../Sources/USB.c ****       case SYNCH_FRAME :
1648:../Sources/USB.c ****       default :                  handleUnexpected();           break;
 3424              		.loc 1 1648 0
 3425 0120 FFF7FEFF 		bl	handleUnexpected
 3426 0124 00BF     		nop
 3427              	.L181:
1649:../Sources/USB.c ****       }
1650:../Sources/USB.c ****       break;
 3428              		.loc 1 1650 0
 3429 0126 06E0     		b	.L167
 3430              	.L169:
1651:../Sources/USB.c **** 
1652:../Sources/USB.c ****    case REQ_TYPE_CLASS :
1653:../Sources/USB.c ****       // Class requests
1654:../Sources/USB.c ****       switch (ep0SetupBuffer.bRequest) {         
1655:../Sources/USB.c ****       default :                        handleUnexpected();              break;
 3431              		.loc 1 1655 0
 3432 0128 FFF7FEFF 		bl	handleUnexpected
 3433 012c 00BF     		nop
1656:../Sources/USB.c ****       }
1657:../Sources/USB.c ****       break;
 3434              		.loc 1 1657 0
 3435 012e 02E0     		b	.L167
 3436              	.L170:
1658:../Sources/USB.c **** 
1659:../Sources/USB.c **** //   case REQ_TYPE_VENDOR :
1660:../Sources/USB.c **** //      // Handle special commands here
1661:../Sources/USB.c **** //      reInit = TRUE;  // tell command handler to re-init
1662:../Sources/USB.c **** //      switch (ep0SetupBuffer.bRequest) {
1663:../Sources/USB.c **** //      case ICP_GET_VER : {
1664:../Sources/USB.c **** //         uint8_t versionResponse[5];
1665:../Sources/USB.c **** //         versionResponse[0] = BDM_RC_OK; 
1666:../Sources/USB.c **** //         versionResponse[1] = VERSION_SW;      // BDM SW version
1667:../Sources/USB.c **** //         versionResponse[2] = VERSION_HW;      // BDM HW version
1668:../Sources/USB.c **** //         versionResponse[3] = 0;               // ICP_Version_SW;
1669:../Sources/USB.c **** //         versionResponse[4] = VERSION_HW;      // ICP_Version_HW;
1670:../Sources/USB.c **** //         ep0StartTxTransaction( sizeof(versionResponse),  versionResponse, DATA1 );
1671:../Sources/USB.c **** //      }
1672:../Sources/USB.c **** //      break;
1673:../Sources/USB.c **** //
1674:../Sources/USB.c **** //      case CMD_USBDM_ICP_BOOT :
1675:../Sources/USB.c **** //         // Reboots to ICP mode
1676:../Sources/USB.c **** //         ep0State.callback = resetDeviceCallback;
1677:../Sources/USB.c **** //         ep0StartTxTransaction( 0, NULL, DATA1 ); // Tx empty Status packet
1678:../Sources/USB.c **** //         break;   
1679:../Sources/USB.c **** //      default :                 
1680:../Sources/USB.c **** //         handleUnexpected();   
1681:../Sources/USB.c **** //         break;
1682:../Sources/USB.c **** //      }
1683:../Sources/USB.c **** //      break;
1684:../Sources/USB.c **** 
1685:../Sources/USB.c ****    case REQ_TYPE_OTHER :
1686:../Sources/USB.c ****       handleUnexpected();
 3437              		.loc 1 1686 0
 3438 0130 FFF7FEFF 		bl	handleUnexpected
1687:../Sources/USB.c ****       break;
 3439              		.loc 1 1687 0
 3440 0134 00BF     		nop
 3441              	.L167:
1688:../Sources/USB.c ****    }
1689:../Sources/USB.c **** 
1690:../Sources/USB.c ****    ep0EnsureReadyForSetupTransaction();   // In case another SETUP pkt
 3442              		.loc 1 1690 0
 3443 0136 FFF7FEFF 		bl	ep0EnsureReadyForSetupTransaction
1691:../Sources/USB.c **** 
1692:../Sources/USB.c ****    // Allow transactions post SETUP pkt (clear TXSUSPENDTOKENBUSY)
1693:../Sources/USB.c ****    USB0_CTL = USB_CTL_USBENSOFEN_MASK;
 3444              		.loc 1 1693 0
 3445 013a 4FF40053 		mov	r3, #8192
 3446 013e C4F20703 		movt	r3, 16391
 3447 0142 4FF00102 		mov	r2, #1
 3448 0146 83F89420 		strb	r2, [r3, #148]
1694:../Sources/USB.c **** }
 3449              		.loc 1 1694 0
 3450 014a 80BD     		pop	{r7, pc}
 3451              		.cfi_endproc
 3452              	.LFE36:
 3454              		.section	.text.ep0HandleInToken,"ax",%progbits
 3455              		.align	2
 3456              		.thumb
 3457              		.thumb_func
 3459              	ep0HandleInToken:
 3460              	.LFB37:
1695:../Sources/USB.c **** 
1696:../Sources/USB.c **** //==================================================================
1697:../Sources/USB.c **** // Handlers for Token Complete USB interrupt
1698:../Sources/USB.c **** //
1699:../Sources/USB.c **** 
1700:../Sources/USB.c **** //================
1701:../Sources/USB.c **** // ep0 - IN
1702:../Sources/USB.c **** // 
1703:../Sources/USB.c **** static void ep0HandleInToken( void ) {
 3461              		.loc 1 1703 0
 3462              		.cfi_startproc
 3463              		@ args = 0, pretend = 0, frame = 0
 3464              		@ frame_needed = 1, uses_anonymous_args = 0
 3465 0000 80B5     		push	{r7, lr}
 3466              	.LCFI98:
 3467              		.cfi_def_cfa_offset 8
 3468              		.cfi_offset 7, -8
 3469              		.cfi_offset 14, -4
 3470 0002 00AF     		add	r7, sp, #0
 3471              	.LCFI99:
 3472              		.cfi_def_cfa_register 7
1704:../Sources/USB.c **** 
1705:../Sources/USB.c ****    epHardwareState[0].data0_1 = !epHardwareState[0].data0_1;   // Toggle DATA0/1
 3473              		.loc 1 1705 0
 3474 0004 40F20003 		movw	r3, #:lower16:epHardwareState
 3475 0008 C0F20003 		movt	r3, #:upper16:epHardwareState
 3476 000c 1B78     		ldrb	r3, [r3, #0]
 3477 000e DBB2     		uxtb	r3, r3
 3478 0010 03F00103 		and	r3, r3, #1
 3479 0014 DBB2     		uxtb	r3, r3
 3480 0016 002B     		cmp	r3, #0
 3481 0018 14BF     		ite	ne
 3482 001a 0023     		movne	r3, #0
 3483 001c 0123     		moveq	r3, #1
 3484 001e D9B2     		uxtb	r1, r3
 3485 0020 40F20003 		movw	r3, #:lower16:epHardwareState
 3486 0024 C0F20003 		movt	r3, #:upper16:epHardwareState
 3487 0028 1A78     		ldrb	r2, [r3, #0]
 3488 002a 61F30002 		bfi	r2, r1, #0, #1
 3489 002e 1A70     		strb	r2, [r3, #0]
1706:../Sources/USB.c ****     
1707:../Sources/USB.c ****    switch (epHardwareState[0].state) {
 3490              		.loc 1 1707 0
 3491 0030 40F20003 		movw	r3, #:lower16:epHardwareState
 3492 0034 C0F20003 		movt	r3, #:upper16:epHardwareState
 3493 0038 1B78     		ldrb	r3, [r3, #0]
 3494 003a C3F3C403 		ubfx	r3, r3, #3, #5
 3495 003e DBB2     		uxtb	r3, r3
 3496 0040 032B     		cmp	r3, #3
 3497 0042 36D0     		beq	.L185
 3498 0044 042B     		cmp	r3, #4
 3499 0046 3FD0     		beq	.L186
 3500 0048 012B     		cmp	r3, #1
 3501 004a 5AD1     		bne	.L192
 3502              	.L184:
1708:../Sources/USB.c ****       case EPDataIn:    // Doing a sequence of IN packets (until data count <= EPSIZE)
1709:../Sources/USB.c ****          if ((ep0State.dataRemaining < ENDPT0MAXSIZE) ||   // Undersize pkt OR
 3503              		.loc 1 1709 0
 3504 004c 40F20003 		movw	r3, #:lower16:ep0State
 3505 0050 C0F20003 		movt	r3, #:upper16:ep0State
 3506 0054 1B79     		ldrb	r3, [r3, #4]
 3507 0056 DBB2     		uxtb	r3, r3
 3508 0058 1F2B     		cmp	r3, #31
 3509 005a 12D9     		bls	.L187
1710:../Sources/USB.c ****              ((ep0State.dataRemaining == ENDPT0MAXSIZE) && // Full size AND
 3510              		.loc 1 1710 0
 3511 005c 40F20003 		movw	r3, #:lower16:ep0State
 3512 0060 C0F20003 		movt	r3, #:upper16:ep0State
 3513 0064 1B79     		ldrb	r3, [r3, #4]
 3514 0066 DBB2     		uxtb	r3, r3
1709:../Sources/USB.c ****          if ((ep0State.dataRemaining < ENDPT0MAXSIZE) ||   // Undersize pkt OR
 3515              		.loc 1 1709 0
 3516 0068 202B     		cmp	r3, #32
 3517 006a 15D1     		bne	.L188
1711:../Sources/USB.c ****                !ep0State.shortInTransaction))              // Don't need to flag undersize transact
 3518              		.loc 1 1711 0
 3519 006c 40F20003 		movw	r3, #:lower16:ep0State
 3520 0070 C0F20003 		movt	r3, #:upper16:ep0State
 3521 0074 9B79     		ldrb	r3, [r3, #6]
 3522 0076 DBB2     		uxtb	r3, r3
 3523 0078 03F00103 		and	r3, r3, #1
 3524 007c DBB2     		uxtb	r3, r3
1710:../Sources/USB.c ****              ((ep0State.dataRemaining == ENDPT0MAXSIZE) && // Full size AND
 3525              		.loc 1 1710 0
 3526 007e 002B     		cmp	r3, #0
 3527 0080 0AD1     		bne	.L188
 3528              	.L187:
1712:../Sources/USB.c ****             epHardwareState[0].state = EPLastIn;    // Sending last pkt
 3529              		.loc 1 1712 0
 3530 0082 40F20003 		movw	r3, #:lower16:epHardwareState
 3531 0086 C0F20003 		movt	r3, #:upper16:epHardwareState
 3532 008a 1A78     		ldrb	r2, [r3, #0]
 3533 008c 4FF00301 		mov	r1, #3
 3534 0090 61F3C702 		bfi	r2, r1, #3, #5
 3535 0094 1A70     		strb	r2, [r3, #0]
 3536 0096 09E0     		b	.L189
 3537              	.L188:
1713:../Sources/USB.c ****          else 
1714:../Sources/USB.c ****             epHardwareState[0].state = EPDataIn;    // Sending full pkt
 3538              		.loc 1 1714 0
 3539 0098 40F20003 		movw	r3, #:lower16:epHardwareState
 3540 009c C0F20003 		movt	r3, #:upper16:epHardwareState
 3541 00a0 1A78     		ldrb	r2, [r3, #0]
 3542 00a2 4FF00101 		mov	r1, #1
 3543 00a6 61F3C702 		bfi	r2, r1, #3, #5
 3544 00aa 1A70     		strb	r2, [r3, #0]
 3545              	.L189:
1715:../Sources/USB.c ****          ep0InitialiseBdtTx(); // Set up next IN pkt
 3546              		.loc 1 1715 0
 3547 00ac FFF7FEFF 		bl	ep0InitialiseBdtTx
1716:../Sources/USB.c ****          break;
 3548              		.loc 1 1716 0
 3549 00b0 28E0     		b	.L182
 3550              	.L185:
1717:../Sources/USB.c ****          
1718:../Sources/USB.c ****       case EPLastIn:    
1719:../Sources/USB.c ****           // Just done the last IN packet
1720:../Sources/USB.c ****          epHardwareState[0].state = EPStatusOut;   // Receiving an OUT status pkt
 3551              		.loc 1 1720 0
 3552 00b2 40F20003 		movw	r3, #:lower16:epHardwareState
 3553 00b6 C0F20003 		movt	r3, #:upper16:epHardwareState
 3554 00ba 1A78     		ldrb	r2, [r3, #0]
 3555 00bc 4FF00501 		mov	r1, #5
 3556 00c0 61F3C702 		bfi	r2, r1, #3, #5
 3557 00c4 1A70     		strb	r2, [r3, #0]
1721:../Sources/USB.c ****          break;
 3558              		.loc 1 1721 0
 3559 00c6 1DE0     		b	.L182
 3560              	.L186:
1722:../Sources/USB.c ****          
1723:../Sources/USB.c ****       case EPStatusIn:  
1724:../Sources/USB.c ****          // Just done an IN packet as a status handshake for an OUT Data transfer
1725:../Sources/USB.c ****          epHardwareState[0].state = EPIdle;           // Now Idle
 3561              		.loc 1 1725 0
 3562 00c8 40F20003 		movw	r3, #:lower16:epHardwareState
 3563 00cc C0F20003 		movt	r3, #:upper16:epHardwareState
 3564 00d0 1A78     		ldrb	r2, [r3, #0]
 3565 00d2 6FF3C702 		bfc	r2, #3, #5
 3566 00d6 1A70     		strb	r2, [r3, #0]
1726:../Sources/USB.c ****          if (ep0State.callback != NULL)
 3567              		.loc 1 1726 0
 3568 00d8 40F20003 		movw	r3, #:lower16:ep0State
 3569 00dc C0F20003 		movt	r3, #:upper16:ep0State
 3570 00e0 9B68     		ldr	r3, [r3, #8]
 3571 00e2 002B     		cmp	r3, #0
 3572 00e4 05D0     		beq	.L191
1727:../Sources/USB.c ****             ep0State.callback(); // Execute callback function to process OUT data
 3573              		.loc 1 1727 0
 3574 00e6 40F20003 		movw	r3, #:lower16:ep0State
 3575 00ea C0F20003 		movt	r3, #:upper16:ep0State
 3576 00ee 9B68     		ldr	r3, [r3, #8]
 3577 00f0 9847     		blx	r3
 3578              	.L191:
1728:../Sources/USB.c ****          ep0State.callback = NULL;
 3579              		.loc 1 1728 0
 3580 00f2 40F20003 		movw	r3, #:lower16:ep0State
 3581 00f6 C0F20003 		movt	r3, #:upper16:ep0State
 3582 00fa 4FF00002 		mov	r2, #0
 3583 00fe 9A60     		str	r2, [r3, #8]
1729:../Sources/USB.c ****          break;
 3584              		.loc 1 1729 0
 3585 0100 00E0     		b	.L182
 3586              	.L192:
1730:../Sources/USB.c **** 
1731:../Sources/USB.c ****       // We don't expect an IN token while in the following states
1732:../Sources/USB.c ****       case EPIdle:           // Idle (Tx complete)
1733:../Sources/USB.c ****       case EPDataOut:        // Doing a sequence of OUT packets (until data count <= EPSIZE)
1734:../Sources/USB.c ****       case EPStatusOut:      // Doing an OUT packet as a status handshake
1735:../Sources/USB.c ****       default:
1736:../Sources/USB.c ****          break;
 3587              		.loc 1 1736 0
 3588 0102 00BF     		nop
 3589              	.L182:
1737:../Sources/USB.c ****    }
1738:../Sources/USB.c **** }
 3590              		.loc 1 1738 0
 3591 0104 80BD     		pop	{r7, pc}
 3592              		.cfi_endproc
 3593              	.LFE37:
 3595 0106 00BF     		.section	.text.ep0HandleOutToken,"ax",%progbits
 3596              		.align	2
 3597              		.thumb
 3598              		.thumb_func
 3600              	ep0HandleOutToken:
 3601              	.LFB38:
1739:../Sources/USB.c **** 
1740:../Sources/USB.c **** //================
1741:../Sources/USB.c **** // ep0 - OUT
1742:../Sources/USB.c **** // 
1743:../Sources/USB.c **** static void ep0HandleOutToken( void ) {
 3602              		.loc 1 1743 0
 3603              		.cfi_startproc
 3604              		@ args = 0, pretend = 0, frame = 8
 3605              		@ frame_needed = 1, uses_anonymous_args = 0
 3606 0000 80B5     		push	{r7, lr}
 3607              	.LCFI100:
 3608              		.cfi_def_cfa_offset 8
 3609              		.cfi_offset 7, -8
 3610              		.cfi_offset 14, -4
 3611 0002 82B0     		sub	sp, sp, #8
 3612              	.LCFI101:
 3613              		.cfi_def_cfa_offset 16
 3614 0004 00AF     		add	r7, sp, #0
 3615              	.LCFI102:
 3616              		.cfi_def_cfa_register 7
1744:../Sources/USB.c **** uint8_t transferSize;
1745:../Sources/USB.c **** 
1746:../Sources/USB.c ****    epHardwareState[0].data0_1 = !epHardwareState[0].data0_1; // Toggle DATA0/1
 3617              		.loc 1 1746 0
 3618 0006 40F20003 		movw	r3, #:lower16:epHardwareState
 3619 000a C0F20003 		movt	r3, #:upper16:epHardwareState
 3620 000e 1B78     		ldrb	r3, [r3, #0]
 3621 0010 DBB2     		uxtb	r3, r3
 3622 0012 03F00103 		and	r3, r3, #1
 3623 0016 DBB2     		uxtb	r3, r3
 3624 0018 002B     		cmp	r3, #0
 3625 001a 14BF     		ite	ne
 3626 001c 0023     		movne	r3, #0
 3627 001e 0123     		moveq	r3, #1
 3628 0020 D9B2     		uxtb	r1, r3
 3629 0022 40F20003 		movw	r3, #:lower16:epHardwareState
 3630 0026 C0F20003 		movt	r3, #:upper16:epHardwareState
 3631 002a 1A78     		ldrb	r2, [r3, #0]
 3632 002c 61F30002 		bfi	r2, r1, #0, #1
 3633 0030 1A70     		strb	r2, [r3, #0]
1747:../Sources/USB.c ****    
1748:../Sources/USB.c ****    switch (epHardwareState[0].state) {
 3634              		.loc 1 1748 0
 3635 0032 40F20003 		movw	r3, #:lower16:epHardwareState
 3636 0036 C0F20003 		movt	r3, #:upper16:epHardwareState
 3637 003a 1B78     		ldrb	r3, [r3, #0]
 3638 003c C3F3C403 		ubfx	r3, r3, #3, #5
 3639 0040 DBB2     		uxtb	r3, r3
 3640 0042 052B     		cmp	r3, #5
 3641 0044 45D8     		bhi	.L194
 3642 0046 4FF00102 		mov	r2, #1
 3643 004a 02FA03F3 		lsl	r3, r2, r3
 3644 004e 03F01B02 		and	r2, r3, #27
 3645 0052 002A     		cmp	r2, #0
 3646 0054 3CD1     		bne	.L201
 3647 0056 03F02002 		and	r2, r3, #32
 3648 005a 002A     		cmp	r2, #0
 3649 005c 2FD1     		bne	.L197
 3650 005e 03F00403 		and	r3, r3, #4
 3651 0062 002B     		cmp	r3, #0
 3652 0064 35D0     		beq	.L194
 3653              	.L196:
1749:../Sources/USB.c ****       case EPDataOut:        // Receiving a sequence of OUT packets
1750:../Sources/USB.c ****          transferSize = ep0SaveRxData();          // Save the data from the Rx buffer
 3654              		.loc 1 1750 0
 3655 0066 FFF7FEFF 		bl	ep0SaveRxData
 3656 006a 0346     		mov	r3, r0
 3657 006c FB71     		strb	r3, [r7, #7]
1751:../Sources/USB.c ****          // Check if completed an under-size pkt or expected number of bytes
1752:../Sources/USB.c ****          if ((transferSize < ENDPT0MAXSIZE) || (ep0State.dataRemaining == 0)) { // Last pkt?
 3658              		.loc 1 1752 0
 3659 006e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3660 0070 1F2B     		cmp	r3, #31
 3661 0072 07D9     		bls	.L198
 3662              		.loc 1 1752 0 is_stmt 0
 3663 0074 40F20003 		movw	r3, #:lower16:ep0State
 3664 0078 C0F20003 		movt	r3, #:upper16:ep0State
 3665 007c 1B79     		ldrb	r3, [r3, #4]
 3666 007e DBB2     		uxtb	r3, r3
 3667 0080 002B     		cmp	r3, #0
 3668 0082 10D1     		bne	.L199
 3669              	.L198:
1753:../Sources/USB.c ****             epHardwareState[0].state = EPIdle;
 3670              		.loc 1 1753 0 is_stmt 1
 3671 0084 40F20003 		movw	r3, #:lower16:epHardwareState
 3672 0088 C0F20003 		movt	r3, #:upper16:epHardwareState
 3673 008c 1A78     		ldrb	r2, [r3, #0]
 3674 008e 6FF3C702 		bfc	r2, #3, #5
 3675 0092 1A70     		strb	r2, [r3, #0]
1754:../Sources/USB.c ****             ep0StartTxTransaction(0, NULL, DATA1); // Do status Pkt transmission
 3676              		.loc 1 1754 0
 3677 0094 4FF00000 		mov	r0, #0
 3678 0098 4FF00001 		mov	r1, #0
 3679 009c 4FF00102 		mov	r2, #1
 3680 00a0 FFF7FEFF 		bl	ep0StartTxTransaction
1755:../Sources/USB.c ****             }
1756:../Sources/USB.c ****          else {
1757:../Sources/USB.c ****             ep0InitialiseBdtRx(epHardwareState[0].data0_1); // Set up next OUT pkt
1758:../Sources/USB.c ****             }
1759:../Sources/USB.c ****          break;
 3681              		.loc 1 1759 0
 3682 00a4 15E0     		b	.L194
 3683              	.L199:
1757:../Sources/USB.c ****             ep0InitialiseBdtRx(epHardwareState[0].data0_1); // Set up next OUT pkt
 3684              		.loc 1 1757 0
 3685 00a6 40F20003 		movw	r3, #:lower16:epHardwareState
 3686 00aa C0F20003 		movt	r3, #:upper16:epHardwareState
 3687 00ae 1B78     		ldrb	r3, [r3, #0]
 3688 00b0 C3F30003 		ubfx	r3, r3, #0, #1
 3689 00b4 DBB2     		uxtb	r3, r3
 3690 00b6 1846     		mov	r0, r3
 3691 00b8 FFF7FEFF 		bl	ep0InitialiseBdtRx
 3692              		.loc 1 1759 0
 3693 00bc 09E0     		b	.L194
 3694              	.L197:
1760:../Sources/USB.c **** 
1761:../Sources/USB.c ****       case EPStatusOut:       // Done an OUT packet as a status handshake
1762:../Sources/USB.c ****          epHardwareState[0].state = EPIdle;
 3695              		.loc 1 1762 0
 3696 00be 40F20003 		movw	r3, #:lower16:epHardwareState
 3697 00c2 C0F20003 		movt	r3, #:upper16:epHardwareState
 3698 00c6 1A78     		ldrb	r2, [r3, #0]
 3699 00c8 6FF3C702 		bfc	r2, #3, #5
 3700 00cc 1A70     		strb	r2, [r3, #0]
1763:../Sources/USB.c ****          break;
 3701              		.loc 1 1763 0
 3702 00ce 00E0     		b	.L194
 3703              	.L201:
1764:../Sources/USB.c ****         
1765:../Sources/USB.c ****       // We don't expect an OUT token while in the following states
1766:../Sources/USB.c ****       case EPLastIn:          // Just done the last IN packet
1767:../Sources/USB.c ****       case EPDataIn:          // Doing a sequence of IN packets (until data count <= EPSIZE)
1768:../Sources/USB.c ****       case EPStatusIn:        // Just done an IN packet as a status handshake
1769:../Sources/USB.c ****       case EPIdle:            // Idle (Tx complete)
1770:../Sources/USB.c ****          break;
 3704              		.loc 1 1770 0
 3705 00d0 00BF     		nop
 3706              	.L194:
1771:../Sources/USB.c ****    }
1772:../Sources/USB.c ****    ep0EnsureReadyForSetupTransaction();  // Make ready for a SETUP pkt
 3707              		.loc 1 1772 0
 3708 00d2 FFF7FEFF 		bl	ep0EnsureReadyForSetupTransaction
1773:../Sources/USB.c **** }
 3709              		.loc 1 1773 0
 3710 00d6 07F10807 		add	r7, r7, #8
 3711 00da BD46     		mov	sp, r7
 3712 00dc 80BD     		pop	{r7, pc}
 3713              		.cfi_endproc
 3714              	.LFE38:
 3716 00de 00BF     		.section	.text.ep0HandleStallComplete,"ax",%progbits
 3717              		.align	2
 3718              		.thumb
 3719              		.thumb_func
 3721              	ep0HandleStallComplete:
 3722              	.LFB39:
1774:../Sources/USB.c **** 
1775:../Sources/USB.c **** //=================================================
1776:../Sources/USB.c **** // ep0 - STALL completed - re-enable ep0 for SETUP
1777:../Sources/USB.c **** // 
1778:../Sources/USB.c **** static void ep0HandleStallComplete( void ) {
 3723              		.loc 1 1778 0
 3724              		.cfi_startproc
 3725              		@ args = 0, pretend = 0, frame = 0
 3726              		@ frame_needed = 1, uses_anonymous_args = 0
 3727 0000 80B5     		push	{r7, lr}
 3728              	.LCFI103:
 3729              		.cfi_def_cfa_offset 8
 3730              		.cfi_offset 7, -8
 3731              		.cfi_offset 14, -4
 3732 0002 00AF     		add	r7, sp, #0
 3733              	.LCFI104:
 3734              		.cfi_def_cfa_register 7
1779:../Sources/USB.c ****    epClearStall(0);
 3735              		.loc 1 1779 0
 3736 0004 4FF00000 		mov	r0, #0
 3737 0008 FFF7FEFF 		bl	epClearStall
1780:../Sources/USB.c ****    ep0ConfigureSetupTransaction(); // re-initialise EP0 OUT // v4.7
 3738              		.loc 1 1780 0
 3739 000c FFF7FEFF 		bl	ep0ConfigureSetupTransaction
1781:../Sources/USB.c **** }
 3740              		.loc 1 1781 0
 3741 0010 80BD     		pop	{r7, pc}
 3742              		.cfi_endproc
 3743              	.LFE39:
 3745 0012 00BF     		.section	.text.ep1HandleOutToken,"ax",%progbits
 3746              		.align	2
 3747              		.thumb
 3748              		.thumb_func
 3750              	ep1HandleOutToken:
 3751              	.LFB40:
1782:../Sources/USB.c **** 
1783:../Sources/USB.c **** //===========================
1784:../Sources/USB.c **** // ep1 - OUT (host->device)
1785:../Sources/USB.c **** // 
1786:../Sources/USB.c **** static void ep1HandleOutToken( void ) {
 3752              		.loc 1 1786 0
 3753              		.cfi_startproc
 3754              		@ args = 0, pretend = 0, frame = 8
 3755              		@ frame_needed = 1, uses_anonymous_args = 0
 3756 0000 80B5     		push	{r7, lr}
 3757              	.LCFI105:
 3758              		.cfi_def_cfa_offset 8
 3759              		.cfi_offset 7, -8
 3760              		.cfi_offset 14, -4
 3761 0002 82B0     		sub	sp, sp, #8
 3762              	.LCFI106:
 3763              		.cfi_def_cfa_offset 16
 3764 0004 00AF     		add	r7, sp, #0
 3765              	.LCFI107:
 3766              		.cfi_def_cfa_register 7
1787:../Sources/USB.c **** uint8_t transferSize;
1788:../Sources/USB.c **** 
1789:../Sources/USB.c ****    epHardwareState[1].data0_1 = !epHardwareState[1].data0_1;   // Toggle DATA0/1
 3767              		.loc 1 1789 0
 3768 0006 40F20003 		movw	r3, #:lower16:epHardwareState
 3769 000a C0F20003 		movt	r3, #:upper16:epHardwareState
 3770 000e 5B78     		ldrb	r3, [r3, #1]
 3771 0010 DBB2     		uxtb	r3, r3
 3772 0012 03F00103 		and	r3, r3, #1
 3773 0016 DBB2     		uxtb	r3, r3
 3774 0018 002B     		cmp	r3, #0
 3775 001a 14BF     		ite	ne
 3776 001c 0023     		movne	r3, #0
 3777 001e 0123     		moveq	r3, #1
 3778 0020 D9B2     		uxtb	r1, r3
 3779 0022 40F20003 		movw	r3, #:lower16:epHardwareState
 3780 0026 C0F20003 		movt	r3, #:upper16:epHardwareState
 3781 002a 5A78     		ldrb	r2, [r3, #1]
 3782 002c 61F30002 		bfi	r2, r1, #0, #1
 3783 0030 5A70     		strb	r2, [r3, #1]
1790:../Sources/USB.c ****    
1791:../Sources/USB.c ****    switch (epHardwareState[1].state) {
 3784              		.loc 1 1791 0
 3785 0032 40F20003 		movw	r3, #:lower16:epHardwareState
 3786 0036 C0F20003 		movt	r3, #:upper16:epHardwareState
 3787 003a 5B78     		ldrb	r3, [r3, #1]
 3788 003c C3F3C403 		ubfx	r3, r3, #3, #5
 3789 0040 DBB2     		uxtb	r3, r3
 3790 0042 082B     		cmp	r3, #8
 3791 0044 2AD8     		bhi	.L203
 3792 0046 4FF00102 		mov	r2, #1
 3793 004a 02FA03F2 		lsl	r2, r2, r3
 3794 004e 40F23B13 		movw	r3, #315
 3795 0052 1340     		ands	r3, r3, r2
 3796 0054 002B     		cmp	r3, #0
 3797 0056 20D1     		bne	.L210
 3798 0058 02F00403 		and	r3, r2, #4
 3799 005c 002B     		cmp	r3, #0
 3800 005e 1DD0     		beq	.L203
 3801              	.L206:
1792:../Sources/USB.c ****       case EPDataOut:        // Doing a sequence of OUT packets making up a command
1793:../Sources/USB.c ****          transferSize = ep1SaveRxData();          // Save the data from the Rx buffer
 3802              		.loc 1 1793 0
 3803 0060 FFF7FEFF 		bl	ep1SaveRxData
 3804 0064 0346     		mov	r3, r0
 3805 0066 FB71     		strb	r3, [r7, #7]
1794:../Sources/USB.c ****          // Completed transfer on undersize pkt or received expected number of bytes
1795:../Sources/USB.c ****          if ((transferSize < ENDPT1MAXSIZE) || (ep1State.dataRemaining == 0)) { // Last pkt?
 3806              		.loc 1 1795 0
 3807 0068 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3808 006a 3F2B     		cmp	r3, #63
 3809 006c 07D9     		bls	.L207
 3810              		.loc 1 1795 0 is_stmt 0
 3811 006e 40F20003 		movw	r3, #:lower16:ep1State
 3812 0072 C0F20003 		movt	r3, #:upper16:ep1State
 3813 0076 1B79     		ldrb	r3, [r3, #4]
 3814 0078 DBB2     		uxtb	r3, r3
 3815 007a 002B     		cmp	r3, #0
 3816 007c 0AD1     		bne	.L208
 3817              	.L207:
1796:../Sources/USB.c ****             epHardwareState[1].state = EPComplete;
 3818              		.loc 1 1796 0 is_stmt 1
 3819 007e 40F20003 		movw	r3, #:lower16:epHardwareState
 3820 0082 C0F20003 		movt	r3, #:upper16:epHardwareState
 3821 0086 5A78     		ldrb	r2, [r3, #1]
 3822 0088 4FF00801 		mov	r1, #8
 3823 008c 61F3C702 		bfi	r2, r1, #3, #5
 3824 0090 5A70     		strb	r2, [r3, #1]
1797:../Sources/USB.c ****          }
1798:../Sources/USB.c ****          else
1799:../Sources/USB.c ****             ep1InitialiseBdtRx(); // Set up next OUT pkt
1800:../Sources/USB.c ****          break;
 3825              		.loc 1 1800 0
 3826 0092 03E0     		b	.L203
 3827              	.L208:
1799:../Sources/USB.c ****             ep1InitialiseBdtRx(); // Set up next OUT pkt
 3828              		.loc 1 1799 0
 3829 0094 FFF7FEFF 		bl	ep1InitialiseBdtRx
 3830              		.loc 1 1800 0
 3831 0098 00E0     		b	.L203
 3832              	.L210:
1801:../Sources/USB.c ****        
1802:../Sources/USB.c ****          // We don't expect an OUT token while in the following states
1803:../Sources/USB.c ****       case EPIdle:           // Idle (Rx complete)
1804:../Sources/USB.c ****       case EPComplete:       // Command reception complete (Rx complete)
1805:../Sources/USB.c ****       case EPLastIn:         // Just done the last IN packet
1806:../Sources/USB.c ****       case EPDataIn:         // Doing a sequence of IN packets (until data count <= EPSIZE)
1807:../Sources/USB.c ****       case EPStatusIn:       // Just done an IN packet as a status handshake
1808:../Sources/USB.c ****       case EPStatusOut:      // Done an OUT packet as a status handshake
1809:../Sources/USB.c ****          break;
 3833              		.loc 1 1809 0
 3834 009a 00BF     		nop
 3835              	.L203:
1810:../Sources/USB.c ****    }
1811:../Sources/USB.c **** }
 3836              		.loc 1 1811 0
 3837 009c 07F10807 		add	r7, r7, #8
 3838 00a0 BD46     		mov	sp, r7
 3839 00a2 80BD     		pop	{r7, pc}
 3840              		.cfi_endproc
 3841              	.LFE40:
 3843              		.section	.text.ep2HandleInToken,"ax",%progbits
 3844              		.align	2
 3845              		.thumb
 3846              		.thumb_func
 3848              	ep2HandleInToken:
 3849              	.LFB41:
1812:../Sources/USB.c **** 
1813:../Sources/USB.c **** //================
1814:../Sources/USB.c **** // ep2 - IN
1815:../Sources/USB.c **** // 
1816:../Sources/USB.c **** static void ep2HandleInToken( void ) {
 3850              		.loc 1 1816 0
 3851              		.cfi_startproc
 3852              		@ args = 0, pretend = 0, frame = 0
 3853              		@ frame_needed = 1, uses_anonymous_args = 0
 3854 0000 80B5     		push	{r7, lr}
 3855              	.LCFI108:
 3856              		.cfi_def_cfa_offset 8
 3857              		.cfi_offset 7, -8
 3858              		.cfi_offset 14, -4
 3859 0002 00AF     		add	r7, sp, #0
 3860              	.LCFI109:
 3861              		.cfi_def_cfa_register 7
1817:../Sources/USB.c **** 
1818:../Sources/USB.c ****    epHardwareState[2].data0_1 = !epHardwareState[2].data0_1;   // Toggle DATA0/1 for next pkt
 3862              		.loc 1 1818 0
 3863 0004 40F20003 		movw	r3, #:lower16:epHardwareState
 3864 0008 C0F20003 		movt	r3, #:upper16:epHardwareState
 3865 000c 9B78     		ldrb	r3, [r3, #2]
 3866 000e DBB2     		uxtb	r3, r3
 3867 0010 03F00103 		and	r3, r3, #1
 3868 0014 DBB2     		uxtb	r3, r3
 3869 0016 002B     		cmp	r3, #0
 3870 0018 14BF     		ite	ne
 3871 001a 0023     		movne	r3, #0
 3872 001c 0123     		moveq	r3, #1
 3873 001e D9B2     		uxtb	r1, r3
 3874 0020 40F20003 		movw	r3, #:lower16:epHardwareState
 3875 0024 C0F20003 		movt	r3, #:upper16:epHardwareState
 3876 0028 9A78     		ldrb	r2, [r3, #2]
 3877 002a 61F30002 		bfi	r2, r1, #0, #1
 3878 002e 9A70     		strb	r2, [r3, #2]
1819:../Sources/USB.c ****    
1820:../Sources/USB.c ****    switch (epHardwareState[2].state) {
 3879              		.loc 1 1820 0
 3880 0030 40F20003 		movw	r3, #:lower16:epHardwareState
 3881 0034 C0F20003 		movt	r3, #:upper16:epHardwareState
 3882 0038 9B78     		ldrb	r3, [r3, #2]
 3883 003a C3F3C403 		ubfx	r3, r3, #3, #5
 3884 003e DBB2     		uxtb	r3, r3
 3885 0040 012B     		cmp	r3, #1
 3886 0042 02D0     		beq	.L213
 3887 0044 032B     		cmp	r3, #3
 3888 0046 20D0     		beq	.L214
 3889 0048 28E0     		b	.L218
 3890              	.L213:
1821:../Sources/USB.c ****       case EPDataIn:    // Doing a sequence of IN packets (until data count <= EPSIZE)
1822:../Sources/USB.c ****          if (ep2State.dataRemaining < ENDPT2MAXSIZE) 
 3891              		.loc 1 1822 0
 3892 004a 40F20003 		movw	r3, #:lower16:ep2State
 3893 004e C0F20003 		movt	r3, #:upper16:ep2State
 3894 0052 1B79     		ldrb	r3, [r3, #4]
 3895 0054 DBB2     		uxtb	r3, r3
 3896 0056 3F2B     		cmp	r3, #63
 3897 0058 0AD8     		bhi	.L215
1823:../Sources/USB.c ****             epHardwareState[2].state = EPLastIn;    // Sending last pkt (may be empty)
 3898              		.loc 1 1823 0
 3899 005a 40F20003 		movw	r3, #:lower16:epHardwareState
 3900 005e C0F20003 		movt	r3, #:upper16:epHardwareState
 3901 0062 9A78     		ldrb	r2, [r3, #2]
 3902 0064 4FF00301 		mov	r1, #3
 3903 0068 61F3C702 		bfi	r2, r1, #3, #5
 3904 006c 9A70     		strb	r2, [r3, #2]
 3905 006e 09E0     		b	.L216
 3906              	.L215:
1824:../Sources/USB.c ****          else 
1825:../Sources/USB.c ****             epHardwareState[2].state = EPDataIn;    // Sending full pkt
 3907              		.loc 1 1825 0
 3908 0070 40F20003 		movw	r3, #:lower16:epHardwareState
 3909 0074 C0F20003 		movt	r3, #:upper16:epHardwareState
 3910 0078 9A78     		ldrb	r2, [r3, #2]
 3911 007a 4FF00101 		mov	r1, #1
 3912 007e 61F3C702 		bfi	r2, r1, #3, #5
 3913 0082 9A70     		strb	r2, [r3, #2]
 3914              	.L216:
1826:../Sources/USB.c ****          ep2InitialiseBdtTx(); // Set up next IN pkt
 3915              		.loc 1 1826 0
 3916 0084 FFF7FEFF 		bl	ep2InitialiseBdtTx
1827:../Sources/USB.c ****          break;
 3917              		.loc 1 1827 0
 3918 0088 09E0     		b	.L211
 3919              	.L214:
1828:../Sources/USB.c ****          
1829:../Sources/USB.c ****       case EPLastIn:    // Just done the last IN packet
1830:../Sources/USB.c ****             epHardwareState[2].state = EPIdle;  // No more transactions expected
 3920              		.loc 1 1830 0
 3921 008a 40F20003 		movw	r3, #:lower16:epHardwareState
 3922 008e C0F20003 		movt	r3, #:upper16:epHardwareState
 3923 0092 9A78     		ldrb	r2, [r3, #2]
 3924 0094 6FF3C702 		bfc	r2, #3, #5
 3925 0098 9A70     		strb	r2, [r3, #2]
1831:../Sources/USB.c ****          break;
 3926              		.loc 1 1831 0
 3927 009a 00E0     		b	.L211
 3928              	.L218:
1832:../Sources/USB.c ****          
1833:../Sources/USB.c ****       // We don't expect an IN token while in the following states
1834:../Sources/USB.c ****       case EPIdle:           // Idle (Tx complete)
1835:../Sources/USB.c ****       case EPDataOut:        // Doing a sequence of OUT packets (until data count <= EPSIZE)
1836:../Sources/USB.c ****       case EPStatusIn:       // Just done an IN packet as a status handshake
1837:../Sources/USB.c ****       case EPStatusOut:      // Doing an OUT packet as a status handshake
1838:../Sources/USB.c ****       default:
1839:../Sources/USB.c ****          break;
 3929              		.loc 1 1839 0
 3930 009c 00BF     		nop
 3931              	.L211:
1840:../Sources/USB.c ****    }
1841:../Sources/USB.c **** }
 3932              		.loc 1 1841 0
 3933 009e 80BD     		pop	{r7, pc}
 3934              		.cfi_endproc
 3935              	.LFE41:
 3937              		.section	.text.handleTokenComplete,"ax",%progbits
 3938              		.align	2
 3939              		.thumb
 3940              		.thumb_func
 3942              	handleTokenComplete:
 3943              	.LFB42:
1842:../Sources/USB.c **** 
1843:../Sources/USB.c **** //==================================================================
1844:../Sources/USB.c **** // Handler for Token Complete USB interrupt
1845:../Sources/USB.c **** //
1846:../Sources/USB.c **** // Handles ep0 [SETUP, IN & OUT]
1847:../Sources/USB.c **** // Handles ep1 [Out]
1848:../Sources/USB.c **** // Handles ep2 [In]
1849:../Sources/USB.c **** // Handles ep3 [In]
1850:../Sources/USB.c **** // Handles ep4 [Out]
1851:../Sources/USB.c **** // Handles ep5 [In]
1852:../Sources/USB.c **** // 
1853:../Sources/USB.c **** static void handleTokenComplete(void) {
 3944              		.loc 1 1853 0
 3945              		.cfi_startproc
 3946              		@ args = 0, pretend = 0, frame = 8
 3947              		@ frame_needed = 1, uses_anonymous_args = 0
 3948 0000 80B5     		push	{r7, lr}
 3949              	.LCFI110:
 3950              		.cfi_def_cfa_offset 8
 3951              		.cfi_offset 7, -8
 3952              		.cfi_offset 14, -4
 3953 0002 82B0     		sub	sp, sp, #8
 3954              	.LCFI111:
 3955              		.cfi_def_cfa_offset 16
 3956 0004 00AF     		add	r7, sp, #0
 3957              	.LCFI112:
 3958              		.cfi_def_cfa_register 7
1854:../Sources/USB.c ****    uint8_t  usbStat       = USB0_STAT;
 3959              		.loc 1 1854 0
 3960 0006 4FF40053 		mov	r3, #8192
 3961 000a C4F20703 		movt	r3, 16391
 3962 000e 93F89030 		ldrb	r3, [r3, #144]
 3963 0012 FB71     		strb	r3, [r7, #7]
1855:../Sources/USB.c ****    uint8_t  endPoint      = ((uint8_t)usbStat)>>4;        // Endpoint number
 3964              		.loc 1 1855 0
 3965 0014 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3966 0016 4FEA1313 		lsr	r3, r3, #4
 3967 001a BB71     		strb	r3, [r7, #6]
1856:../Sources/USB.c ****    uint8_t  isTx          = usbStat&USB_STAT_TX_MASK;     // Direction of T/F 0=>OUT, (!=0)=>IN
 3968              		.loc 1 1856 0
 3969 001c FB79     		ldrb	r3, [r7, #7]
 3970 001e 03F00803 		and	r3, r3, #8
 3971 0022 7B71     		strb	r3, [r7, #5]
1857:../Sources/USB.c ****    uint8_t  isOdd         = usbStat&USB_STAT_ODD_MASK;    // Odd/even buffer
 3972              		.loc 1 1857 0
 3973 0024 FB79     		ldrb	r3, [r7, #7]
 3974 0026 03F00403 		and	r3, r3, #4
 3975 002a 3B71     		strb	r3, [r7, #4]
1858:../Sources/USB.c ****    BdtEntry *bdt = &BDTS(usbStat>>2);
 3976              		.loc 1 1858 0
 3977 002c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3978 002e 4FEA9303 		lsr	r3, r3, #2
 3979 0032 DBB2     		uxtb	r3, r3
 3980 0034 4FEAC302 		lsl	r2, r3, #3
 3981 0038 40F20003 		movw	r3, #:lower16:endPointBdts
 3982 003c C0F20003 		movt	r3, #:upper16:endPointBdts
 3983 0040 D318     		adds	r3, r2, r3
 3984 0042 3B60     		str	r3, [r7, #0]
1859:../Sources/USB.c ****    if (isTx) {
 3985              		.loc 1 1859 0
 3986 0044 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 3987 0046 002B     		cmp	r3, #0
 3988 0048 0FD0     		beq	.L220
1860:../Sources/USB.c ****       epHardwareState[endPoint].txOdd = !isOdd; // Buffer to use next
 3989              		.loc 1 1860 0
 3990 004a B979     		ldrb	r1, [r7, #6]	@ zero_extendqisi2
 3991 004c 3B79     		ldrb	r3, [r7, #4]	@ zero_extendqisi2
 3992 004e 002B     		cmp	r3, #0
 3993 0050 14BF     		ite	ne
 3994 0052 0023     		movne	r3, #0
 3995 0054 0123     		moveq	r3, #1
 3996 0056 D8B2     		uxtb	r0, r3
 3997 0058 40F20003 		movw	r3, #:lower16:epHardwareState
 3998 005c C0F20003 		movt	r3, #:upper16:epHardwareState
 3999 0060 5A5C     		ldrb	r2, [r3, r1]
 4000 0062 60F34102 		bfi	r2, r0, #1, #1
 4001 0066 5A54     		strb	r2, [r3, r1]
 4002 0068 0EE0     		b	.L221
 4003              	.L220:
1861:../Sources/USB.c ****    }
1862:../Sources/USB.c ****    else {
1863:../Sources/USB.c ****       epHardwareState[endPoint].rxOdd = !isOdd; // Buffer to use next
 4004              		.loc 1 1863 0
 4005 006a B979     		ldrb	r1, [r7, #6]	@ zero_extendqisi2
 4006 006c 3B79     		ldrb	r3, [r7, #4]	@ zero_extendqisi2
 4007 006e 002B     		cmp	r3, #0
 4008 0070 14BF     		ite	ne
 4009 0072 0023     		movne	r3, #0
 4010 0074 0123     		moveq	r3, #1
 4011 0076 D8B2     		uxtb	r0, r3
 4012 0078 40F20003 		movw	r3, #:lower16:epHardwareState
 4013 007c C0F20003 		movt	r3, #:upper16:epHardwareState
 4014 0080 5A5C     		ldrb	r2, [r3, r1]
 4015 0082 60F38202 		bfi	r2, r0, #2, #1
 4016 0086 5A54     		strb	r2, [r3, r1]
 4017              	.L221:
1864:../Sources/USB.c ****    }
1865:../Sources/USB.c ****    switch (endPoint) {
 4018              		.loc 1 1865 0
 4019 0088 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 4020 008a 012B     		cmp	r3, #1
 4021 008c 17D0     		beq	.L224
 4022 008e 022B     		cmp	r3, #2
 4023 0090 20D0     		beq	.L225
 4024 0092 002B     		cmp	r3, #0
 4025 0094 29D1     		bne	.L219
 4026              	.L223:
1866:../Sources/USB.c ****        case 0: // Control - Accept IN, OUT or SETUP token
1867:../Sources/USB.c ****           if (isTx) { // IN Transaction complete
 4027              		.loc 1 1867 0
 4028 0096 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 4029 0098 002B     		cmp	r3, #0
 4030 009a 02D0     		beq	.L226
1868:../Sources/USB.c ****              ep0HandleInToken();
 4031              		.loc 1 1868 0
 4032 009c FFF7FEFF 		bl	ep0HandleInToken
1869:../Sources/USB.c ****           }
1870:../Sources/USB.c ****           else if (bdt->u.result.tok_pid == SETUPToken) { // SETUP transaction complete
1871:../Sources/USB.c ****              handleSetupToken();
1872:../Sources/USB.c ****           }
1873:../Sources/USB.c ****           else { // OUT Transaction
1874:../Sources/USB.c ****              ep0HandleOutToken();
1875:../Sources/USB.c ****           }
1876:../Sources/USB.c ****           return;
 4033              		.loc 1 1876 0
 4034 00a0 23E0     		b	.L219
 4035              	.L226:
1870:../Sources/USB.c ****           else if (bdt->u.result.tok_pid == SETUPToken) { // SETUP transaction complete
 4036              		.loc 1 1870 0
 4037 00a2 3B68     		ldr	r3, [r7, #0]
 4038 00a4 1B78     		ldrb	r3, [r3, #0]
 4039 00a6 DBB2     		uxtb	r3, r3
 4040 00a8 03F03C03 		and	r3, r3, #60
 4041 00ac DBB2     		uxtb	r3, r3
 4042 00ae 342B     		cmp	r3, #52
 4043 00b0 02D1     		bne	.L228
1871:../Sources/USB.c ****              handleSetupToken();
 4044              		.loc 1 1871 0
 4045 00b2 FFF7FEFF 		bl	handleSetupToken
 4046              		.loc 1 1876 0
 4047 00b6 18E0     		b	.L219
 4048              	.L228:
1874:../Sources/USB.c ****              ep0HandleOutToken();
 4049              		.loc 1 1874 0
 4050 00b8 FFF7FEFF 		bl	ep0HandleOutToken
 4051              		.loc 1 1876 0
 4052 00bc 15E0     		b	.L219
 4053              	.L224:
1877:../Sources/USB.c ****        case 1: // USBDM BDM - Accept OUT token
1878:../Sources/USB.c ****           usbActivityFlag.flags.bdmActive = 1;
 4054              		.loc 1 1878 0
 4055 00be 40F20003 		movw	r3, #:lower16:usbActivityFlag
 4056 00c2 C0F20003 		movt	r3, #:upper16:usbActivityFlag
 4057 00c6 1A78     		ldrb	r2, [r3, #0]
 4058 00c8 42F00102 		orr	r2, r2, #1
 4059 00cc 1A70     		strb	r2, [r3, #0]
1879:../Sources/USB.c ****           ep1HandleOutToken();
 4060              		.loc 1 1879 0
 4061 00ce FFF7FEFF 		bl	ep1HandleOutToken
1880:../Sources/USB.c ****           return;
 4062              		.loc 1 1880 0
 4063 00d2 0AE0     		b	.L219
 4064              	.L225:
1881:../Sources/USB.c ****        case 2: // USBDM BDM - Accept IN token
1882:../Sources/USB.c ****           usbActivityFlag.flags.bdmActive = 1;
 4065              		.loc 1 1882 0
 4066 00d4 40F20003 		movw	r3, #:lower16:usbActivityFlag
 4067 00d8 C0F20003 		movt	r3, #:upper16:usbActivityFlag
 4068 00dc 1A78     		ldrb	r2, [r3, #0]
 4069 00de 42F00102 		orr	r2, r2, #1
 4070 00e2 1A70     		strb	r2, [r3, #0]
1883:../Sources/USB.c ****           ep2HandleInToken();
 4071              		.loc 1 1883 0
 4072 00e4 FFF7FEFF 		bl	ep2HandleInToken
1884:../Sources/USB.c ****           return;
 4073              		.loc 1 1884 0
 4074 00e8 00BF     		nop
 4075              	.L219:
1885:../Sources/USB.c **** #if (HW_CAPABILITY&CAP_CDC)
1886:../Sources/USB.c ****        case 3: // USBDM CDC Control - Accept IN token
1887:../Sources/USB.c ****           epHardwareState[3].data0_1 = !epHardwareState[3].data0_1; // Toggle data0/1
1888:../Sources/USB.c ****           ep3StartTxTransaction();
1889:../Sources/USB.c ****           return;
1890:../Sources/USB.c ****        case 4: // USBDM CDC Data - Accept OUT token
1891:../Sources/USB.c **** //          usbActivityFlag.flags.serialOutActive = 1;
1892:../Sources/USB.c ****           if (cdc_txBufferIsFree()) {
1893:../Sources/USB.c ****              ep4SaveRxData();
1894:../Sources/USB.c ****              ep4InitialiseBdtRx();
1895:../Sources/USB.c ****           }
1896:../Sources/USB.c ****           else {
1897:../Sources/USB.c ****              //! Throttle endpoint - send NAKs
1898:../Sources/USB.c ****              epHardwareState[4].state = EPThrottle;
1899:../Sources/USB.c ****           }
1900:../Sources/USB.c ****           return;
1901:../Sources/USB.c ****        case 5:  // USBD CDC Data - Accept IN token           
1902:../Sources/USB.c **** //           usbActivityFlag.flags.serialInActive = 1;
1903:../Sources/USB.c **** #if 0
1904:../Sources/USB.c ****           if (epHardwareState[5].state == EPDataIn) {
1905:../Sources/USB.c ****              epHardwareState[5].state = EPLastIn;
1906:../Sources/USB.c ****           }
1907:../Sources/USB.c ****           else {
1908:../Sources/USB.c ****               epHardwareState[5].state = EPIdle;
1909:../Sources/USB.c ****           }
1910:../Sources/USB.c **** #else
1911:../Sources/USB.c **** //#if (DEBUG&USB_PING_DEBUG)
1912:../Sources/USB.c **** //          DEBUG_PIN_PSOR = DEBUG_PIN_MASK;
1913:../Sources/USB.c **** //#endif          
1914:../Sources/USB.c ****           epHardwareState[5].state = EPIdle;
1915:../Sources/USB.c **** //          RTCMOD = 0;
1916:../Sources/USB.c **** //          rtcCount = 0;
1917:../Sources/USB.c **** #endif
1918:../Sources/USB.c **** //          ep5StartInTransactionIfIdle();
1919:../Sources/USB.c ****           return;
1920:../Sources/USB.c **** #endif
1921:../Sources/USB.c ****    }
1922:../Sources/USB.c **** }
 4076              		.loc 1 1922 0
 4077 00ea 07F10807 		add	r7, r7, #8
 4078 00ee BD46     		mov	sp, r7
 4079 00f0 80BD     		pop	{r7, pc}
 4080              		.cfi_endproc
 4081              	.LFE42:
 4083 00f2 00BF     		.section	.text.handleSOFToken,"ax",%progbits
 4084              		.align	2
 4085              		.thumb
 4086              		.thumb_func
 4088              	handleSOFToken:
 4089              	.LFB43:
1923:../Sources/USB.c **** 
1924:../Sources/USB.c **** //#pragma MESSAGE DISABLE C4003
1925:../Sources/USB.c **** //==================================================================
1926:../Sources/USB.c **** // Handler for Start of Frame Token interrupt (~1ms interval)
1927:../Sources/USB.c **** //
1928:../Sources/USB.c **** static void handleSOFToken( void ) {
 4090              		.loc 1 1928 0
 4091              		.cfi_startproc
 4092              		@ args = 0, pretend = 0, frame = 0
 4093              		@ frame_needed = 1, uses_anonymous_args = 0
 4094              		@ link register save eliminated.
 4095 0000 80B4     		push	{r7}
 4096              	.LCFI113:
 4097              		.cfi_def_cfa_offset 4
 4098              		.cfi_offset 7, -4
 4099 0002 00AF     		add	r7, sp, #0
 4100              	.LCFI114:
 4101              		.cfi_def_cfa_register 7
1929:../Sources/USB.c ****    // Green LED
1930:../Sources/USB.c ****    // Off                     - no USB activity, not connected
1931:../Sources/USB.c ****    // On                      - no USB activity, connected
1932:../Sources/USB.c ****    // Off, flash briefly on   - USB activity, not connected
1933:../Sources/USB.c ****    // On,  flash briefly off  - USB activity, connected
1934:../Sources/USB.c ****    if (USB0_FRMNUML==0) { // Every ~256 ms
 4102              		.loc 1 1934 0
 4103 0004 4FF40053 		mov	r3, #8192
 4104 0008 C4F20703 		movt	r3, 16391
 4105 000c 93F8A030 		ldrb	r3, [r3, #160]
 4106 0010 DBB2     		uxtb	r3, r3
 4107 0012 002B     		cmp	r3, #0
 4108 0014 23D1     		bne	.L229
1935:../Sources/USB.c ****       switch (USB0_FRMNUMH&0x03) {
 4109              		.loc 1 1935 0
 4110 0016 4FF40053 		mov	r3, #8192
 4111 001a C4F20703 		movt	r3, 16391
 4112 001e 93F8A430 		ldrb	r3, [r3, #164]
 4113 0022 DBB2     		uxtb	r3, r3
 4114 0024 03F00303 		and	r3, r3, #3
 4115 0028 002B     		cmp	r3, #0
 4116 002a 15D0     		beq	.L235
 4117 002c 002B     		cmp	r3, #0
 4118 002e 02DB     		blt	.L231
 4119 0030 022B     		cmp	r3, #2
 4120 0032 00DC     		bgt	.L231
1936:../Sources/USB.c ****          case 0:
1937:../Sources/USB.c ****             if (deviceState.state == USBconfigured) {
1938:../Sources/USB.c ****                 // Green LED on when USB connection established
1939:../Sources/USB.c **** //                greenLedOn(); 
1940:../Sources/USB.c ****             }
1941:../Sources/USB.c ****             else {
1942:../Sources/USB.c ****                 // Green LED off when no USB connection
1943:../Sources/USB.c **** //                greenLedOff(); 
1944:../Sources/USB.c ****             }
1945:../Sources/USB.c ****             break;
1946:../Sources/USB.c ****          case 1:
1947:../Sources/USB.c ****          case 2:
1948:../Sources/USB.c ****             break;
 4121              		.loc 1 1948 0
 4122 0034 13E0     		b	.L229
 4123              	.L231:
1949:../Sources/USB.c ****          case 3:
1950:../Sources/USB.c ****          default :
1951:../Sources/USB.c ****             if (usbActivityFlag.flags.bdmActive) { 
 4124              		.loc 1 1951 0
 4125 0036 40F20003 		movw	r3, #:lower16:usbActivityFlag
 4126 003a C0F20003 		movt	r3, #:upper16:usbActivityFlag
 4127 003e 1B68     		ldr	r3, [r3, #0]
 4128 0040 03F00103 		and	r3, r3, #1
 4129 0044 002B     		cmp	r3, #0
 4130 0046 09D0     		beq	.L236
1952:../Sources/USB.c ****                // Green LED flashes on USB activity
1953:../Sources/USB.c **** //               greenLedToggle();
1954:../Sources/USB.c ****                usbActivityFlag.byte = 0;
 4131              		.loc 1 1954 0
 4132 0048 40F20003 		movw	r3, #:lower16:usbActivityFlag
 4133 004c C0F20003 		movt	r3, #:upper16:usbActivityFlag
 4134 0050 4FF00002 		mov	r2, #0
 4135 0054 1A70     		strb	r2, [r3, #0]
1955:../Sources/USB.c ****             }
1956:../Sources/USB.c ****             break;            
 4136              		.loc 1 1956 0
 4137 0056 01E0     		b	.L236
 4138              	.L235:
1945:../Sources/USB.c ****             break;
 4139              		.loc 1 1945 0
 4140 0058 00BF     		nop
 4141 005a 00E0     		b	.L229
 4142              	.L236:
 4143              		.loc 1 1956 0
 4144 005c 00BF     		nop
 4145              	.L229:
1957:../Sources/USB.c ****          }
1958:../Sources/USB.c ****    }
1959:../Sources/USB.c **** #if (HW_CAPABILITY&CAP_CDC)
1960:../Sources/USB.c ****    // Check if need to restart EP5 (CDC IN)
1961:../Sources/USB.c ****    ep5StartTxTransactionIfIdle();
1962:../Sources/USB.c **** //   if (serialDelayCount++>SERIAL_THRESHOLD) {
1963:../Sources/USB.c **** //     ep5StartInTransactionIfIdle();
1964:../Sources/USB.c **** //   }
1965:../Sources/USB.c **** #endif
1966:../Sources/USB.c **** #if (HW_CAPABILITY&CAP_CDC) && 0
1967:../Sources/USB.c ****    // Check for need to restart idle EP3
1968:../Sources/USB.c ****    ep3StartInTransactionIfIdle();
1969:../Sources/USB.c **** #endif   
1970:../Sources/USB.c **** }
 4146              		.loc 1 1970 0
 4147 005e BD46     		mov	sp, r7
 4148 0060 80BC     		pop	{r7}
 4149 0062 7047     		bx	lr
 4150              		.cfi_endproc
 4151              	.LFE43:
 4153              		.section	.text.handleUSBSuspend,"ax",%progbits
 4154              		.align	2
 4155              		.thumb
 4156              		.thumb_func
 4158              	handleUSBSuspend:
 4159              	.LFB44:
1971:../Sources/USB.c **** //#pragma MESSAGE DEFAULT C4003
1972:../Sources/USB.c **** #if (HW_CAPABILITY&CAP_CDC)
1973:../Sources/USB.c **** void checkUsbCdcTxData(void) {
1974:../Sources/USB.c ****    // Check if we need to unThrottle EP4
1975:../Sources/USB.c ****    if ((epHardwareState[4].state == EPThrottle) && cdc_txBufferIsFree()) {
1976:../Sources/USB.c ****       ep4SaveRxData();        // Save data from last transfer
1977:../Sources/USB.c ****       ep4InitialiseBdtRx();   // Set up next transfer
1978:../Sources/USB.c ****       epHardwareState[4].state = EPDataOut;
1979:../Sources/USB.c ****    }
1980:../Sources/USB.c **** }
1981:../Sources/USB.c **** #endif
1982:../Sources/USB.c **** //==================================================================
1983:../Sources/USB.c **** // Handler for USB Suspend
1984:../Sources/USB.c **** //
1985:../Sources/USB.c **** // * Enables the USB module to wakeup the CPU 
1986:../Sources/USB.c **** // * Stops the CPU
1987:../Sources/USB.c **** // On wakeup
1988:../Sources/USB.c **** // * Re-checks the USB after a small delay to avoid wakeups by noise
1989:../Sources/USB.c **** //
1990:../Sources/USB.c **** static void handleUSBSuspend( void ) {
 4160              		.loc 1 1990 0
 4161              		.cfi_startproc
 4162              		@ args = 0, pretend = 0, frame = 8
 4163              		@ frame_needed = 1, uses_anonymous_args = 0
 4164              		@ link register save eliminated.
 4165 0000 80B4     		push	{r7}
 4166              	.LCFI115:
 4167              		.cfi_def_cfa_offset 4
 4168              		.cfi_offset 7, -4
 4169 0002 83B0     		sub	sp, sp, #12
 4170              	.LCFI116:
 4171              		.cfi_def_cfa_offset 16
 4172 0004 00AF     		add	r7, sp, #0
 4173              	.LCFI117:
 4174              		.cfi_def_cfa_register 7
1991:../Sources/USB.c ****    int delay;
1992:../Sources/USB.c ****    
1993:../Sources/USB.c ****    USB0_ISTAT = USB_ISTAT_SLEEP_MASK;   // Clear the sleep int flag                    
 4175              		.loc 1 1993 0
 4176 0006 4FF40053 		mov	r3, #8192
 4177 000a C4F20703 		movt	r3, 16391
 4178 000e 4FF01002 		mov	r2, #16
 4179 0012 83F88020 		strb	r2, [r3, #128]
1994:../Sources/USB.c ****    // Need to disable BDM interface & everything else to reduce power
1995:../Sources/USB.c **** //   bdm_suspend();
1996:../Sources/USB.c ****    deviceState.state = USBsuspended;
 4180              		.loc 1 1996 0
 4181 0016 40F20003 		movw	r3, #:lower16:deviceState
 4182 001a C0F20003 		movt	r3, #:upper16:deviceState
 4183 001e 1A78     		ldrb	r2, [r3, #0]
 4184 0020 4FF00501 		mov	r1, #5
 4185 0024 61F30702 		bfi	r2, r1, #0, #8
 4186 0028 1A70     		strb	r2, [r3, #0]
 4187 002a 00E0     		b	.L242
 4188              	.L244:
1997:../Sources/USB.c **** 
1998:../Sources/USB.c ****    // A re-check loop is used here to ensure USB bus noise doesn't wakeup the CPU
1999:../Sources/USB.c ****    for(;;) {
2000:../Sources/USB.c ****       USB0_ISTAT  = USB_ISTAT_RESUME_MASK;       // Clear resume int flag
2001:../Sources/USB.c ****       USB0_INTEN |= USB_INTEN_RESUMEEN_MASK;     // Enable resume detection interrupts on the USB b
2002:../Sources/USB.c ****       USB0_CTL   |= USB_CTL_RESUME_SHIFT;        // Allow the USB module to wakeup the CPU
2003:../Sources/USB.c ****      
2004:../Sources/USB.c ****       asm ("wfi");  // Processor stop for low power
2005:../Sources/USB.c **** 
2006:../Sources/USB.c ****       // The CPU has woken up!
2007:../Sources/USB.c **** 
2008:../Sources/USB.c ****       USB0_ISTAT = USB_ISTAT_RESUME_MASK;  // Clear resume int flag
2009:../Sources/USB.c ****       
2010:../Sources/USB.c ****       //Todo
2011:../Sources/USB.c ****       for(delay=0; delay<10000; delay++) {
2012:../Sources/USB.c ****       }
2013:../Sources/USB.c ****       // We should have another resume int by now
2014:../Sources/USB.c ****       if (USB0_ISTAT&USB_ISTAT_RESUME_MASK) {
2015:../Sources/USB.c ****          break;
2016:../Sources/USB.c ****       }
2017:../Sources/USB.c ****    }
 4189              		.loc 1 2017 0
 4190 002c 00BF     		nop
 4191              	.L242:
2000:../Sources/USB.c ****       USB0_ISTAT  = USB_ISTAT_RESUME_MASK;       // Clear resume int flag
 4192              		.loc 1 2000 0
 4193 002e 4FF40053 		mov	r3, #8192
 4194 0032 C4F20703 		movt	r3, 16391
 4195 0036 4FF02002 		mov	r2, #32
 4196 003a 83F88020 		strb	r2, [r3, #128]
2001:../Sources/USB.c ****       USB0_INTEN |= USB_INTEN_RESUMEEN_MASK;     // Enable resume detection interrupts on the USB b
 4197              		.loc 1 2001 0
 4198 003e 4FF40053 		mov	r3, #8192
 4199 0042 C4F20703 		movt	r3, 16391
 4200 0046 4FF40052 		mov	r2, #8192
 4201 004a C4F20702 		movt	r2, 16391
 4202 004e 92F88420 		ldrb	r2, [r2, #132]
 4203 0052 D2B2     		uxtb	r2, r2
 4204 0054 42F02002 		orr	r2, r2, #32
 4205 0058 D2B2     		uxtb	r2, r2
 4206 005a 83F88420 		strb	r2, [r3, #132]
2002:../Sources/USB.c ****       USB0_CTL   |= USB_CTL_RESUME_SHIFT;        // Allow the USB module to wakeup the CPU
 4207              		.loc 1 2002 0
 4208 005e 4FF40053 		mov	r3, #8192
 4209 0062 C4F20703 		movt	r3, 16391
 4210 0066 4FF40052 		mov	r2, #8192
 4211 006a C4F20702 		movt	r2, 16391
 4212 006e 92F89420 		ldrb	r2, [r2, #148]
 4213 0072 D2B2     		uxtb	r2, r2
 4214 0074 42F00202 		orr	r2, r2, #2
 4215 0078 D2B2     		uxtb	r2, r2
 4216 007a 83F89420 		strb	r2, [r3, #148]
2004:../Sources/USB.c ****       asm ("wfi");  // Processor stop for low power
 4217              		.loc 1 2004 0
 4218              	@ 2004 "../Sources/USB.c" 1
 4219 007e 30BF     		wfi
 4220              	@ 0 "" 2
2008:../Sources/USB.c ****       USB0_ISTAT = USB_ISTAT_RESUME_MASK;  // Clear resume int flag
 4221              		.loc 1 2008 0
 4222              		.thumb
 4223 0080 4FF40053 		mov	r3, #8192
 4224 0084 C4F20703 		movt	r3, 16391
 4225 0088 4FF02002 		mov	r2, #32
 4226 008c 83F88020 		strb	r2, [r3, #128]
2011:../Sources/USB.c ****       for(delay=0; delay<10000; delay++) {
 4227              		.loc 1 2011 0
 4228 0090 4FF00003 		mov	r3, #0
 4229 0094 7B60     		str	r3, [r7, #4]
 4230 0096 03E0     		b	.L238
 4231              	.L239:
2011:../Sources/USB.c ****       for(delay=0; delay<10000; delay++) {
 4232              		.loc 1 2011 0 is_stmt 0
 4233 0098 7B68     		ldr	r3, [r7, #4]
 4234 009a 03F10103 		add	r3, r3, #1
 4235 009e 7B60     		str	r3, [r7, #4]
 4236              	.L238:
2011:../Sources/USB.c ****       for(delay=0; delay<10000; delay++) {
 4237              		.loc 1 2011 0
 4238 00a0 7A68     		ldr	r2, [r7, #4]
 4239 00a2 42F20F73 		movw	r3, #9999
 4240 00a6 9A42     		cmp	r2, r3
 4241 00a8 F6DD     		ble	.L239
2014:../Sources/USB.c ****       if (USB0_ISTAT&USB_ISTAT_RESUME_MASK) {
 4242              		.loc 1 2014 0 is_stmt 1
 4243 00aa 4FF40053 		mov	r3, #8192
 4244 00ae C4F20703 		movt	r3, 16391
 4245 00b2 93F88030 		ldrb	r3, [r3, #128]
 4246 00b6 DBB2     		uxtb	r3, r3
 4247 00b8 03F02003 		and	r3, r3, #32
 4248 00bc 002B     		cmp	r3, #0
 4249 00be B5D0     		beq	.L244
2015:../Sources/USB.c ****          break;
 4250              		.loc 1 2015 0
 4251 00c0 00BF     		nop
2018:../Sources/USB.c ****    USB0_CTL |= USB_CTL_RESUME_MASK;  
 4252              		.loc 1 2018 0
 4253 00c2 4FF40053 		mov	r3, #8192
 4254 00c6 C4F20703 		movt	r3, 16391
 4255 00ca 4FF40052 		mov	r2, #8192
 4256 00ce C4F20702 		movt	r2, 16391
 4257 00d2 92F89420 		ldrb	r2, [r2, #148]
 4258 00d6 D2B2     		uxtb	r2, r2
 4259 00d8 42F00402 		orr	r2, r2, #4
 4260 00dc D2B2     		uxtb	r2, r2
 4261 00de 83F89420 		strb	r2, [r3, #148]
2019:../Sources/USB.c **** 
2020:../Sources/USB.c ****    return;
 4262              		.loc 1 2020 0
 4263 00e2 00BF     		nop
2021:../Sources/USB.c **** }
 4264              		.loc 1 2021 0
 4265 00e4 07F10C07 		add	r7, r7, #12
 4266 00e8 BD46     		mov	sp, r7
 4267 00ea 80BC     		pop	{r7}
 4268 00ec 7047     		bx	lr
 4269              		.cfi_endproc
 4270              	.LFE44:
 4272 00ee 00BF     		.section	.text.handleUSBResume,"ax",%progbits
 4273              		.align	2
 4274              		.thumb
 4275              		.thumb_func
 4277              	handleUSBResume:
 4278              	.LFB45:
2022:../Sources/USB.c **** 
2023:../Sources/USB.c **** //==================================================================
2024:../Sources/USB.c **** // Handler for USB Resume
2025:../Sources/USB.c **** // 
2026:../Sources/USB.c **** // Disables further USB module wakeups
2027:../Sources/USB.c **** static void handleUSBResume( void ) {
 4279              		.loc 1 2027 0
 4280              		.cfi_startproc
 4281              		@ args = 0, pretend = 0, frame = 0
 4282              		@ frame_needed = 1, uses_anonymous_args = 0
 4283 0000 80B5     		push	{r7, lr}
 4284              	.LCFI118:
 4285              		.cfi_def_cfa_offset 8
 4286              		.cfi_offset 7, -8
 4287              		.cfi_offset 14, -4
 4288 0002 00AF     		add	r7, sp, #0
 4289              	.LCFI119:
 4290              		.cfi_def_cfa_register 7
2028:../Sources/USB.c ****    USB0_INTEN &= ~ USB_INTEN_RESUMEEN_MASK;         // Mask further resume ints
 4291              		.loc 1 2028 0
 4292 0004 4FF40053 		mov	r3, #8192
 4293 0008 C4F20703 		movt	r3, 16391
 4294 000c 4FF40052 		mov	r2, #8192
 4295 0010 C4F20702 		movt	r2, 16391
 4296 0014 92F88420 		ldrb	r2, [r2, #132]
 4297 0018 D2B2     		uxtb	r2, r2
 4298 001a 22F02002 		bic	r2, r2, #32
 4299 001e D2B2     		uxtb	r2, r2
 4300 0020 83F88420 		strb	r2, [r3, #132]
2029:../Sources/USB.c ****    USB0_CTL   |= USB_CTL_TXSUSPENDTOKENBUSY_MASK;   // Enable the transmit or receive of packets
 4301              		.loc 1 2029 0
 4302 0024 4FF40053 		mov	r3, #8192
 4303 0028 C4F20703 		movt	r3, 16391
 4304 002c 4FF40052 		mov	r2, #8192
 4305 0030 C4F20702 		movt	r2, 16391
 4306 0034 92F89420 		ldrb	r2, [r2, #148]
 4307 0038 D2B2     		uxtb	r2, r2
 4308 003a 42F02002 		orr	r2, r2, #32
 4309 003e D2B2     		uxtb	r2, r2
 4310 0040 83F89420 		strb	r2, [r3, #148]
2030:../Sources/USB.c ****    deviceState.state = USBconfigured;
 4311              		.loc 1 2030 0
 4312 0044 40F20003 		movw	r3, #:lower16:deviceState
 4313 0048 C0F20003 		movt	r3, #:upper16:deviceState
 4314 004c 1A78     		ldrb	r2, [r3, #0]
 4315 004e 4FF00401 		mov	r1, #4
 4316 0052 61F30702 		bfi	r2, r1, #0, #8
 4317 0056 1A70     		strb	r2, [r3, #0]
2031:../Sources/USB.c **** 
2032:../Sources/USB.c ****    // Set up to receive setup packet
2033:../Sources/USB.c ****    ep0ConfigureSetupTransaction(); // re-initialise EP0 OUT // v4.7
 4318              		.loc 1 2033 0
 4319 0058 FFF7FEFF 		bl	ep0ConfigureSetupTransaction
2034:../Sources/USB.c ****    // power up BDM interface?
2035:../Sources/USB.c **** }
 4320              		.loc 1 2035 0
 4321 005c 80BD     		pop	{r7, pc}
 4322              		.cfi_endproc
 4323              	.LFE45:
 4325 005e 00BF     		.section	.text.USB0_IRQHandler,"ax",%progbits
 4326              		.align	2
 4327              		.global	USB0_IRQHandler
 4328              		.thumb
 4329              		.thumb_func
 4331              	USB0_IRQHandler:
 4332              	.LFB46:
2036:../Sources/USB.c **** 
2037:../Sources/USB.c **** //==================================================================
2038:../Sources/USB.c **** // Handler for USB interrupt
2039:../Sources/USB.c **** // 
2040:../Sources/USB.c **** // Determines source and dispatches to appropriate routine.
2041:../Sources/USB.c **** //
2042:../Sources/USB.c **** //! Handler for USB interrupts
2043:../Sources/USB.c **** void USB0_IRQHandler( void ) {
 4333              		.loc 1 2043 0
 4334              		.cfi_startproc
 4335              		@ args = 0, pretend = 0, frame = 8
 4336              		@ frame_needed = 1, uses_anonymous_args = 0
 4337 0000 80B5     		push	{r7, lr}
 4338              	.LCFI120:
 4339              		.cfi_def_cfa_offset 8
 4340              		.cfi_offset 7, -8
 4341              		.cfi_offset 14, -4
 4342 0002 82B0     		sub	sp, sp, #8
 4343              	.LCFI121:
 4344              		.cfi_def_cfa_offset 16
 4345 0004 00AF     		add	r7, sp, #0
 4346              	.LCFI122:
 4347              		.cfi_def_cfa_register 7
2044:../Sources/USB.c **** uint8_t interruptFlags = USB0_ISTAT;
 4348              		.loc 1 2044 0
 4349 0006 4FF40053 		mov	r3, #8192
 4350 000a C4F20703 		movt	r3, 16391
 4351 000e 93F88030 		ldrb	r3, [r3, #128]
 4352 0012 FB71     		strb	r3, [r7, #7]
2045:../Sources/USB.c **** 
2046:../Sources/USB.c ****    if ((interruptFlags&USB_ISTAT_TOKDNE_MASK) != 0) { // Token complete int?
 4353              		.loc 1 2046 0
 4354 0014 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4355 0016 03F00803 		and	r3, r3, #8
 4356 001a 002B     		cmp	r3, #0
 4357 001c 0AD0     		beq	.L247
2047:../Sources/USB.c ****       handleTokenComplete();
 4358              		.loc 1 2047 0
 4359 001e FFF7FEFF 		bl	handleTokenComplete
2048:../Sources/USB.c ****       USB0_ISTAT = USB_ISTAT_TOKDNE_MASK; // Clear source
 4360              		.loc 1 2048 0
 4361 0022 4FF40053 		mov	r3, #8192
 4362 0026 C4F20703 		movt	r3, 16391
 4363 002a 4FF00802 		mov	r2, #8
 4364 002e 83F88020 		strb	r2, [r3, #128]
 4365 0032 55E0     		b	.L246
 4366              	.L247:
2049:../Sources/USB.c ****    }
2050:../Sources/USB.c **** //   else if ((USBCTL0_LPRESF) && (deviceState.state==USBsuspended)) {
2051:../Sources/USB.c **** //      USBCTL0_USBRESMEN = 0;
2052:../Sources/USB.c **** //   }
2053:../Sources/USB.c ****    else if ((interruptFlags&USB_ISTAT_RESUME_MASK) != 0) { // Resume signalled on Bus?
 4367              		.loc 1 2053 0
 4368 0034 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4369 0036 03F02003 		and	r3, r3, #32
 4370 003a 002B     		cmp	r3, #0
 4371 003c 0AD0     		beq	.L249
2054:../Sources/USB.c ****       handleUSBResume();
 4372              		.loc 1 2054 0
 4373 003e FFF7FEFF 		bl	handleUSBResume
2055:../Sources/USB.c ****       USB0_ISTAT = USB_ISTAT_RESUME_MASK; // Clear source
 4374              		.loc 1 2055 0
 4375 0042 4FF40053 		mov	r3, #8192
 4376 0046 C4F20703 		movt	r3, 16391
 4377 004a 4FF02002 		mov	r2, #32
 4378 004e 83F88020 		strb	r2, [r3, #128]
 4379 0052 45E0     		b	.L246
 4380              	.L249:
2056:../Sources/USB.c ****    }
2057:../Sources/USB.c ****    else if ((interruptFlags&USB_ISTAT_USBRST_MASK) != 0) {
 4381              		.loc 1 2057 0
 4382 0054 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4383 0056 03F00103 		and	r3, r3, #1
 4384 005a 002B     		cmp	r3, #0
 4385 005c 0AD0     		beq	.L250
2058:../Sources/USB.c ****       handleUSBReset();
 4386              		.loc 1 2058 0
 4387 005e FFF7FEFF 		bl	handleUSBReset
2059:../Sources/USB.c ****       USB0_ISTAT = USB_ISTAT_USBRST_MASK; // Clear source
 4388              		.loc 1 2059 0
 4389 0062 4FF40053 		mov	r3, #8192
 4390 0066 C4F20703 		movt	r3, 16391
 4391 006a 4FF00102 		mov	r2, #1
 4392 006e 83F88020 		strb	r2, [r3, #128]
 4393 0072 35E0     		b	.L246
 4394              	.L250:
2060:../Sources/USB.c ****    }
2061:../Sources/USB.c ****    else if ((interruptFlags&USB_ISTAT_STALL_MASK) != 0) { // Stall sent?
 4395              		.loc 1 2061 0
 4396 0074 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4397 0076 5BB2     		sxtb	r3, r3
 4398 0078 002B     		cmp	r3, #0
 4399 007a 0ADA     		bge	.L251
2062:../Sources/USB.c ****       ep0HandleStallComplete();
 4400              		.loc 1 2062 0
 4401 007c FFF7FEFF 		bl	ep0HandleStallComplete
2063:../Sources/USB.c ****       USB0_ISTAT = USB_ISTAT_STALL_MASK; // Clear source
 4402              		.loc 1 2063 0
 4403 0080 4FF40053 		mov	r3, #8192
 4404 0084 C4F20703 		movt	r3, 16391
 4405 0088 4FF08002 		mov	r2, #128
 4406 008c 83F88020 		strb	r2, [r3, #128]
 4407 0090 26E0     		b	.L246
 4408              	.L251:
2064:../Sources/USB.c ****    }
2065:../Sources/USB.c ****    else if ((interruptFlags&USB_ISTAT_SOFTOK_MASK) != 0) { // SOF Token?
 4409              		.loc 1 2065 0
 4410 0092 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4411 0094 03F00403 		and	r3, r3, #4
 4412 0098 002B     		cmp	r3, #0
 4413 009a 0AD0     		beq	.L252
2066:../Sources/USB.c ****       handleSOFToken();
 4414              		.loc 1 2066 0
 4415 009c FFF7FEFF 		bl	handleSOFToken
2067:../Sources/USB.c ****       USB0_ISTAT = USB_ISTAT_SOFTOK_MASK; // Clear source
 4416              		.loc 1 2067 0
 4417 00a0 4FF40053 		mov	r3, #8192
 4418 00a4 C4F20703 		movt	r3, 16391
 4419 00a8 4FF00402 		mov	r2, #4
 4420 00ac 83F88020 		strb	r2, [r3, #128]
 4421 00b0 16E0     		b	.L246
 4422              	.L252:
2068:../Sources/USB.c ****    }
2069:../Sources/USB.c ****    else if ((interruptFlags&USB_ISTAT_SLEEP_MASK) != 0) { // Bus Idle 3ms? => sleep
 4423              		.loc 1 2069 0
 4424 00b2 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4425 00b4 03F01003 		and	r3, r3, #16
 4426 00b8 002B     		cmp	r3, #0
 4427 00ba 0AD0     		beq	.L253
2070:../Sources/USB.c ****       handleUSBSuspend();
 4428              		.loc 1 2070 0
 4429 00bc FFF7FEFF 		bl	handleUSBSuspend
2071:../Sources/USB.c ****       USB0_ISTAT = USB_ISTAT_SLEEP_MASK; // Clear source
 4430              		.loc 1 2071 0
 4431 00c0 4FF40053 		mov	r3, #8192
 4432 00c4 C4F20703 		movt	r3, 16391
 4433 00c8 4FF01002 		mov	r2, #16
 4434 00cc 83F88020 		strb	r2, [r3, #128]
 4435 00d0 06E0     		b	.L246
 4436              	.L253:
2072:../Sources/USB.c ****    }
2073:../Sources/USB.c ****    else  { // unexpected int
2074:../Sources/USB.c ****       USB0_ISTAT = interruptFlags; // Clear & ignore
 4437              		.loc 1 2074 0
 4438 00d2 4FF40053 		mov	r3, #8192
 4439 00d6 C4F20703 		movt	r3, 16391
 4440 00da FA79     		ldrb	r2, [r7, #7]
 4441 00dc 83F88020 		strb	r2, [r3, #128]
 4442              	.L246:
2075:../Sources/USB.c ****    }
2076:../Sources/USB.c **** }
 4443              		.loc 1 2076 0
 4444 00e0 07F10807 		add	r7, r7, #8
 4445 00e4 BD46     		mov	sp, r7
 4446 00e6 80BD     		pop	{r7, pc}
 4447              		.cfi_endproc
 4448              	.LFE46:
 4450              		.section	.rodata.zeroReturn.5478,"a",%progbits
 4451              		.align	2
 4454              	zeroReturn.5478:
 4455 0000 0000     		.space	2
 4456 0002 0000     		.section	.rodata.epStatusStalled.5479,"a",%progbits
 4457              		.align	2
 4460              	epStatusStalled.5479:
 4461 0000 01       		.byte	1
 4462 0001 00       		.byte	0
 4463 0002 0000     		.space	2
 4464              		.section	.rodata.epStatusOK.5480,"a",%progbits
 4465              		.align	2
 4468              	epStatusOK.5480:
 4469 0000 00000000 		.space	4
 4470              		.text
 4471              	.Letext0:
 4472              		.file 2 "C:/Freescale/CW MCU v10.5/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 4473              		.file 3 "C:/Users/Jay/Documents/MC2/Projects/UNL Rover/BLDCdriver/cw_workspace/USBDM_Kinetis_BLDC/
 4474              		.file 4 "C:/Users/Jay/Documents/MC2/Projects/UNL Rover/BLDCdriver/cw_workspace/USBDM_Kinetis_BLDC/
 4475              		.file 5 "C:/Users/Jay/Documents/MC2/Projects/UNL Rover/BLDCdriver/cw_workspace/USBDM_Kinetis_BLDC/
DEFINED SYMBOLS
                            *ABS*:00000000 USB.c
                            *COM*:0000012c commandBuffer
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:20     .text.noChange32:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:24     .text.noChange32:00000000 noChange32
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:55     .text.noChange16:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:59     .text.noChange16:00000000 noChange16
                            *COM*:00000020 ep0InDataBuffer
                            *COM*:00000020 ep0OutDataBuffer
                            *COM*:00000040 ep1DataBuffer
                            *COM*:00000040 ep2DataBuffer
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:94     .user_data2:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:97     .user_data2:00000000 endPointBdts
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:100    .rodata.deviceDescriptor:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:103    .rodata.deviceDescriptor:00000000 deviceDescriptor
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:119    .rodata.otherDescriptors:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:122    .rodata.otherDescriptors:00000000 otherDescriptors
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:153    .rodata.msCompatibleIdFeatureDescriptor:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:156    .rodata.msCompatibleIdFeatureDescriptor:00000000 msCompatibleIdFeatureDescriptor
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:171    .rodata.msPropertiesFeatureDescriptor:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:174    .rodata.msPropertiesFeatureDescriptor:00000000 msPropertiesFeatureDescriptor
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:191    .rodata.OS_StringDescriptor:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:194    .rodata.OS_StringDescriptor:00000000 OS_StringDescriptor
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:214    .rodata.sd0:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:217    .rodata.sd0:00000000 sd0
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:223    .rodata.sd1:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:226    .rodata.sd1:00000000 sd1
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:229    .rodata.sd2:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:232    .rodata.sd2:00000000 sd2
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:235    .rodata.sd3:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:238    .rodata.sd3:00000000 sd3
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:241    .rodata.sd4:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:244    .rodata.sd4:00000000 sd4
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:247    .rodata.sd5:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:250    .rodata.sd5:00000000 sd5
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:253    .rodata.sd6:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:256    .rodata.sd6:00000000 sd6
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:259    .rodata.sd7:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:262    .rodata.sd7:00000000 sd7
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:265    .rodata.sd8:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:268    .rodata.sd8:00000000 sd8
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:271    .rodata.stringDescriptors:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:274    .rodata.stringDescriptors:00000000 stringDescriptors
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:289    .data.deviceState:00000000 deviceState
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:286    .data.deviceState:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:302    .bss.reInit:00000000 reInit
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:303    .bss.reInit:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:305    .bss.ep0State:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:308    .bss.ep0State:00000000 ep0State
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:311    .bss.ep1State:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:314    .bss.ep1State:00000000 ep1State
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:317    .bss.ep2State:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:320    .bss.ep2State:00000000 ep2State
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:323    .bss.epHardwareState:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:326    .bss.epHardwareState:00000000 epHardwareState
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:329    .bss.usbActivityFlag:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:332    .bss.usbActivityFlag:00000000 usbActivityFlag
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:335    .bss.ep0SetupBuffer:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:338    .bss.ep0SetupBuffer:00000000 ep0SetupBuffer
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:341    .text.initEndpointBuffers:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:345    .text.initEndpointBuffers:00000000 initEndpointBuffers
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:437    .text.ep0InitialiseBdtRx:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:441    .text.ep0InitialiseBdtRx:00000000 ep0InitialiseBdtRx
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:508    .text.ep0InitialiseBdtRx:00000060 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:513    .text.ep0SaveRxData:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:517    .text.ep0SaveRxData:00000000 ep0SaveRxData
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:638    .text.ep0SaveRxData:000000e4 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:643    .text.ep0ConfigureSetupTransaction:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:647    .text.ep0ConfigureSetupTransaction:00000000 ep0ConfigureSetupTransaction
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:676    .text.ep0EnsureReadyForSetupTransaction:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:680    .text.ep0EnsureReadyForSetupTransaction:00000000 ep0EnsureReadyForSetupTransaction
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:736    .text.ep0InitialiseBdtTx:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:740    .text.ep0InitialiseBdtTx:00000000 ep0InitialiseBdtTx
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:867    .text.ep0InitialiseBdtTx:000000f0 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:873    .text.ep0StartTxTransaction:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:877    .text.ep0StartTxTransaction:00000000 ep0StartTxTransaction
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1012   .text.ep1InitialiseBdtRx:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1016   .text.ep1InitialiseBdtRx:00000000 ep1InitialiseBdtRx
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1085   .text.ep1InitialiseBdtRx:00000064 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1091   .text.ep1SaveRxData:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1095   .text.ep1SaveRxData:00000000 ep1SaveRxData
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1212   .text.ep1SaveRxData:000000d8 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1218   .text.ep1StartRxTransaction:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1222   .text.ep1StartRxTransaction:00000000 ep1StartRxTransaction
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1274   .text.ep2InitialiseBdtTx:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1278   .text.ep2InitialiseBdtTx:00000000 ep2InitialiseBdtTx
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1406   .text.ep2InitialiseBdtTx:000000f0 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1412   .text.ep2StartTxTransaction:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1416   .text.ep2StartTxTransaction:00000000 ep2StartTxTransaction
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1482   .text.initialiseEndpoints:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1486   .text.initialiseEndpoints:00000000 initialiseEndpoints
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1823   .text.epClearStall:00000000 epClearStall
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1605   .text.receiveUSBCommand:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1610   .text.receiveUSBCommand:00000000 receiveUSBCommand
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1691   .text.sendUSBResponse:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1696   .text.sendUSBResponse:00000000 sendUSBResponse
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1741   .text.epStall:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1745   .text.epStall:00000000 epStall
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1819   .text.epClearStall:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1879   .text.setUSBdefaultState:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1883   .text.setUSBdefaultState:00000000 setUSBdefaultState
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1927   .text.setUSBaddressedState:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1931   .text.setUSBaddressedState:00000000 setUSBaddressedState
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1989   .text.setUSBconfiguredState:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:1993   .text.setUSBconfiguredState:00000000 setUSBconfiguredState
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:2053   .text.handleUSBReset:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:2057   .text.handleUSBReset:00000000 handleUSBReset
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:2101   .text.initUSB:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:2106   .text.initUSB:00000000 initUSB
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:2247   .text.handleGetStatus:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:2251   .text.handleGetStatus:00000000 handleGetStatus
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:4454   .rodata.zeroReturn.5478:00000000 zeroReturn.5478
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:4460   .rodata.epStatusStalled.5479:00000000 epStatusStalled.5479
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:4468   .rodata.epStatusOK.5480:00000000 epStatusOK.5480
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:2363   .text.handleGetStatus:000000b4 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:2368   .text.handleClearFeature:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:2372   .text.handleClearFeature:00000000 handleClearFeature
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:2486   .text.handleSetFeature:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:2490   .text.handleSetFeature:00000000 handleSetFeature
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:2604   .text.utf8ToStringDescriptor:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:2608   .text.utf8ToStringDescriptor:00000000 utf8ToStringDescriptor
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:2776   .text.handleGetDescriptor:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:2780   .text.handleGetDescriptor:00000000 handleGetDescriptor
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:2831   .text.handleGetDescriptor:00000050 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:2839   .text.handleGetDescriptor:00000068 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:2940   .text.resetDeviceCallback:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:2944   .text.resetDeviceCallback:00000000 resetDeviceCallback
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:2966   .text.setAddressCallback:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:2970   .text.setAddressCallback:00000000 setAddressCallback
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3025   .text.handleSetAddress:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3029   .text.handleSetAddress:00000000 handleSetAddress
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3080   .text.handleGetConfiguration:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3084   .text.handleGetConfiguration:00000000 handleGetConfiguration
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3108   .text.handleGetConfiguration:00000014 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3113   .text.handleSetConfiguration:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3117   .text.handleSetConfiguration:00000000 handleSetConfiguration
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3181   .text.handleGetInterface:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3185   .text.handleGetInterface:00000000 handleGetInterface
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3262   .text.handleUnexpected:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3266   .text.handleUnexpected:00000000 handleUnexpected
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3289   .text.handleSetupToken:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3293   .text.handleSetupToken:00000000 handleSetupToken
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3380   .text.handleSetupToken:000000c4 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3393   .text.handleSetupToken:000000f0 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3455   .text.ep0HandleInToken:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3459   .text.ep0HandleInToken:00000000 ep0HandleInToken
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3596   .text.ep0HandleOutToken:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3600   .text.ep0HandleOutToken:00000000 ep0HandleOutToken
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3717   .text.ep0HandleStallComplete:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3721   .text.ep0HandleStallComplete:00000000 ep0HandleStallComplete
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3746   .text.ep1HandleOutToken:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3750   .text.ep1HandleOutToken:00000000 ep1HandleOutToken
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3844   .text.ep2HandleInToken:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3848   .text.ep2HandleInToken:00000000 ep2HandleInToken
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3938   .text.handleTokenComplete:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:3942   .text.handleTokenComplete:00000000 handleTokenComplete
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:4084   .text.handleSOFToken:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:4088   .text.handleSOFToken:00000000 handleSOFToken
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:4154   .text.handleUSBSuspend:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:4158   .text.handleUSBSuspend:00000000 handleUSBSuspend
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:4273   .text.handleUSBResume:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:4277   .text.handleUSBResume:00000000 handleUSBResume
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:4326   .text.USB0_IRQHandler:00000000 $t
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:4331   .text.USB0_IRQHandler:00000000 USB0_IRQHandler
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:4451   .rodata.zeroReturn.5478:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:4457   .rodata.epStatusStalled.5479:00000000 $d
C:\Users\Jay\AppData\Local\Temp\ccqE5nSx.s:4465   .rodata.epStatusOK.5480:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
memcpy
memset
